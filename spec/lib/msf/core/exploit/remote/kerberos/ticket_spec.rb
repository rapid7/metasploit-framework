# -*- coding:binary -*-

require 'spec_helper'

RSpec.describe Msf::Exploit::Remote::Kerberos::Ticket do
  before do
    Timecop.freeze(Time.parse('Jul 15, 2022 12:33:40.000000000 GMT'))
  end

  after do
    Timecop.return
  end

  let(:pac_type) do
    "\x04\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\xb8\x01\x00\x00" \
    "\x48\x00\x00\x00\x00\x00\x00\x00\x0a\x00\x00\x00\x1e\x00\x00\x00" \
    "\x00\x02\x00\x00\x00\x00\x00\x00\x06\x00\x00\x00\x14\x00\x00\x00" \
    "\x20\x02\x00\x00\x00\x00\x00\x00\x07\x00\x00\x00\x14\x00\x00\x00" \
    "\x38\x02\x00\x00\x00\x00\x00\x00\x01\x10\x08\x00\xcc\xcc\xcc\xcc" \
    "\xa8\x01\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\xea\xc1\x1c" \
    "\x47\x98\xd8\x01\xff\xff\xff\xff\xff\xff\xff\x7f\xff\xff\xff\xff" \
    "\xff\xff\xff\x7f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" \
    "\x00\x00\x00\x00\xff\xff\xff\xff\xff\xff\xff\x7f\x14\x00\x14\x00" \
    "\x04\x00\x02\x00\x00\x00\x00\x00\x08\x00\x02\x00\x00\x00\x00\x00" \
    "\x0c\x00\x02\x00\x00\x00\x00\x00\x10\x00\x02\x00\x00\x00\x00\x00" \
    "\x14\x00\x02\x00\x00\x00\x00\x00\x18\x00\x02\x00\x00\x00\x00\x00" \
    "\xf4\x01\x00\x00\x01\x02\x00\x00\x05\x00\x00\x00\x1c\x00\x02\x00" \
    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" \
    "\x00\x00\x00\x00\x00\x00\x00\x00\x20\x00\x02\x00\x10\x00\x10\x00" \
    "\x24\x00\x02\x00\x28\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00" \
    "\x10\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" \
    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" \
    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" \
    "\x00\x00\x00\x00\x0a\x00\x00\x00\x00\x00\x00\x00\x0a\x00\x00\x00" \
    "\x66\x00\x61\x00\x6b\x00\x65\x00\x5f\x00\x6d\x00\x79\x00\x73\x00" \
    "\x71\x00\x6c\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" \
    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" \
    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" \
    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" \
    "\x05\x00\x00\x00\x01\x02\x00\x00\x07\x00\x00\x00\x00\x02\x00\x00" \
    "\x07\x00\x00\x00\x08\x02\x00\x00\x07\x00\x00\x00\x06\x02\x00\x00" \
    "\x07\x00\x00\x00\x07\x02\x00\x00\x07\x00\x00\x00\x00\x00\x00\x00" \
    "\x00\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x00\x00\x00\x00" \
    "\x08\x00\x00\x00\x44\x00\x57\x00\x2e\x00\x4c\x00\x4f\x00\x43\x00" \
    "\x41\x00\x4c\x00\x04\x00\x00\x00\x01\x04\x00\x00\x00\x00\x00\x05" \
    "\x15\x00\x00\x00\x02\x87\x5a\x55\xfd\x66\x7b\xcc\xf7\xbc\xaf\x16" \
    "\x00\xea\xc1\x1c\x47\x98\xd8\x01\x14\x00\x66\x00\x61\x00\x6b\x00" \
    "\x65\x00\x5f\x00\x6d\x00\x79\x00\x73\x00\x71\x00\x6c\x00\x00\x00" \
    "\x76\xff\xff\xff\x5a\xef\xf8\xbb\xde\xb6\x03\x73\xea\xba\x70\xf6" \
    "\x0e\x09\x5d\x78\x00\x00\x00\x00\x76\xff\xff\xff\x70\x20\xb7\xe2" \
    "\xf9\xcb\xad\xfa\x62\xff\x44\x00\x0a\x08\xc6\xf6\x00\x00\x00\x00"
  end

  describe '#create_ticket' do
    SECS_IN_DAY = 60 * 60 * 24
    let(:current_time) { Time.now }
    let(:nt_hash) { '88E4D9FABAECF3DEC18DD80905521B29' }
    let(:domain_sid) { 'S-1-5-21-1431996162-3430639357-380615927' }
    let(:domain) { 'DW.LOCAL' }
    let(:spn) { ['mysql', 'dw.local'] }
    let(:username) { 'fake_mysql' }
    let(:ticket_key) { [nt_hash].pack('H*') }
    let(:flags) do
      [
        Rex::Proto::Kerberos::Model::TicketFlags::FORWARDABLE,
        Rex::Proto::Kerberos::Model::TicketFlags::PROXIABLE,
        Rex::Proto::Kerberos::Model::TicketFlags::RENEWABLE,
        Rex::Proto::Kerberos::Model::TicketFlags::PRE_AUTHENT
      ]
    end

    subject(:kerberos_ticket) do
      mod = ::Msf::Exploit.new
      mod.extend ::Msf::Exploit::Remote::Kerberos::Client
      mod.extend ::Msf::Exploit::Remote::Kerberos::Ticket
      mod.send(:initialize)
      mod.create_ticket(
        enc_key: ticket_key,
        start_time: current_time,
        end_time: current_time + SECS_IN_DAY * 3650,
        domain_sid: domain_sid,
        domain: domain,
        sname: spn,
        username: username,
        flags: Rex::Proto::Kerberos::Model::TicketFlags.from_flags(flags),
        save_ccache: false
      )
    end

    it { is_expected.to be_a(Rex::Proto::Kerberos::Model::Ticket) }

    describe 'decoding ticket' do
      subject(:ticket) { kerberos_ticket }

      it { expect(subject.realm.to_s).to eq(domain) }
      it { expect(subject.tkt_vno).to eq(Rex::Proto::Kerberos::Model::VERSION) }
      it { expect(subject.sname.name_string.length).to eq(spn.length) }
      it { expect(subject.sname.name_string).to include(*spn) }
      it { expect(subject.enc_part).to be_a(Rex::Proto::Kerberos::Model::EncryptedData) }
    end

    describe 'decrypting ticket' do
      subject(:ticket_enc_part) { kerberos_ticket.enc_part }

      it { expect { subject.decrypt_asn1(ticket_key, Rex::Proto::Kerberos::Crypto::KeyUsage::KDC_REP_TICKET) }.not_to raise_error }
      it { expect(subject.decrypt_asn1(ticket_key, Rex::Proto::Kerberos::Crypto::KeyUsage::KDC_REP_TICKET)).to be_a(String) }

      describe 'decoding ticket enc part' do
        subject(:decrypted_ticket_part) { ticket_enc_part.decrypt_asn1(ticket_key, Rex::Proto::Kerberos::Crypto::KeyUsage::KDC_REP_TICKET) }
        it { expect { Rex::Proto::Kerberos::Model::TicketEncPart.decode(subject) }.not_to raise_error }
        it { expect(Rex::Proto::Kerberos::Model::TicketEncPart.decode(subject)).to be_a(Rex::Proto::Kerberos::Model::TicketEncPart) }

        describe 'ticket enc part' do
          let(:expected_flags) do
            [
              Rex::Proto::Kerberos::Model::TicketFlags::FORWARDABLE,
              Rex::Proto::Kerberos::Model::TicketFlags::PROXIABLE,
              Rex::Proto::Kerberos::Model::TicketFlags::RENEWABLE,
              Rex::Proto::Kerberos::Model::TicketFlags::PRE_AUTHENT
            ]
          end

          subject { Rex::Proto::Kerberos::Model::TicketEncPart.decode(decrypted_ticket_part) }

          describe 'flags' do
            it { expect(subject.flags).to include(*expected_flags) }
          end

          describe 'key' do
            it { expect(subject.key.type).to eq(Rex::Proto::Kerberos::Crypto::Encryption::RC4_HMAC) }
            it { expect(subject.key.value).to be_a(String) }
            it { expect(subject.key.value).not_to eq(ticket_key) }
            it { expect(subject.key.value.length).to eq(16) }
          end

          describe 'crealm' do
            it { expect(subject.crealm).to eq(domain) }
          end

          describe 'cname' do
            it { expect(subject.cname.name_type).to eq(Rex::Proto::Kerberos::Model::NameType::NT_PRINCIPAL) }
            it { expect(subject.cname.name_string).to include(username) }
          end

          describe 'transited' do
            it { expect(subject.transited).to be_a(Rex::Proto::Kerberos::Model::TransitedEncoding) }
          end

          describe 'authtime' do
            it { expect(subject.authtime).to be_a(Time) }
            it { expect(subject.authtime).to eq(current_time) }
          end

          describe 'starttime' do
            it { expect(subject.starttime).to be_a(Time) }
            it { expect(subject.starttime).to eq(current_time) }
          end

          describe 'endtime' do
            it { expect(subject.endtime).to be_a(Time) }
            it { expect(subject.endtime).to be > current_time }
          end

          describe 'renew_till' do
            it { expect(subject.renew_till).to be_a(Time) }
            it { expect(subject.renew_till).to be > current_time }
          end

          describe 'authorization_data' do
            it { expect(subject.authorization_data.elements.length).to eq(1) }
            it { expect(subject.authorization_data.elements[0][:type]).to eq(Rex::Proto::Kerberos::Model::AD_IF_RELEVANT) }
            it { expect { Rex::Proto::Kerberos::Model::AuthorizationData.decode(subject.authorization_data.elements[0][:data]) }.not_to raise_error }
            it { expect(Rex::Proto::Kerberos::Model::AuthorizationData.decode(subject.authorization_data.elements[0][:data])).to be_a(Rex::Proto::Kerberos::Model::AuthorizationData) }
          end
        end
      end
    end

    describe 'pac_auth_data contents' do
      let(:ticket) { kerberos_ticket }
      let(:ticket_enc_part) { kerberos_ticket.enc_part }
      let(:decrypted_ticket_part) { ticket_enc_part.decrypt_asn1(ticket_key, Rex::Proto::Kerberos::Crypto::KeyUsage::KDC_REP_TICKET) }
      let(:decoded_ticket_part) { Rex::Proto::Kerberos::Model::TicketEncPart.decode(decrypted_ticket_part) }

      subject(:pac_auth_data) { Rex::Proto::Kerberos::Model::AuthorizationData.decode(decoded_ticket_part.authorization_data.elements[0][:data]) }

      it { expect(subject.elements.length).to eq(1) }
      it { expect(subject.elements[0][:type]).to eq(Rex::Proto::Kerberos::Pac::AD_WIN2K_PAC) }
      it { expect(subject.elements[0][:data]).to eq(pac_type) }
    end
  end
end
