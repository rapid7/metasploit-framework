require 'msf/core/exploit/compat_defaults'

module Msf::Exploit::Compatibility
  #
  # Returns a list of compatible encoders based on architecture
  #
  def compatible_encoders
    encoders = []

    c_platform = (target and target.platform) ? target.platform : platform
    c_arch     = (target and target.arch)     ? target.arch     : (arch == []) ? nil : arch

    framework.encoders.each_module_ranked(
        'Arch' => c_arch) { |name, mod|

      encoders << [ name, mod ]
    }

    return encoders;
  end

  #
  # Returns a list of compatible payloads based on platform, architecture,
  # and size requirements.
  #
  def compatible_payloads
    payloads = []


    c_platform = (target and target.platform) ? target.platform : platform
    c_arch     = (target and target.arch)     ? target.arch     : (arch == []) ? nil : arch
    c_arch   ||= [ ARCH_X86 ]

    framework.payloads.each_module(
        'Platform' => c_platform,
        'Arch'     => c_arch ) { |name, mod|

      # Skip over payloads that are too big
      if ((payload_space) and
          (framework.payloads.sizes[name]) and
          (framework.payloads.sizes[name] > payload_space))
        dlog("#{refname}: Skipping payload #{name} for being too large", 'core',
             LEV_1)
        next
      end

      # Are we compatible in terms of conventions and connections and
      # what not?
      next if (compatible?(framework.payloads.instance(name)) == false)

      # If the payload is privileged but the exploit does not give
      # privileged access, then fail it.
      next if (self.privileged == false and framework.payloads.instance(name).privileged == true)

      # This one be compatible!
      payloads << [ name, mod ]
    }

    return payloads;
  end

  #
  # Overrides the base class method and serves to initialize default
  # compatibilities for exploits
  #
  def init_compat
    super

    #
    # Merge in payload compatible defaults
    #
    p = module_info['Compat']['Payload']

    Msf::Exploit::CompatDefaults::Payload.each_pair { |k,v|
      (p[k]) ? p[k] << " #{v}" : p[k] = v
    }

    #
    # Set the default save registers if none have been explicitly
    # specified.
    #
    if (module_info['SaveRegisters'] == nil)
      module_info['SaveRegisters'] = [ 'esp', 'ebp' ]
    end
  end
end