# -*- coding: binary -*-
module Msf

###
#
# This module provides a way of interacting with wordpress installations
#
###
	module Exploit::Remote::Wordpress
		include Exploit::Remote::HttpClient
		include Msf::Auxiliary::Report

		def initialize(info = {})
			super

			register_options(
					[
							OptString.new('TARGETURI', [true, 'The base path to the wordpress application', '/']),
					], Exploit::Remote::Wordpress
			)
		end

		# Checks if the site is online and running wordpress
		def wp_wordpress_and_online?
			begin
				res = send_request_cgi({
																	 'method' => 'GET',
																	 'uri' => normalize_uri(target_uri)
															 }, 20)
				if res and res.code == 200
					if res.body =~ /["'][^"']*\/wp-content\/[^"']*["']/i or
							res.body =~ /<link rel=["']wlwmanifest["'].*href=["'].*\/wp-includes\/wlwmanifest\.xml["'] \/>/i or
							res.body =~ /<link rel=["']pingback["'].*href=["'].*\/xmlrpc\.php["'] \/>/i
						return true
					else
						print_error("#{target_uri} does not seeem to be Wordpress site")
						return false
					end
				end
			rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout
			rescue ::Timeout::Error, ::Errno::EPIPE
				print_error("Error connecting to #{target_uri}")
				return false
			end

			return false
		end

		def wp_uri_login
			normalize_uri(target_uri.path, 'wp-login.php')
		end

		def wp_url_post(post_id)
			normalize_uri(target_uri.path) + "/?p=#{post_id}"
		end

		# performs a wordpress login
		# returns the session cookie on successful login, nil otherwise
		def wp_login(user, pass)
			redirect = "#{target_uri}#{Rex::Text.rand_text_alpha(8)}"
			res = send_request_cgi({
																 'method' => 'POST',
																 'uri' => wp_uri_login,
																 'data' => _wp_login_post_data(user, pass, redirect),
														 }, 20)

			if res and res.code == 302 and res.headers['Location'] == redirect
				match = res.get_cookies.match(/(wordpress(?:_sec)?_logged_in_[^=]+=[^;]+);/i)
				if match
					# return wordpress login cookie
					return match[0]
				end
			end
			return nil
		end

		def wp_user_exists?(user)
			res = send_request_cgi({
																 'method' => 'POST',
																 'uri' => wp_uri_login,
																 'data' => _wp_login_post_data(user, 'x'),
														 }, 20)

			exists = false
			if res and res.code == 200
				if res.body.to_s =~ /Incorrect password/ or
						res.body.to_s =~ /document\.getElementById\('user_pass'\)/
					exists = true
				else
					exists = false
				end
			end
			return exists
		end

		def wp_post_comment_auth(comment, comment_post_id, login_cookie)
			_wp_post_comment(comment, comment_post_id, login_cookie, nil, nil, nil)
		end

		def wp_post_comment_no_auth(comment, comment_post_id, author, email, url)
			_wp_post_comment(comment, comment_post_id, nil, author, email, url)
		end

		def wp_get_valid_post_id(login_cookie=nil)
			_wp_get_valid_post_id(false, login_cookie)
		end

		def wp_get_valid_post_id_with_comments_enabled(login_cookie=nil)
			_wp_get_valid_post_id(true, login_cookie)
		end

		def wp_post_comments_enabled?(post_id, login_cookie=nil)
			_wp_check_post_id(wp_url_post(post_id), true, login_cookie)
		end

		private

		def _wp_login_post_data(user, pass, redirect=nil)
			post_data = "log=#{Rex::Text.uri_encode(user.to_s)}"
			post_data << "&pwd=#{Rex::Text.uri_encode(pass.to_s)}"
			post_data << "&redirect_to=#{Rex::Text.uri_encode(redirect.to_s)}"
			post_data << '&wp-submit=Login'
			post_data
		end

		def _wp_post_comment(comment, comment_post_id, login_cookie, author, email, url)
			vars_post = {
					'comment' => comment,
					'submit' => 'Post+Comment',
					'comment_post_ID' => comment_post_id.to_s,
					'comment_parent' => '0'
			}
			vars_post.merge!({
													 'author' => author,
													 'email' => email,
													 'url' => url,
											 }) unless login_cookie

			options = {
					'uri' => normalize_uri(target_uri.path, 'wp-comments-post.php'),
					'method' => 'POST'
			}
			options.merge!({'vars_post' => vars_post})
			options.merge!({'cookie' => login_cookie}) if login_cookie
			res = send_request_cgi(options)
			if res and res.code == 302
				location = URI(res.headers['Location'])
				return location
			else
				return nil
			end
		end

		def _wp_get_valid_post_id(comments_enabled=false, login_cookie=nil)
			(1..1000).each { |id|
				vprint_status("#{rhost}:#{rport} - Checking POST ID #{id}...") if (id % 100) == 0
				body = _wp_check_post_id(wp_url_post(id), comments_enabled, login_cookie)
				return id if body
			}
			# no post found
			return nil
		end

		def _wp_check_post_id(uri, comments_enabled=false, login_cookie=nil)
			options = {
					'method' => 'GET',
					'uri' => uri
			}
			options.merge!({'cookie' => login_cookie}) if login_cookie
			res = send_request_cgi(options)
			# post exists
			if res and res.code == 200
				# also check if comments are enabled
				if comments_enabled
					if res.body =~ /form.*action.*wp-comments-post\.php/
						return res.body
					else
						return nil
					end
				# valid post found, not checking for comments
				else
					return res.body
				end
			elsif res and (res.code == 301 or res.code == 302) and res.headers['Location']
				location = URI(res.headers['Location'])
				uri = location.path
				uri << "?#{location.query}" unless location.query.nil? or location.query.empty?
				return _wp_check_post_id(uri, comments_enabled)
			end
			return nil
		end

	end
end
