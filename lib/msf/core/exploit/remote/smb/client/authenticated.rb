# -*- coding: binary -*-

module Msf

# Mini-mixin for making SMBUser/SMBPass/SMBDomain regular options vs advanced
# Included when the module needs credentials to function
module Exploit::Remote::SMB::Client::Authenticated

  include Msf::Exploit::Remote::SMB::Client

  def initialize(info = {})
    super
    register_options(
      [
        OptString.new('SMBUser', [ false, 'The username to authenticate as', ''], fallbacks: ['USERNAME']),
        OptString.new('SMBPass', [ false, 'The password for the specified username', ''], fallbacks: ['PASSWORD']),
        OptString.new('SMBDomain',  [ false, 'The Windows domain to use for authentication', '.'], fallbacks: ['DOMAIN']),
      ], Msf::Exploit::Remote::SMB::Client::Authenticated)

    register_advanced_options(
      [
        OptEnum.new('SMBAuth', [true, 'The Authentication mechanism to use', Msf::Exploit::Remote::AuthOption::AUTO, Msf::Exploit::Remote::AuthOption::SMB_OPTIONS]),
        OptString.new('SmbRhostname', [false, 'The rhostname which is required for kerberos']),
        OptAddress.new('DomainControllerRhost', [false, 'The resolvable rhost for the Domain Controller']),
        OptPath.new('SmbKrb5Ccname', [false, 'The ccache file to use for kerberos authentication', ENV.fetch('SMBKRB5CCNAME', ENV.fetch('KRB5CCNAME', nil))], conditions: %w[ SMBAuth == kerberos ]),
        OptBool.new('KrbUseCachedCredentials', [false, 'Use credentials stored in the database for kerberos authentication', false], conditions: %w[ SMBAuth == kerberos ]),
        OptBool.new('KrbStoreCredentialCache', [false, 'Store Kerberos TGS MIT Credential Cache to the database if authentication succeed', true], conditions: %w[ SMBAuth == kerberos ]),
        OptString.new('SmbKrbOfferedEnctypes', [true, 'The offered kerberos enc types', Msf::Exploit::Remote::AuthOption::KERBEROS_DEFAULT_OFFERED_ENC_TYPES.join(',')])
      ],
      Msf::Exploit::Remote::SMB::Client::Authenticated
    )
  end
end

end
