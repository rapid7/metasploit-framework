module Msf
  ###
  #
  # This module exposes methods for querying a remote LDAP service
  #
  ###
  module Exploit::Remote::LDAP
    module ActiveDirectory
      include Msf::Exploit::Remote::LDAP
      include Msf::Exploit::Remote::LDAP::EntryCache
      include Msf::Exploit::Remote::LDAP::ActiveDirectory::SecurityDescriptorMatcher

      LDAP_CAP_ACTIVE_DIRECTORY_OID = '1.2.840.113556.1.4.800'.freeze
      LDAP_SERVER_SD_FLAGS_OID = '1.2.840.113556.1.4.801'.freeze
      OWNER_SECURITY_INFORMATION = 0x1
      GROUP_SECURITY_INFORMATION = 0x2
      DACL_SECURITY_INFORMATION = 0x4
      SACL_SECURITY_INFORMATION = 0x8

      # Query the remote server via the provided LDAP connection to determine if it's an Active Directory LDAP server.
      # More specifically, this ensures that it reports active directory capabilities and the whoami extension.
      #
      # @param Net::LDAP::Connection ldap_connection
      # @rtype Boolean
      def is_active_directory?(ldap)
        root_dse = ldap.search(
          ignore_server_caps: true,
          base: '',
          scope: Net::LDAP::SearchScope_BaseObject,
          attributes: %i[ supportedCapabilities supportedExtension ]
        )&.first

        return false unless root_dse[:supportedCapabilities].map(&:to_s).include?(LDAP_CAP_ACTIVE_DIRECTORY_OID)

        return false unless root_dse[:supportedExtension].include?(Net::LDAP::WhoamiOid)

        true
      end

      # Build a control blob that will fetch all security descriptor data but the SACL. This often enables reading a
      # security descriptor's DACL without the need for elevated permissions.
      #
      # @rtype String
      def adds_build_ldap_sd_control(owner: true, group: true, dacl: true, sacl: false)
        # Set the value of LDAP_SERVER_SD_FLAGS_OID flag so everything but
        # the SACL flag is set, as we need administrative privileges to retrieve
        # the SACL from the ntSecurityDescriptor attribute on Windows AD LDAP servers.
        #
        # Note that without specifying the LDAP_SERVER_SD_FLAGS_OID control in this manner,
        # the LDAP searchRequest will default to trying to grab all possible attributes of
        # the ntSecurityDescriptor attribute, hence resulting in an attempt to retrieve the
        # SACL even if the user is not an administrative user.
        #
        # Now one may think that we would just get the rest of the data without the SACL field,
        # however in reality LDAP will cause that attribute to just be blanked out if a part of it
        # cannot be retrieved, so we just will get nothing for the ntSecurityDescriptor attribute
        # in these cases if the user doesn't have permissions to read the SACL.
        flags = 0
        flags |= OWNER_SECURITY_INFORMATION if owner
        flags |= GROUP_SECURITY_INFORMATION if group
        flags |= DACL_SECURITY_INFORMATION if dacl
        flags |= SACL_SECURITY_INFORMATION if sacl
        control_values = [flags].map(&:to_ber).to_ber_sequence.to_s.to_ber
        [LDAP_SERVER_SD_FLAGS_OID.to_ber, true.to_ber, control_values].to_ber_sequence
      end

      # Query LDAP and obtain all members of a particular group. In this context, "members" are either users or groups.
      #
      # @param [Net::LDAP::Connection] ldap The LDAP connection to use for querying.
      # @param [String] group_dn The DN of the group to obtain members for.
      # @param [String] base_dn An optional base search DN.
      # @param [Boolean] inherited Whether or not to include entities that are members by inheritance.
      # @param [String] object_class An optional object class for filtering. This is typically either 'user' or 'group'.
      def adds_query_group_members(ldap, group_dn, base_dn: nil, inherited: true, object_class: nil)
        return enum_for(:adds_query_group_members, ldap, group_dn, base_dn: base_dn, inherited: inherited, object_class: object_class) unless block_given?
        results = 0

        member_filter = "memberOf#{inherited ? ':1.2.840.113556.1.4.1941:' : ''}=#{ldap_escape_filter(group_dn)}"

        # Get the member's primaryGroupID
        group = adds_get_object_by_dn(ldap, group_dn)
        if group && group[:objectSID]
          group_sid = Rex::Proto::MsDtyp::MsDtypSid.read(group[:objectSID].first)
          # if we have a group RID, filter on that when the object has it as it's primaryGroupId to include those groups too
          member_filter = "|(#{member_filter})(primaryGroupId=#{group_sid.rid})"
        end

        filters = []
        filters << "objectClass=#{ldap_escape_filter(object_class)}" if object_class
        filters << member_filter

        ldap.search(
          base: base_dn || ldap.base_dn,
          controls: [adds_build_ldap_sd_control],
          filter: "(&#{filters.map { "(#{_1})" }.join})",
          return_result: false # make sure we're streaming because this could be a lot of data
        ) do |ldap_entry|
          yield ldap_entry
          results += 1
        end

        unless ldap.get_operation_result.code == 0
          raise "LDAP Error: #{ldap.get_operation_result.message}"
        end

        results
      end

      # Query LDAP and obtain all groups a particular entity is a member of. In this context, "members" are either users or groups.
      #
      # @param [Net::LDAP::Connection] ldap The LDAP connection to use for querying.
      # @param [String] member_dn The DN of the member to obtain groups for.
      # @param [String] base_dn An optional base search DN.
      # @param [Boolean] inherited Whether or not to include groups that are inherited.
      def adds_query_member_groups(ldap, member_dn, base_dn: nil, inherited: true)
        return enum_for(:adds_query_member_groups, ldap, member_dn, base_dn: base_dn, inherited: inherited) unless block_given?
        results = 0

        # Get the member's primaryGroupId
        member = adds_get_object_by_dn(ldap, member_dn)
        if member && member[:objectSid] && member[:primaryGroupId] && !member[:primaryGroupId].empty?
          # if it's found, calculate the SID of the primary group and query it, the primary group is typically 'Domain Users'
          # and is *not* included in the member query
          member_sid = Rex::Proto::MsDtyp::MsDtypSid.read(member[:objectSid].first)
          primary_group_sid = "#{member_sid.to_s.rpartition('-').first}-#{member[:primaryGroupId].first}"
          primary_group = adds_get_object_by_sid(ldap, primary_group_sid)
          yield primary_group if primary_group
        end

        filters = []
        filters << "objectClass=group"
        filters << "member#{inherited ? ':1.2.840.113556.1.4.1941:' : ''}=#{ldap_escape_filter(member_dn)}"

        ldap.search(
          base: base_dn || ldap.base_dn,
          controls: [adds_build_ldap_sd_control],
          filter: "(&#{filters.map { "(#{_1})" }.join})",
          return_result: false
        ) do |ldap_entry|
          yield ldap_entry
          results += 1
        end

        unless ldap.get_operation_result.code == 0
          raise "LDAP Error: #{ldap.get_operation_result.message}"
        end

        results
      end

      # Obtain a particular entity by its distinguished name (DN).
      #
      # @param [Net::LDAP::Connection] ldap The LDAP connection to use for querying.
      # @param [String] object_dn The full distinguished name of the object to retrieve.
      # @return Returns nil when the object was not found.
      # @rtype [Net::LDAP::Entry,nil]
      def adds_get_object_by_dn(ldap, object_dn)
        object = ldap_entry_cache.get_by_dn(object_dn)
        return object if object

        object = ldap.search(base: object_dn, controls: [adds_build_ldap_sd_control], scope: Net::LDAP::SearchScope_BaseObject)&.first
        validate_query_result!(ldap.get_operation_result.table)

        ldap_entry_cache << object if object
        object
      end

      # Obtain a particular entity by its sAMAccountName.
      #
      # @param [Net::LDAP::Connection] ldap The LDAP connection to use for querying.
      # @param [String] object_samaccountname The sAMAccountName of the object to retrieve.
      # @return Returns nil when the object was not found.
      # @rtype [Net::LDAP::Entry,nil]
      def adds_get_object_by_samaccountname(ldap, object_samaccountname)
        object = ldap_entry_cache.get_by_samaccountname(object_samaccountname)
        return object if object

        filter = "(sAMAccountName=#{ldap_escape_filter(object_samaccountname)})"
        begin
          object = ldap.search(base: ldap.base_dn, controls: [adds_build_ldap_sd_control], filter: filter)&.first
        rescue Net::LDAP::Error => e
          elog('ldap search error for sAMAccountName', error: e)
          return nil
        end
        validate_query_result!(ldap.get_operation_result.table, filter)

        ldap_entry_cache << object if object
        object
      end

      # Obtain a particular entity by its SID.
      #
      # @param [Net::LDAP::Connection] ldap The LDAP connection to use for querying.
      # @param [String] object_sid The SID of the object to retrieve.
      # @return Returns nil when the object was not found.
      # @rtype [Net::LDAP::Entry,nil]
      def adds_get_object_by_sid(ldap, object_sid)
        object_sid = Rex::Proto::MsDtyp::MsDtypSid.new(object_sid)
        object = ldap_entry_cache.get_by_sid(object_sid)
        return object if object

        filter = "(objectSID=#{ldap_escape_filter(object_sid.to_s)})"
        object = ldap.search(base: ldap.base_dn, controls: [adds_build_ldap_sd_control], filter: filter)&.first
        validate_query_result!(ldap.get_operation_result.table, filter)

        ldap_entry_cache << object if object
        object
      end

      # Get the LDAP object that describes the current user.
      #
      # @param [Net::LDAP::Connection] ldap The LDAP connection to use for querying.
      # @rtype [Net::LDAP::Entry]
      def adds_get_current_user(ldap)
        whoami = @ldap_whoami = (@ldap_whoami || ldap.ldapwhoami.to_s)
        our_domain, _, our_username = whoami.delete_prefix('u:').partition('\\')
        # todo: this is probably going to have issues if our user is from a domain that the target server is not the
        # authority of
        adds_get_object_by_samaccountname(ldap, our_username)
      end

      # Get the AD DS domain info for the current server.
      #
      # @param [Net::LDAP::Connection] ldap The LDAP connection to use for querying.
      # @rtype [Hash]
      def adds_get_domain_info(ldap)
        domain_object = ldap.search(base: ldap.base_dn, filter: '(objectClass=domain)', return_result: true)&.first
        return nil unless domain_object

        ldap_entry_cache << domain_object
        domain_sid = Rex::Proto::MsDtyp::MsDtypSid.read(domain_object[:objectSid].first)

        root_dse = ldap.search(
          base: '',
          scope: Net::LDAP::SearchScope_BaseObject,
          attributes: %i[configurationNamingContext]
        )&.first
        return nil unless root_dse

        xrefs = ldap.search(
          base: root_dse[:configurationNamingContext].first,
          filter: "(&(objectCategory=crossref)(nETBIOSName=*)(nCName=#{ldap.base_dn}))"
        )
        return nil unless xrefs&.length == 1

        xref = xrefs.first
        ldap_entry_cache << xref

        {
          netbios_name: xref[:nETBIOSName].first.to_s,
          dns_name: xref[:dNSRoot].first.to_s,
          sid: domain_sid
        }
      end

      # Determine if a security descriptor will grant the permissions identified by *matcher* to the
      # *test_sid*.
      #
      # @param [Net::LDAP::Connection] ldap The LDAP connection to use for querying.
      # @param [Rex::Proto::MsDtyp::MsDtypSecurityDescriptor] security_descriptor The security descriptor object to
      #   evaluate.
      # @param [SecurityDescriptorMatcher::Base] matcher An object that will match ACEs that allow or deny the desired permissions.
      # @param [Rex::Proto::MsDtyp::MsDtypSid] test_sid The SID to check for access.
      # @param [Rex::Proto::MsDtyp::MsDtypSid] self_sid The SID of the object who owns the security_descriptor. This is
      #   typically the objectSid LDAP attribute and is used when the security descriptor references the special 'SELF'
      #   entity.
      def adds_sd_grants_permissions?(ldap, security_descriptor, matcher, test_sid: nil, self_sid: nil)
        unless test_sid
          current_user = adds_get_current_user(ldap)
          raise RuntimeError.new('No SID was specified and the current user could not be identified.') unless current_user

          test_sid = Rex::Proto::MsDtyp::MsDtypSid.read(current_user[:objectSid].first)
        end

        test_member_sids = nil

        dacl_aces = []
        # because deny entries take precedence, process them first
        dacl_aces += security_descriptor.dacl.aces.select { |ace| Rex::Proto::MsDtyp::MsDtypAceType.deny?(ace.header.ace_type) }
        dacl_aces += security_descriptor.dacl.aces.select { |ace| Rex::Proto::MsDtyp::MsDtypAceType.allow?(ace.header.ace_type) }

        dacl_aces.each do |ace|
          # Uncomment this if you need to debug ACE evaluation
          # ldap_object = adds_get_object_by_sid(ldap, ace.body.sid)
          # $stderr.puts  "ACE:"
          # $stderr.puts  "  Type:        #{Rex::Proto::MsDtyp::MsDtypAceType.name(ace.header.ace_type)}"
          # $stderr.puts  "  Permissions: #{ace.body.access_mask.permissions.map(&:to_s).join(', ')}"
          # $stderr.write "  SID:         #{ace.body.sid}"
          # $stderr.puts (ldap_object && ldap_object[:sAMAccountName].first) ? " (#{ldap_object[:sAMAccountName].first})" : ""
          # $stderr.puts "  Object:      #{ace.body.object_type}" if Rex::Proto::MsDtyp::MsDtypAceType.has_object?(ace.header.ace_type)

          next if matcher.ignore_ace?(ace)

          case ace.body.sid
          when Rex::Proto::Secauthz::WellKnownSids::SECURITY_WORLD_SID
            matcher.apply_ace!(ace)
          when Rex::Proto::Secauthz::WellKnownSids::SECURITY_PRINCIPAL_SELF_SID
            matcher.apply_ace!(ace) if self_sid == test_sid
          when Rex::Proto::Secauthz::WellKnownSids::SECURITY_CREATOR_OWNER_SID
            matcher.apply_ace!(ace) if security_descriptor.owner_sid == test_sid
          when Rex::Proto::Secauthz::WellKnownSids::SECURITY_CREATOR_GROUP_SID
            matcher.apply_ace!(ace) if security_descriptor.group_sid == test_sid
          when test_sid
            matcher.apply_ace!(ace)
          else
            ldap_object = adds_get_object_by_sid(ldap, ace.body.sid)
            next unless ldap_object && ldap_object[:objectClass].include?('group')

            member_sids = adds_query_group_members(ldap, ldap_object.dn, inherited: false).map { |member| Rex::Proto::MsDtyp::MsDtypSid.read(member[:objectSid].first) }
            if member_sids.include?(test_sid)
              matcher.apply_ace!(ace)
              next
            end

            if test_member_sids.nil?
              test_obj = adds_get_object_by_sid(ldap, test_sid)
              test_member_sids = adds_query_member_groups(ldap, test_obj.dn, inherited: true).map { |member| Rex::Proto::MsDtyp::MsDtypSid.read(member[:objectSid].first) }.to_set
              if test_obj[:objectClass].include?('user') && test_sid.rid != Rex::Proto::Secauthz::WellKnownSids::DOMAIN_USER_RID_GUEST
                test_member_sids << Rex::Proto::Secauthz::WellKnownSids::SECURITY_AUTHENTICATED_USER_SID
                test_member_sids << Rex::Proto::Secauthz::WellKnownSids::DOMAIN_ALIAS_SID_USERS
              end
            end

            matcher.apply_ace!(ace) if member_sids.any? { |member_sid| test_member_sids.include?(member_sid) }
          end

          break if matcher.satisfied?
        end

        matcher.matches?
      end

      # Determine if a security descriptor will grant the permissions identified by *matcher* to the
      # *test_sid*. For this to work, the authenticated user typically needs "Read permissions", and "Read general
      # information" from the advanced "Permission Entry" form in Active Directory. The more generic, "Read properties"
      # permission will also do the trick.
      #
      # @param [Net::LDAP::Connection] ldap The LDAP connection to use for querying.
      # @param [Net::LDAP::Entry] obj The LDAP object to test. The security descriptor will be taken from the
      #   nTSecurityDescriptor attribute.
      # @param [#call] matcher An object that will match ACEs that allow or deny the desired permissions.
      # @param [Rex::Proto::MsDtyp::MsDtypSid] test_sid The SID to check for access.
      def adds_obj_grants_permissions?(ldap, obj, matcher, test_sid: nil)
        unless obj[:nTSecurityDescriptor].first
          raise RuntimeError.new('The nTSecurityDescriptor can not be read from the object.')
        end

        security_descriptor = Rex::Proto::MsDtyp::MsDtypSecurityDescriptor.read(obj[:nTSecurityDescriptor].first)
        self_sid = nil
        if obj[:objectSid]&.first
          self_sid = Rex::Proto::MsDtyp::MsDtypSid.read(obj[:objectSid].first)
        end

        adds_sd_grants_permissions?(ldap, security_descriptor, matcher, test_sid: test_sid, self_sid: self_sid)
      end
    end
  end
end
