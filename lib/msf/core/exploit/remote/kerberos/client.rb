# -*- coding: binary -*-

module Msf
  class Exploit
    class Remote
      module Kerberos
        module Client
          include Msf::Exploit::Remote::Kerberos::Client::Base
          include Msf::Exploit::Remote::Kerberos::Client::AsRequest
          include Msf::Exploit::Remote::Kerberos::Client::AsResponse
          include Msf::Exploit::Remote::Kerberos::Client::TgsRequest
          include Msf::Exploit::Remote::Kerberos::Client::TgsResponse
          include Msf::Exploit::Remote::Kerberos::Client::Pac
          include Msf::Exploit::Remote::Kerberos::Client::CacheCredential

          # @!attribute client
          #   @return [Rex::Proto::Kerberos::Client] The kerberos client
          attr_accessor :client

          def initialize(info = {})
            super

            register_options(
              [
                Opt::RHOST,
                Opt::RPORT(88),
                OptInt.new('Timeout', [true, 'The TCP timeout to establish connection and read data', 10])
              ], self.class
            )
          end

          # Returns the target host
          #
          # @return [String]
          def rhost
            datastore['RHOST']
          end

          # Returns the remote port
          #
          # @return [Integer]
          def rport
            datastore['RPORT']
          end

          # Returns the TCP timeout
          #
          # @return [Integer]
          def timeout
            datastore['Timeout']
          end

          # Returns the kdc peer
          #
          # @return [String]
          def peer
            "#{rhost}:#{rport}"
          end

          # Creates a kerberos connection
          #
          # @param opts [Hash{Symbol => <String, Integer>}]
          # @option opts [String] :rhost
          # @option opts [<String, Integer>] :rport
          # @return [Rex::Proto::Kerberos::Client]
          def connect(opts={})
            kerb_client = Rex::Proto::Kerberos::Client.new(
              host: opts[:rhost] || rhost,
              port: (opts[:rport] || rport).to_i,
              timeout: (opts[:timeout] || timeout).to_i,
              context:
                {
                  'Msf'        => framework,
                  'MsfExploit' => self,
                },
              protocol: 'tcp'
            )

            disconnect if client
            self.client = kerb_client

            kerb_client
          end

          # Disconnects the Kerberos client
          #
          # @param kerb_client [Rex::Proto::Kerberos::Client] the client to disconnect
          def disconnect(kerb_client = client)
            kerb_client.close if kerb_client

            if kerb_client == client
              self.client = nil
            end
          end

          # Performs cleanup as necessary, disconnecting the Kerberos client
          # if it's still established.
          def cleanup
            super
            disconnect
          end

          # Sends a kerberos AS request and reads the response
          #
          # @param opts [Hash]
          # @return [Rex::Proto::Kerberos::Model::KdcResponse]
          # @see Msf::Kerberos::Client::AsRequest#build_as_request
          # @see Rex::Proto::Kerberos::Model::KdcResponse
          def send_request_as(opts = {})
            connect(opts)
            req = opts.fetch(:req) { build_as_request(opts) }
            res = client.send_recv(req)
            disconnect
            res
          end

          # Sends a kerberos AS request and reads the response
          #
          # @param opts [Hash]
          # @return [Rex::Proto::Kerberos::Model::KdcResponse]
          # @see Msf::Kerberos::Client::TgsRequest#build_tgs_request
          # @see Rex::Proto::Kerberos::Model::KdcResponse
          def send_request_tgs(opts = {})
            connect(opts)
            req = opts.fetch(:req) { build_tgs_request(opts) }
            res = client.send_recv(req)
            disconnect
            res
          end

          # Sends the required kerberos AS requests for a kerberos Ticket Granting Ticket
          #
          # @param options [Hash]
          # @return [Msf::Exploit::Remote::Kerberos::Model::Tgt] ticket granting ticket
          # @raise [Rex::Proto::Kerberos::Model::Error::KerberosError] if the provided credentials are invalid
          def send_request_tgt(options = {})
            realm = options[:realm]
            server_name = options[:server_name]
            client_name = options[:client_name]
            password = options[:password]
            request_pac = options.fetch(:request_pac, true)

            # NOTE: This should be improved to properly negotiate encryption with the server, with graceful fallbacks etc. For now RC4_HMAC is hardcoded.
            desired_encryption_type = Rex::Proto::Kerberos::Crypto::RC4_HMAC

            unicode_password = Rex::Text.to_unicode(password)
            password_digest = OpenSSL::Digest.digest('MD4', unicode_password)

            # First stage: Send an initial AS-REQ request, used to exchange supported encryption methods.
            # The server may respond with a ticket granting ticket (TGT) immediately,
            # or the client may require preauthentication, and a second AS-REQ is required

            now = Time.now.utc
            expiry_time = now + 1.day
            initial_as_req = build_as_request(
              pa_data: [
                build_pa_pac_request(pac_request_value: request_pac)
              ],
              body: build_as_request_body(
                client_name: client_name,
                server_name: server_name,
                realm: realm,

                etype: [desired_encryption_type],

                # Specify nil to ensure the KDC uses the current time for the desired starttime of the requested ticket
                from: nil,
                till: expiry_time,
                rtime: expiry_time
              )
            )

            initial_as_res = send_request_as(req: initial_as_req)

            # If we receive a AS_REP response immediately, no-preauthentication was required and we can return immediately
            if initial_as_res.msg_type == Rex::Proto::Kerberos::Model::AS_REP
              return Msf::Exploit::Remote::Kerberos::Model::TgtResponse.new(
                as_rep: initial_as_res,
                preauth_required: false,
                decrypted_part: nil
              )
            end

            # Verify error codes. Anything other than the server requiring an additional preauth request is considered a failure.
            if initial_as_res.msg_type == Rex::Proto::Kerberos::Model::KRB_ERROR && initial_as_res.error_code != Rex::Proto::Kerberos::Model::Error::ErrorCodes::KDC_ERR_PREAUTH_REQUIRED
              if initial_as_res.error_code == Rex::Proto::Kerberos::Model::Error::ErrorCodes::KDC_ERR_ETYPE_NOSUPP
                raise Rex::Proto::Kerberos::Model::Error::KerberosEncryptionNotSupported.new(encryption_type: desired_encryption_type)
              end

              raise ::Rex::Proto::Kerberos::Model::Error::KerberosError.new(res: initial_as_res)
            end

            # Second stage: Send an additional AS-REQ request with preauthentication provided
            # Note that Clock skew issues may be raised at this point

            preauth_as_req = build_as_request(
              pa_data: [
                build_as_pa_time_stamp(key: password_digest, etype: desired_encryption_type),
                build_pa_pac_request(pac_request_value: request_pac)
              ],
              body: build_as_request_body(
                client_name: client_name,
                server_name: server_name,
                realm: realm,
                key: password_digest,

                etype: [desired_encryption_type],

                # Specify nil to ensure the KDC uses the current time for the desired starttime of the requested ticket
                from: nil,
                till: expiry_time,
                rtime: expiry_time
              )
            )

            preauth_as_res = send_request_as(req: preauth_as_req)
            if preauth_as_res.msg_type != Rex::Proto::Kerberos::Model::AS_REP
              raise ::Rex::Proto::Kerberos::Model::Error::KerberosError.new(res: preauth_as_res)
            end

            Msf::Exploit::Remote::Kerberos::Model::TgtResponse.new(
              as_rep: preauth_as_res,
              preauth_required: true,
              decrypted_part: decrypt_kdc_as_rep_enc_part(preauth_as_res, password_digest),
            )
          end
        end
      end
    end
  end
end
