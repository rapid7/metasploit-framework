# -*- coding: binary -*-
require 'msf/core'
require 'msf/core/module'
require 'msf/core/module/failure'

###
#
# The exploit class acts as the base class for all exploit modules.  It
# provides a common interface for interacting with exploits at the most basic
# level.
#
###
class Msf::Exploit < Msf::Module
  self.module_type = Metasploit::Model::Module::Type::EXPLOIT

  require 'msf/core/exploit/autofilter'
  include Msf::Exploit::Autofilter

  require 'msf/core/exploit/capabilities'
  include Msf::Exploit::Capabilities

  require 'msf/core/exploit/compatibility'
  include Msf::Exploit::Compatibility

  require 'msf/core/exploit/failure'
  include Msf::Exploit::Failure

  require 'msf/core/exploit/payload'
  include Msf::Exploit::Payload

  require 'msf/core/exploit/session'
  include Msf::Exploit::Session

  require 'msf/core/exploit/stance'
  include Msf::Exploit::Stance

  require 'msf/core/exploit/targets'
  include Msf::Exploit::Targets

  require 'msf/core/exploit/text'
  include Msf::Exploit::Text

  #
  # Attributes
  #

  # @!attribute [r] exploit_type
  #   The type of exploit this exploit is.
  #
  #   @return [String]
  #   @see Msf::Exploit::Type
  def exploit_type
    Msf::Type::Omni
  end

  #
  # Methods
  #

  #
  # Performs any cleanup that may be necessary, such as disconnecting
  # connections and any other such fun things.  If a payload is active then
  # its handler cleanup routines are called as well.
  #
  def cleanup
    if (payload_instance and handler_enabled?)
      payload_instance.cleanup_handler
    end
    self.abort_sockets if self.respond_to?(:abort_sockets)
  end

  #
  # Kicks off the actual exploit.  Prior to this call, the framework will
  # have validated the data store using the options associated with this
  # exploit module.  It will also pre-generate the desired payload, though
  # exploits can re-generate the payload if necessary.
  #
  # This method is designed to be overriden by exploit modules.
  #
  def exploit
  end

  #
  # Creates an instance of the exploit module.  Mad skillz.
  #
  def initialize(info = {})

    # Ghetto compat mirroring for payload compatibilities.  This mirrors
    #
    # Payload => Compat => xyz
    #
    # to
    #
    # Compat => Payload => xyz
    if (info['Payload'] and info['Payload']['Compat'])
      info['Compat'] = Hash.new if (info['Compat'] == nil)
      info['Compat']['Payload'] = Hash.new if (info['Compat']['Payload'] == nil)
      info['Compat']['Payload'].update(info['Payload']['Compat'])
    end

    # Call the parent constructor after making any necessary modifications
    # to the information hash.
    super(info)

    self.payload_info = info['Payload'] || {}
    self.successful = false
    self.session_count = 0
    self.active_timeout = 120
    self.fail_reason = Msf::Module::Failure::None

    if (info['Payload'] and info['Payload']['ActiveTimeout'])
      self.active_timeout = info['Payload']['ActiveTimeout'].to_i
    end

    # All exploits can increase the delay when waiting for a session.
    # However, this only applies to aggressive exploits.
    if aggressive?
      register_advanced_options(
        [
          Msf::OptInt.new('WfsDelay', [ false, "Additional delay when waiting for a session", 0 ])
        ], Msf::Exploit)
    end

    # Allow all exploits to leverage context keyed encoding
    register_advanced_options(
      [
        Msf::OptBool.new('EnableContextEncoding', [ false, "Use transient context when encoding payloads", false ]),
        Msf::OptPath.new('ContextInformationFile', [ false, "The information file that contains context information", nil ])
      ], Msf::Exploit)

    # Allow all exploits to disable their payload handlers
    register_advanced_options(
      [
        Msf::OptBool.new('DisablePayloadHandler', [ false, "Disable the handler code for the selected payload", false ])
      ], Msf::Exploit)
  end

  #
  # Prepares the module for exploitation, initializes any state, and starts
  # the payload handler.
  #
  def setup
    # Reset the session counts to zero.
    reset_session_counts

    return if not payload_instance
    return if not handler_enabled?

    # Configure the payload handler
    payload_instance.exploit_config = {
      'active_timeout' => self.active_timeout
    }

    # Set up the payload handlers
    payload_instance.setup_handler

    # Start the payload handler
    payload_instance.start_handler

  end
end

#
# Load all of the exploit mixins
#
require 'msf/core/exploit/mixins'