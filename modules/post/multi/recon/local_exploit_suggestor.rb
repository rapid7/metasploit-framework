##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'

class Metasploit3 < Msf::Post

  def initialize(info={})
    super(update_info(info,
        'Name'          => 'Multi Recon Local Exploit Suggestor',
        'Description'   => %q{
          This module suggests local meterpreter exploits that can be used. The
          exploits are suggested based on the architecture and platform that
          the user has a shell opened as well as the available exploits in
          meterpreter. Additionally, the ShowDescription option can be set
          to 'true' to a detailed description on the suggested exploits.

          It's important to note that not all local exploits will be fired. For
          example, if a module doesn't have a default datastore option that is
          required for it to run, then it will not come up in the suggestor's
          results.
        },
        'License'       => MSF_LICENSE,
        'Author'        => [ 'sinn3r',
                             'Mo'
                           ],
        'Platform'      => all_platforms,
        'SessionTypes'  => [ 'meterpreter', 'shell' ]
    ))

    register_options([
      Msf::OptInt.new('SESSION', [ true, "The session to run this module on." ]),
      Msf::OptBool.new('ShowDescription', [true, "Displays a detailed description for the available exploits", false])
    ],Msf::Post)
  end


  def all_platforms
    Msf::Module::Platform.subclasses.collect {|c| c.realname.downcase }
  end


  def get_target_arch
    @target_arch ||= lambda {
      return nil unless session
      session.platform.split('/').first
    }.call
  end


  def get_target_platform
    @target_platform ||= lambda {
      return nil unless session
      platform = session.platform.split('/').second

      if platform =~ /^win/
        platform = 'win'
      end

      return platform
    }.call
  end


  def is_module_arch?(mod)
    mod_arch = mod.target.arch || mod.arch
    mod_arch.include?(get_target_arch)
  end

  def is_module_options_ready?(mod)
    mod.options.each_pair do |option_name, option|
      if option.required && option.default.nil? && mod.datastore[option_name].blank?
        return false
      end
    end
    true
  end

  def is_module_platform?(mod)
    platform_obj = nil
    begin
      platform_obj = Msf::Module::Platform.find_platform(get_target_platform)
    rescue ArgumentError
      # When not found, find_platform raises an ArgumentError
      return false
    end
    module_platforms = mod.target.platform ? mod.target.platform.platforms : mod.platform.platforms
    module_platforms.include?(platform_obj)
  end

  def set_module_options(mod)
    mod.datastore.merge!(self.datastore)
    mod.datastore['SESSION'] = session.sid if !mod.datastore['SESSION'] && session
  end

  def setup
    print_status "Collecting local exploits..."
    #Initializes an array
    @local_exploits = []
    # Collects exploits into an array
    framework.exploits.each do |name, obj|
      mod = framework.exploits.create(name)
      next unless mod
      set_module_options(mod)
        if mod.kind_of?(Msf::Exploit::Local) &&
          mod.respond_to?(:check)  &&
          is_module_platform?(mod) &&
          is_module_arch?(mod) &&
          is_module_options_ready?(mod)
         @local_exploits << mod
        end
      end
  end

  def run
    @local_exploits.each do |m|
    begin
      checkcode = m.check
        # See def is_check_interesting?
        if is_check_interesting?(checkcode)
          # Prints the full name and the checkcode message for the exploit
          print_good("#{m.fullname}: #{checkcode.second}")
          #If the datastore option is true, a detailed description will show
          if datastore['ShowDescription']
            # Formatting for the description text
            print_line("\n")
            print_line Rex::Text.wordwrap(Rex::Text.compress(m.description), 2, 70)
          end
          else
            # Prints the full name and the checkcode message for the exploit
            vprint_status("#{m.fullname}: #{checkcode.second}")
          end
     # Creates a log record in framework.log
        rescue ::Exception => e
          elog("#{e.class} #{e.message}\n#{e.backtrace * "\n"}")
          vprint_error("#{m.shortname} failled to run: #{e.message}")
        end
      end
        if @local_exploits.length < 1
          print_error "No suggestions available. "
        end
  end

  def is_check_interesting?(checkcode)
    [
      Msf::Exploit::CheckCode::Vulnerable,
      Msf::Exploit::CheckCode::Appears,
      Msf::Exploit::CheckCode::Detected
    ].include?(checkcode)
  end

  def print_status(msg='')
    super("#{session.sock.peerhost} - #{msg}")
  end

  def print_good(msg='')
    super("#{session.sock.peerhost} - #{msg}")
  end

  def print_error(msg='')
    super("#{session.sock.peerhost} - #{msg}")
  end
end
